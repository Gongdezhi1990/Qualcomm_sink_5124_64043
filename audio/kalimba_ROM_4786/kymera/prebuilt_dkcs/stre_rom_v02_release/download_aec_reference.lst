
/home/svc-audio-dspsw/kymera_builds/builds/2019/kymera_1907221320/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_aec_reference.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_set_rate_monitor_new_amount_ptr>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.set_rate_monitor_new_amount_ptr;
.CODESEGMENT PM;
.MAXIM;
$_set_rate_monitor_new_amount_ptr:
   NULL = r0;
84200000:	0f 00 02 00 	Null = r0 + Null;
   if Z rts;
84200004:	00 00 0d dc 	if EQ rts;
   push r3;
84200008:	00 00 50 f3 	push r3;
   r3 = M[r0 +   ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420000c:	0c 00 52 d1 	r3 = M[r0 + 12];
   M[r3 + $cbops_rate_monitor_op.rate_monitor_op_struct.NEW_AMOUNT_PTR_FIELD] = r1;
84200010:	34 00 35 d5 	M[r3 + 52] = r1;
   pop r3;
84200014:	00 00 54 f3 	pop r3;
   rts;
84200018:	0f 00 0d dc 	rts;

8420001c <$_rate_monitor_op_initialise>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.rate_monitor_op_initialise;
.CODESEGMENT PM;
.MAXIM;
$_rate_monitor_op_initialise:
   push rLink;
8420001c:	00 00 d0 f3 	push rLink;
   // run init function from ROM
   call $_rate_monitor_op_initiatlize;
84200020:	06 00 00 fd 	call 0x6bb84;
84200024:	84 bb f0 e1 
   // then do the extra init
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.ACC_DRIFT_FIELD] = Null;
84200028:	3c 00 02 d5 	M[r0 + 60] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.EXPECTED_ACC_SUM_FIELD] = Null;
8420002c:	38 00 02 d5 	M[r0 + 56] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.STALL_FIELD] = NULL;
84200030:	20 00 02 d5 	M[r0 + 32] = Null;
   pop rLink;
84200034:	00 00 d4 f3 	pop rLink;
   rts;
84200038:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

8420003c <$_aec_reference_create>:
aec_latency_common *aec_latency_ptr = NULL;
#endif


bool aec_reference_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420003c:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
8420003e:	17 00       	r5 = r0 + Null;
84200040:	21 09       	r7 = r2 + Null;
84200042:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200044:	3e 99       	r4 = M[r5 + 48];

    patch_fn_shared(aec_reference);

#ifdef CAPABILITY_DOWNLOAD_BUILD
    /* let the patches know it's not running from ROM */
    set_aec_reference_not_running_from_rom();
84200046:	18 f0 2b e3 	call (m) $_set_aec_reference_not_running_from_rom;
#endif

    /* Setup Response to Creation Request.   Assume Failure*/
    *response_id = OPCMD_CREATE;
8420004a:	90 f0 00 ee 	M[r7 + Null] = Null;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420004e:	7b 88       	r1 = M[r5 + 4];
84200050:	02 f0 00 60 	r0 = Null + 4096;
84200054:	44 08       	r2 = r6 + Null;
84200056:	ff fd 00 f0 	call (m) 0x204;
8420005a:	2f ed 
8420005c:	10 04       	Null = r0 - Null;
8420005e:	03 62       	if NE jump (m) Lc_aec_reference_create_3;

84200060 <Lc_aec_reference_create_2>:
    {
        return(FALSE);
84200060:	02 00       	r0 = Null + Null;
84200062:	6e 6e       	jump (m) Lc_aec_reference_create_14;

84200064 <Lc_aec_reference_create_3>:
    }

    /* Processing is in timer task.  This prevents kicks from
       propagating to the main processing function */
    op_data->stop_chain_kicks = TRUE;
84200064:	09 71       	r7 = Null + 1;
84200066:	79 f0 19 8a 	MB[r5 + 25] = r7;

    /* Initialize extended data for operator.  Assume intialized to zero*/
    op_extra_data->cap_id = op_data->cap_data->id;
8420006a:	79 89       	rMAC = M[r5 + 20];
8420006c:	09 e8       	rMAC = M[rMAC + Null];
8420006e:	61 f0 59 8e 	M[r4 + 356] = rMAC;
    op_extra_data->ReInitFlag = TRUE;
84200072:	49 08       	rMAC = r7 + Null;
84200074:	61 f0 5c 8e 	M[r4 + 368] = rMAC;
    op_extra_data->Cur_mode = AEC_REFERENCE_SYSMODE_FULL;
84200078:	61 f0 5a 8e 	M[r4 + 360] = rMAC;
    op_extra_data->kick_id = TIMER_ID_INVALID;
8420007c:	60 f0 5d 8e 	M[r4 + 372] = Null;
                         (AEC_REFERENCE_DEFAULT_TASK_PERIOD >= AEC_REFERENCE_MIN_TASK_PERIOD) &&
                         ((SECOND%AEC_REFERENCE_DEFAULT_TASK_PERIOD)==0)),
                        AEC_REFERENCE_DEFAULT_TASK_PERIOD_Not_Accepted);

    /* set default task period */
    if(!aec_reference_set_task_period(op_extra_data, AEC_REFERENCE_DEFAULT_TASK_PERIOD, 1))
84200080:	03 f0 e8 43 	r1 = Null + 1000;
84200084:	0c 00       	r2 = rMAC + Null;
84200086:	32 00       	r0 = r4 + Null;
84200088:	06 f0 25 ed 	call (m) $_aec_reference_set_task_period;
8420008c:	10 04       	Null = r0 - Null;
8420008e:	42 60       	if EQ jump (m) Lc_aec_reference_create_8;

84200090 <Lc_aec_reference_create_4>:
    }


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* set minimum tag length for mic output metadata tags */
    op_extra_data->mic_metadata_min_tag_len = AEC_REFERENCE_MIC_METADATA_MIN_TAG_LEN;
84200090:	01 3b       	rMAC = Null + 60;
84200092:	61 f0 cc 8e 	M[r4 + 816] = rMAC;

    /* create time to play with default params */
    op_extra_data->mic_time_to_play = ttp_init();
84200096:	ff fd b3 f0 	call (m) 0x16698;
8420009a:	23 e0 
8420009c:	62 f0 cf 8e 	M[r4 + 828] = r0;
    if (op_extra_data->mic_time_to_play != NULL)
842000a0:	61 f0 cf 88 	rMAC = M[r4 + 828];
842000a4:	37 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000a6 <Lc_aec_reference_create_5>:
    {
        ttp_params params;
        ttp_get_default_params(&params, TTP_TYPE_PCM);
842000a6:	4b 08       	r1 = r7 + Null;
842000a8:	82 11       	r0 = FP + 24;
842000aa:	ff fd b3 f0 	call (m) 0x166de;
842000ae:	35 e1 
        ttp_configure_params(op_extra_data->mic_time_to_play, &params);
842000b0:	83 11       	r1 = FP + 24;
842000b2:	62 f0 cf 88 	r0 = M[r4 + 828];
842000b6:	ff fd b3 f0 	call (m) 0x16822;
842000ba:	2d eb 
       but is not declared as such because we may want it to be configurable in the future */

    /* For Atlas this must be less than for equal to the ping/pong period.
       Also set AEC_REFERENCE_TIME_PERIOD
    */
    op_extra_data->mic_rate_ability  = RATEMATCHING_SUPPORT_NONE;
842000bc:	60 f0 67 8e 	M[r4 + 412] = Null;
    op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_NONE;
842000c0:	60 f0 6f 8e 	M[r4 + 444] = Null;
    op_extra_data->mic_shift  = AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c4:	60 f0 6d 8e 	M[r4 + 436] = Null;
    op_extra_data->spkr_shift = -AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c8:	60 f0 74 8e 	M[r4 + 464] = Null;

    /* Note:  sample rate config must be sent before the operator's terminals may be connected
       input_rate and output_rate are initialized to zero and checked in the connect operation */

    /*allocate the volume control shared memory */
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
842000cc:	ff fd 8b f0 	call (m) 0x1181c;
842000d0:	31 ea 
842000d2:	62 f0 58 8e 	M[r4 + 352] = r0;
    if(!op_extra_data->shared_volume_ptr)
842000d6:	61 f0 58 88 	rMAC = M[r4 + 352];
842000da:	24 60       	if EQ jump (m) Lc_aec_reference_create_10;

842000dc <Lc_aec_reference_create_6>:
    {
        goto aFailed;
    }

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)AEC_REFERENCE_GetDefaults(op_extra_data->cap_id),(unsigned*)&op_extra_data->params,sizeof(AEC_REFERENCE_PARAMETERS)))
842000dc:	62 f0 59 88 	r0 = M[r4 + 356];
842000e0:	14 f0 31 ed 	call (m) $_AEC_REFERENCE_GetDefaults;
842000e4:	13 00       	r1 = r0 + Null;
842000e6:	05 f0 94 40 	r3 = Null + 148;
842000ea:	64 f0 cc 20 	r2 = r4 + 204;
842000ee:	62 f0 78 21 	r0 = r4 + 376;
842000f2:	ff fd 01 f0 	call (m) 0x424;
842000f6:	33 e9 
842000f8:	10 04       	Null = r0 - Null;
842000fa:	0c 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000fc <Lc_aec_reference_create_7>:
    {
        goto aFailed;
    }

#if defined(IO_DEBUG)
    aec_latency_ptr = &op_extra_data->sync_block;
842000fc:	61 f0 14 22 	rMAC = r4 + 532;
84200100:	e0 f0 01 f0 	M[Null + $_aec_latency_ptr] = rMAC;
84200104:	58 8e 
#endif

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
84200106:	79 f0 18 8a 	MB[r5 + 24] = r7;
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420010a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420010e:	48 8e       	M[rMAC + 4] = Null;
84200110:	16 6e       	jump (m) Lc_aec_reference_create_13;

84200112 <Lc_aec_reference_create_8>:
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
  aFailed:
    if(op_extra_data->shared_volume_ptr)
84200112:	62 f0 58 88 	r0 = M[r4 + 352];
84200116:	06 60       	if EQ jump (m) Lc_aec_reference_create_10;

84200118 <Lc_aec_reference_create_9>:
    {
        release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
84200118:	ff fd 8b f0 	call (m) 0x11840;
8420011c:	29 e9 
        op_extra_data->shared_volume_ptr = NULL;
8420011e:	60 f0 58 8e 	M[r4 + 352] = Null;

84200122 <Lc_aec_reference_create_10>:
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* free it if we created time to play context for mic */
    if (op_extra_data->mic_time_to_play != NULL)
84200122:	62 f0 cf 88 	r0 = M[r4 + 828];
84200126:	06 60       	if EQ jump (m) Lc_aec_reference_create_12;

84200128 <Lc_aec_reference_create_11>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200128:	ff fd b4 f0 	call (m) 0x16af4;
8420012c:	2d ee 
        op_extra_data->mic_time_to_play = NULL;
8420012e:	60 f0 cf 8e 	M[r4 + 828] = Null;

84200132 <Lc_aec_reference_create_12>:
84200132:	01 f0 00 60 	rMAC = Null + 4096;
84200136:	82 f0 00 e8 	r0 = M[r6 + Null];
8420013a:	51 8e       	M[r0 + 4] = rMAC;

8420013c <Lc_aec_reference_create_13>:

    /* chance to fix up */
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
8420013c:	4a 08       	r0 = r7 + Null;

8420013e <Lc_aec_reference_create_14>:
    }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    return TRUE;
}
8420013e:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84200140:	d8 4c       	rts;

84200142 <$_aec_reference_destroy>:
     */
    op_extra_data->channel_status = 0;
}

bool aec_reference_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200142:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200144:	17 00       	r5 = r0 + Null;
84200146:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200148:	3e 99       	r4 = M[r5 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* Setup Response to Destroy Request.*/
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
8420014a:	ef fd ff ff 	call (m) 0xac;
8420014e:	23 eb 
84200150:	10 04       	Null = r0 - Null;
84200152:	03 62       	if NE jump (m) Lc_aec_reference_destroy_3;

84200154 <Lc_aec_reference_destroy_2>:
    {
        return(FALSE);
84200154:	02 00       	r0 = Null + Null;
84200156:	17 6e       	jump (m) Lc_aec_reference_destroy_6;

84200158 <Lc_aec_reference_destroy_3>:
    }

    /* Make sure everything is cleared */
    aec_reference_cleanup(op_data);
84200158:	3a 00       	r0 = r5 + Null;
8420015a:	08 f0 3b e7 	call (m) $_aec_reference_cleanup;

    /* calling the "destroy" assembly function - this frees up all the capability-internal memory */
    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
8420015e:	62 f0 58 88 	r0 = M[r4 + 352];
84200162:	ff fd 8b f0 	call (m) 0x11840;
84200166:	3f e6 
    op_extra_data->shared_volume_ptr = NULL;
84200168:	60 f0 58 8e 	M[r4 + 352] = Null;


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* delete mic time-to-play object */
    if(op_extra_data->mic_time_to_play != NULL)
8420016c:	62 f0 cf 88 	r0 = M[r4 + 828];
84200170:	06 60       	if EQ jump (m) Lc_aec_reference_destroy_5;

84200172 <Lc_aec_reference_destroy_4>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200172:	ff fd b4 f0 	call (m) 0x16af4;
84200176:	23 ec 
        op_extra_data->mic_time_to_play = NULL;
84200178:	60 f0 cf 8e 	M[r4 + 828] = Null;

8420017c <Lc_aec_reference_destroy_5>:
8420017c:	81 f0 00 e8 	rMAC = M[r6 + Null];
84200180:	48 8e       	M[rMAC + 4] = Null;
    }
#endif

    base_op_change_response_status(response_data,STATUS_OK);
    return(TRUE);
84200182:	42 20       	r0 = Null + 1;

84200184 <Lc_aec_reference_destroy_6>:
}
84200184:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200186:	d8 4c       	rts;

84200188 <$_aec_reference_reset>:
    *response_id = OPCMD_STOP;
    return(aec_reference_stop_reset(op_data,response_data));
}

bool aec_reference_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200188:	c8 1c       	pushm <FP(=SP), rLink>;
8420018a:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Reset Request.   Assume Failure*/
    *response_id = OPCMD_RESET;
8420018c:	01 21       	rMAC = Null + 4;
8420018e:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
84200190:	10 f0 35 e4 	call (m) $_aec_reference_stop_reset;

84200194 <Lc_aec_reference_reset_2>:
}
84200194:	c8 48       	popm <FP, rLink>;
84200196:	d8 4c       	rts;

84200198 <$_aec_reference_connect>:


bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200198:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420019a:	13 09       	r9 = r0 + Null;
8420019c:	22 09       	r8 = r2 + Null;
8420019e:	45 de       	M[FP + 32] = r3;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842001a0:	b7 f0 0c 88 	r5 = M[r9 + 48];


bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id    = ((unsigned*)message_data)[0];    /* extract the terminal_id */
842001a4:	1e e8       	r4 = M[r1 + Null];
    tCbuffer* pterminal_buf = (tCbuffer*)(uintptr_t)(((unsigned *)message_data)[1]);
842001a6:	38 f0 01 88 	r6 = M[r1 + 4];
    INT_OP_ID int_id = op_data->id;
842001aa:	b9 f0 01 88 	r7 = M[r9 + 4];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- connect TID = %x", terminal_id);
842001ae:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842001b2:	c8 24       	Null = rMAC - 3;
842001b4:	08 68       	if LT jump (m) Lc_aec_reference_connect_3;

842001b6 <Lc_aec_reference_connect_2>:
842001b6:	55 f1 02 f0 	r0 = Null + 357564416;
842001ba:	00 40 
842001bc:	33 00       	r1 = r4 + Null;
842001be:	ff fd 03 f0 	call (m) 0x9b4;
842001c2:	37 ef 

842001c4 <Lc_aec_reference_connect_3>:


    /* Setup Response to Connection Request.   Assume Failure*/
    *response_id = OPCMD_CONNECT;
842001c4:	41 21       	rMAC = Null + 5;
842001c6:	a1 f0 00 ee 	M[r8 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842001ca:	b3 f0 01 88 	r1 = M[r9 + 4];
842001ce:	02 f0 00 60 	r0 = Null + 4096;
842001d2:	44 d8       	r2 = M[FP + 32];
842001d4:	ff fd 00 f0 	call (m) 0x204;
842001d8:	31 e1 
842001da:	10 04       	Null = r0 - Null;
842001dc:	03 62       	if NE jump (m) Lc_aec_reference_connect_5;

842001de <Lc_aec_reference_connect_4>:
    {
        return(FALSE);
842001de:	02 00       	r0 = Null + Null;
842001e0:	d8 6e       	jump (m) Lc_aec_reference_connect_45;

842001e2 <Lc_aec_reference_connect_5>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
842001e2:	70 f0 64 88 	Null = M[r5 + 400];
842001e6:	13 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001e8 <Lc_aec_reference_connect_6>:
842001e8:	70 f0 65 88 	Null = M[r5 + 404];
842001ec:	10 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001ee <Lc_aec_reference_connect_7>:
        return(TRUE);
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842001ee:	33 00       	r1 = r4 + Null;
842001f0:	5a 08       	r0 = r9 + Null;
842001f2:	ef fd ff ff 	call (m) 0x1de;
842001f6:	2d ef 
842001f8:	10 04       	Null = r0 - Null;
842001fa:	04 60       	if EQ jump (m) Lc_aec_reference_connect_9;

842001fc <Lc_aec_reference_connect_8>:
842001fc:	0f f8 00 c2 	Null = r6 - Null;
84200200:	08 62       	if NE jump (m) Lc_aec_reference_connect_11;

84200202 <Lc_aec_reference_connect_9>:
84200202:	01 f0 03 60 	rMAC = Null + 4099;
84200206:	42 d8       	r0 = M[FP + 32];
84200208:	12 e8       	r0 = M[r0 + Null];
8420020a:	51 8e       	M[r0 + 4] = rMAC;

8420020c <Lc_aec_reference_connect_10>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
    {
        return(TRUE);
8420020c:	42 20       	r0 = Null + 1;
8420020e:	c1 6e       	jump (m) Lc_aec_reference_connect_45;

84200210 <Lc_aec_reference_connect_11>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is already connected and if not , connect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
84200210:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200214:	00 00 
84200216:	5c 60       	if EQ jump (m) Lc_aec_reference_connect_27;

84200218 <Lc_aec_reference_connect_12>:
    {
        terminal_id &= ~ TERMINAL_SINK_MASK;
84200218:	bf ff 66 ff 	r4 = r4 AND 0xff7fffff;
8420021c:	ff 1f 

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420021e:	b0 24       	Null = r4 - 2;
84200220:	35 62       	if NE jump (m) Lc_aec_reference_connect_19;

84200222 <Lc_aec_reference_connect_13>:
        {
            uint32 config_value;

            /* get info about overridden endpoints */
            op_extra_data->mic_endpoint = get_overriden_endpoint(int_id,
                                                                 AEC_REF_MIC_TERMINAL1 | TERMINAL_SINK_MASK);
84200222:	08 f0 03 f0 	r1 = Null + 8388610;
84200226:	02 40 
84200228:	4a 08       	r0 = r7 + Null;
8420022a:	ff fd 24 f0 	call (m) 0x4ab0;
8420022e:	27 e4 
84200230:	72 f0 7f 8e 	M[r5 + 508] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->mic_endpoint,&config_value))
84200234:	43 12       	r1 = FP + 36;
84200236:	72 f0 7f 88 	r0 = M[r5 + 508];
8420023a:	ff fd 24 f0 	call (m) 0x4a4e;
8420023e:	35 e0 
84200240:	10 04       	Null = r0 - Null;
84200242:	e0 61       	if EQ jump (m) Lc_aec_reference_connect_9;

84200244 <Lc_aec_reference_connect_14>:
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = (unsigned)config_value;
84200244:	49 d8       	rMAC = M[FP + 36];
84200246:	71 f0 67 8e 	M[r5 + 412] = rMAC;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
8420024a:	70 f0 68 8e 	M[r5 + 416] = Null;
#endif
            if(op_extra_data->mic_sync_enable)
8420024e:	70 f0 d4 88 	Null = M[r5 + 848];
84200252:	0b 60       	if EQ jump (m) Lc_aec_reference_connect_17;

84200254 <Lc_aec_reference_connect_15>:
            {
                /* Mic output will be synchronised to speaker input, SW or HW depends on
                 * it's ability.
                 */
                op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200254:	71 f0 68 8e 	M[r5 + 416] = rMAC;
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200258:	88 24       	Null = rMAC - 2;
8420025a:	07 62       	if NE jump (m) Lc_aec_reference_connect_17;

8420025c <Lc_aec_reference_connect_16>:
                {
                    set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint, TRUE);
8420025c:	43 20       	r1 = Null + 1;
8420025e:	72 f0 7f 88 	r0 = M[r5 + 508];
84200262:	ff fd 23 f0 	call (m) 0x4a3e;
84200266:	3d ee 

84200268 <Lc_aec_reference_connect_17>:
                }
            }

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if mic graph wants to use an external rate adjust operator */
            aec_reference_mic_check_external_rate_adjust_op(op_extra_data);
84200268:	3a 00       	r0 = r5 + Null;
8420026a:	06 f0 33 ee 	call (m) $_aec_reference_mic_check_external_rate_adjust_op;
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

            if(!get_override_ep_sample_rate(op_extra_data->mic_endpoint,&config_value))
8420026e:	43 12       	r1 = FP + 36;
84200270:	72 f0 7f 88 	r0 = M[r5 + 508];
84200274:	ff fd 23 f0 	call (m) 0x4a02;
84200278:	2f ec 
8420027a:	10 04       	Null = r0 - Null;
8420027c:	c3 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420027e <Lc_aec_reference_connect_18>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;
8420027e:	49 d8       	rMAC = M[FP + 36];
84200280:	71 f0 66 8e 	M[r5 + 408] = rMAC;
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        op_extra_data->input_stream[terminal_id] = pterminal_buf;
84200284:	78 f0 02 8e 	M[r5 + 8] = r6;
84200288:	60 6e       	jump (m) Lc_aec_reference_connect_36;

8420028a <Lc_aec_reference_connect_19>:
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
8420028a:	30 04       	Null = r4 - Null;
8420028c:	16 62       	if NE jump (m) Lc_aec_reference_connect_24;

8420028e <Lc_aec_reference_connect_20>:
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
8420028e:	08 f0 03 f0 	r1 = Null + 8388608;
84200292:	00 40 
84200294:	4a 08       	r0 = r7 + Null;
84200296:	ff fd 24 f0 	call (m) 0x4ab0;
8420029a:	3b e0 
8420029c:	72 f0 82 8e 	M[r5 + 520] = r0;
        }
        op_extra_data->input_stream[terminal_id] = pterminal_buf;
842002a0:	78 f0 00 ee 	M[r5 + Null] = r6;

842002a4 <Lc_aec_reference_connect_21>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
842002a4:	81 f0 05 88 	rMAC = M[r6 + 20];
842002a8:	49 c6       	rMAC = rMAC AND 0x8000;
842002aa:	4f 60       	if EQ jump (m) Lc_aec_reference_connect_36;

842002ac <Lc_aec_reference_connect_22>:
         */
        if(IsSpeakerInputTerminal(terminal_id) &&
           buff_has_metadata(pterminal_buf))
        {
            /* set metadata buffer if it hasn't been set already */
            if(NULL == op_extra_data->spkr_input_metadata_buffer)
842002ac:	71 f0 c9 88 	rMAC = M[r5 + 804];
842002b0:	4c 62       	if NE jump (m) Lc_aec_reference_connect_36;

842002b2 <Lc_aec_reference_connect_23>:
            {
                op_extra_data->spkr_input_metadata_buffer = pterminal_buf;
842002b2:	78 f0 c9 8e 	M[r5 + 804] = r6;
842002b6:	49 6e       	jump (m) Lc_aec_reference_connect_36;

842002b8 <Lc_aec_reference_connect_24>:
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        op_extra_data->input_stream[terminal_id] = pterminal_buf;
842002b8:	72 54       	r0 = r4 LSHIFT 2;
842002ba:	78 f0 02 ee 	M[r5 + r0] = r6;
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842002be:	70 24       	Null = r4 - 1;
842002c0:	f2 61       	if EQ jump (m) Lc_aec_reference_connect_21;

842002c2 <Lc_aec_reference_connect_25>:
842002c2:	b0 25       	Null = r4 - 6;
842002c4:	42 64       	if NC jump (m) Lc_aec_reference_connect_36;

842002c6 <Lc_aec_reference_connect_26>:
842002c6:	f0 26       	Null = r4 - 11;
842002c8:	f9 ff dd ef 	if LS jump (m) Lc_aec_reference_connect_21;

842002cc <Lc_14>:
842002cc:	3e 6e       	jump (m) Lc_aec_reference_connect_36;

842002ce <Lc_aec_reference_connect_27>:
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */
    }
    else
    {
        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842002ce:	70 24       	Null = r4 - 1;
842002d0:	26 62       	if NE jump (m) Lc_aec_reference_connect_31;

842002d2 <Lc_aec_reference_connect_28>:
        {
            uint32 config_value;

            op_extra_data->spkr_endpoint = get_overriden_endpoint(int_id,
                                                                  AEC_REF_SPKR_TERMINAL1);
842002d2:	43 20       	r1 = Null + 1;
842002d4:	4a 08       	r0 = r7 + Null;
842002d6:	ff fd 23 f0 	call (m) 0x4ab0;
842002da:	3b ee 
842002dc:	72 f0 80 8e 	M[r5 + 512] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->spkr_endpoint,&config_value))
842002e0:	83 12       	r1 = FP + 40;
842002e2:	72 f0 80 88 	r0 = M[r5 + 512];
842002e6:	ff fd 23 f0 	call (m) 0x4a4e;
842002ea:	29 eb 
842002ec:	10 04       	Null = r0 - Null;
842002ee:	8a 61       	if EQ jump (m) Lc_aec_reference_connect_9;

842002f0 <Lc_aec_reference_connect_29>:

#if defined(ENABLE_FORCE_SW_RATEMATCH)
            op_extra_data->spkr_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            op_extra_data->spkr_rate_ability   = (unsigned)config_value;
842002f0:	51 d8       	rMAC = M[FP + 40];
842002f2:	71 f0 6f 8e 	M[r5 + 444] = rMAC;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
842002f6:	70 f0 71 8e 	M[r5 + 452] = Null;
#endif

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if speaker graph wants to use an external rate adjust operator */
            aec_reference_spkr_check_external_rate_adjust_op(op_extra_data);
842002fa:	3a 00       	r0 = r5 + Null;
842002fc:	06 f0 23 e8 	call (m) $_aec_reference_spkr_check_external_rate_adjust_op;
#endif
            if(!get_override_ep_sample_rate(op_extra_data->spkr_endpoint,&config_value))
84200300:	83 12       	r1 = FP + 40;
84200302:	72 f0 80 88 	r0 = M[r5 + 512];
84200306:	ff fd 23 f0 	call (m) 0x4a02;
8420030a:	3d e7 
8420030c:	10 04       	Null = r0 - Null;
8420030e:	7a 61       	if EQ jump (m) Lc_aec_reference_connect_9;

84200310 <Lc_aec_reference_connect_30>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;
84200310:	51 d8       	rMAC = M[FP + 40];
84200312:	71 f0 6e 8e 	M[r5 + 440] = rMAC;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        op_extra_data->output_stream[terminal_id] = pterminal_buf;
84200316:	78 f0 11 8e 	M[r5 + 68] = r6;
8420031a:	17 6e       	jump (m) Lc_aec_reference_connect_36;

8420031c <Lc_aec_reference_connect_31>:
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;

        }
        else if (terminal_id==AEC_REF_OUTPUT_TERMINAL1)
8420031c:	f0 24       	Null = r4 - 3;
8420031e:	1c 62       	if NE jump (m) Lc_aec_reference_connect_38;

84200320 <Lc_aec_reference_connect_32>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
84200320:	c3 20       	r1 = Null + 3;
84200322:	4a 08       	r0 = r7 + Null;
84200324:	ff fd 23 f0 	call (m) 0x4ab0;
84200328:	2d ec 
8420032a:	72 f0 81 8e 	M[r5 + 516] = r0;
            op_extra_data->sync_block.mic_data = 0;
8420032e:	70 f0 88 8e 	M[r5 + 544] = Null;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        op_extra_data->output_stream[terminal_id] = pterminal_buf;
84200332:	78 f0 13 8e 	M[r5 + 76] = r6;

84200336 <Lc_aec_reference_connect_33>:
84200336:	81 f0 05 88 	rMAC = M[r6 + 20];
8420033a:	49 c6       	rMAC = rMAC AND 0x8000;
8420033c:	06 60       	if EQ jump (m) Lc_aec_reference_connect_36;

8420033e <Lc_aec_reference_connect_34>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
       /* set metadata buffer for mic outputs */
       if(IsMicrophoneOutputTerminal(terminal_id) &&
          buff_has_metadata(pterminal_buf))
       {
           if(NULL == op_extra_data->mic_metadata_buffer)
8420033e:	71 f0 ca 88 	rMAC = M[r5 + 808];
84200342:	03 62       	if NE jump (m) Lc_aec_reference_connect_36;

84200344 <Lc_aec_reference_connect_35>:
           {   /* first connected mic output buffer with metadata */
               op_extra_data->mic_metadata_buffer = pterminal_buf;
84200344:	78 f0 ca 8e 	M[r5 + 808] = r6;

84200348 <Lc_aec_reference_connect_36>:

    }

    /* OP not running, accept connections */
    /* OP is running, validate terminals and reset config */
    if(op_data->state != OP_RUNNING)
84200348:	b1 f0 18 80 	rMAC = MBS[r9 + 24];
8420034c:	1c 60       	if EQ jump (m) Lc_aec_reference_connect_44;

8420034e <Lc_aec_reference_connect_37>:
8420034e:	41 d8       	rMAC = M[FP + 32];
84200350:	09 e8       	rMAC = M[rMAC + Null];
84200352:	48 8e       	M[rMAC + 4] = Null;
84200354:	5c 6f       	jump (m) Lc_aec_reference_connect_10;

84200356 <Lc_aec_reference_connect_38>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
            op_extra_data->sync_block.mic_data = 0;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
84200356:	30 04       	Null = r4 - Null;
84200358:	06 62       	if NE jump (m) Lc_aec_reference_connect_40;

8420035a <Lc_aec_reference_connect_39>:
        {
            op_extra_data->sync_block.speaker_data = 0;
8420035a:	70 f0 89 8e 	M[r5 + 548] = Null;
        }
        op_extra_data->output_stream[terminal_id] = pterminal_buf;
8420035e:	78 f0 10 8e 	M[r5 + 64] = r6;
84200362:	f3 6f       	jump (m) Lc_aec_reference_connect_36;

84200364 <Lc_aec_reference_connect_40>:
84200364:	72 54       	r0 = r4 LSHIFT 2;
84200366:	39 00       	rMAC = r5 + Null;
84200368:	51 00       	rMAC = r0 + rMAC;
8420036a:	18 f0 10 8e 	M[rMAC + 64] = r6;
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
8420036e:	f0 24       	Null = r4 - 3;
84200370:	ec 65       	if NC jump (m) Lc_aec_reference_connect_36;

84200372 <Lc_aec_reference_connect_41>:
84200372:	b0 25       	Null = r4 - 6;
84200374:	f9 ff c3 ef 	if LS jump (m) Lc_aec_reference_connect_33;

84200378 <Lc_aec_reference_connect_42>:
84200378:	70 27       	Null = r4 - 13;
8420037a:	e7 65       	if NC jump (m) Lc_aec_reference_connect_36;

8420037c <Lc_aec_reference_connect_43>:
8420037c:	30 2c       	Null = r4 - 16;
8420037e:	f9 ff b9 ef 	if LS jump (m) Lc_aec_reference_connect_33;

84200382 <Lc_15>:
84200382:	e3 6f       	jump (m) Lc_aec_reference_connect_36;

84200384 <Lc_aec_reference_connect_44>:
    /* OP is running, validate terminals and reset config */
    if(op_data->state != OP_RUNNING)
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    else if(validate_channels_and_build(op_data))
84200384:	5a 08       	r0 = r9 + Null;
84200386:	0b f0 3f e7 	call (m) $_validate_channels_and_build;
8420038a:	10 04       	Null = r0 - Null;
8420038c:	e1 63       	if NE jump (m) Lc_aec_reference_connect_37;

8420038e <Lc_16>:
8420038e:	3f 6f       	jump (m) Lc_aec_reference_connect_10;

84200390 <Lc_aec_reference_connect_45>:
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    return TRUE;
}
84200390:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200392:	d8 4c       	rts;

84200394 <$_aec_reference_disconnect>:

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200394:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200396:	11 09       	r7 = r0 + Null;
84200398:	20 09       	r6 = r2 + Null;
8420039a:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420039c:	96 f0 0c 88 	r4 = M[r7 + 48];
}

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = *((unsigned*)message_data);
842003a0:	1f e8       	r5 = M[r1 + Null];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- disconnect TID = %x", terminal_id);
842003a2:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842003a6:	c8 24       	Null = rMAC - 3;
842003a8:	08 68       	if LT jump (m) Lc_aec_reference_disconnect_3;

842003aa <Lc_aec_reference_disconnect_2>:
842003aa:	55 f1 02 f0 	r0 = Null + 357564451;
842003ae:	23 40 
842003b0:	3b 00       	r1 = r5 + Null;
842003b2:	ff fd 03 f0 	call (m) 0x9b4;
842003b6:	23 e0 

842003b8 <Lc_aec_reference_disconnect_3>:

    /* Setup Response to Disconnection Request. Assume Failure*/
    *response_id = OPCMD_DISCONNECT;
842003b8:	81 21       	rMAC = Null + 6;
842003ba:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842003be:	93 f0 01 88 	r1 = M[r7 + 4];
842003c2:	02 f0 00 60 	r0 = Null + 4096;
842003c6:	54 08       	r2 = r8 + Null;
842003c8:	ef fd ff ff 	call (m) 0x204;
842003cc:	3d e1 
842003ce:	10 04       	Null = r0 - Null;
842003d0:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_5;

842003d2 <Lc_aec_reference_disconnect_4>:
    {
        return(FALSE);
842003d2:	02 00       	r0 = Null + Null;
842003d4:	9b 6e       	jump (m) Lc_aec_reference_disconnect_54;

842003d6 <Lc_aec_reference_disconnect_5>:
    }

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
842003d6:	3b 00       	r1 = r5 + Null;
842003d8:	4a 08       	r0 = r7 + Null;
842003da:	ef fd ff ff 	call (m) 0x1de;
842003de:	25 e0 
842003e0:	10 04       	Null = r0 - Null;
842003e2:	08 62       	if NE jump (m) Lc_aec_reference_disconnect_8;

842003e4 <Lc_aec_reference_disconnect_6>:
842003e4:	01 f0 03 60 	rMAC = Null + 4099;
842003e8:	a2 f0 00 e8 	r0 = M[r8 + Null];
842003ec:	51 8e       	M[r0 + 4] = rMAC;

842003ee <Lc_aec_reference_disconnect_7>:
    {
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842003ee:	42 20       	r0 = Null + 1;
842003f0:	8d 6e       	jump (m) Lc_aec_reference_disconnect_54;

842003f2 <Lc_aec_reference_disconnect_8>:
    }

    /* check if the terminal is connected and if so , disconnect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
842003f2:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842003f6:	00 00 
842003f8:	3b 60       	if EQ jump (m) Lc_aec_reference_disconnect_29;

842003fa <Lc_aec_reference_disconnect_9>:
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842003fa:	bf ff 77 ff 	r5 = r5 AND 0xff7fffff;
842003fe:	ff 1f 
84200400:	08 60       	if EQ jump (m) Lc_aec_reference_disconnect_13;

84200402 <Lc_aec_reference_disconnect_10>:
84200402:	78 24       	Null = r5 - 1;
84200404:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_13;

84200406 <Lc_aec_reference_disconnect_11>:
84200406:	b8 25       	Null = r5 - 6;
84200408:	26 64       	if NC jump (m) Lc_aec_reference_disconnect_26;

8420040a <Lc_aec_reference_disconnect_12>:
8420040a:	f8 26       	Null = r5 - 11;
8420040c:	08 f0 c3 e0 	if HI jump (m) Lc_aec_reference_disconnect_25;

84200410 <Lc_aec_reference_disconnect_13>:
        terminal_id &= ~ TERMINAL_SINK_MASK;

#ifdef AEC_REFERENCE_SUPPORT_METADATA
        if(IsSpeakerInputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->input_stream[terminal_id];
84200410:	7a 54       	r0 = r5 LSHIFT 2;
84200412:	b1 e8       	rMAC = M[r4 + r0];
            if(this_buf == op_extra_data->spkr_input_metadata_buffer)
84200414:	62 f0 c9 88 	r0 = M[r4 + 804];
84200418:	88 04       	Null = rMAC - r0;
8420041a:	16 62       	if NE jump (m) Lc_aec_reference_disconnect_23;

8420041c <Lc_aec_reference_disconnect_14>:
            {
                /* disconnecting buffer is the metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
8420041c:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
8420041e:	03 00       	r1 = Null + Null;
84200420:	03 6e       	jump (m) Lc_aec_reference_disconnect_16;

84200422 <Lc_aec_reference_disconnect_15>:
                {
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84200422:	98 24       	Null = r1 - 2;
84200424:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_17;

84200426 <Lc_aec_reference_disconnect_16>:
84200426:	1c 00       	r2 = r1 + Null;
84200428:	02 6e       	jump (m) Lc_aec_reference_disconnect_18;

8420042a <Lc_aec_reference_disconnect_17>:
8420042a:	1c 21       	r2 = r1 + 4;

8420042c <Lc_aec_reference_disconnect_18>:
8420042c:	64 54       	r2 = r2 LSHIFT 2;
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
8420042e:	34 e9       	r2 = M[r4 + r2];
84200430:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_21;

84200432 <Lc_aec_reference_disconnect_19>:
84200432:	60 04       	Null = r2 - rMAC;
84200434:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_21;

84200436 <Lc_aec_reference_disconnect_20>:
84200436:	65 89       	r3 = M[r2 + 20];
84200438:	6d c6       	r3 = r3 AND 0x8000;
8420043a:	64 62       	if NE jump (m) Lc_aec_reference_disconnect_52;

8420043c <Lc_aec_reference_disconnect_21>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
8420043c:	5b 20       	r1 = r1 + 1;
8420043e:	18 26       	Null = r1 - 8;
84200440:	f1 69       	if LT jump (m) Lc_aec_reference_disconnect_15;

84200442 <Lc_aec_reference_disconnect_22>:
                    {
                        new_metadata_buf = inp_buf;
                        break;
                    }
                }
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
84200442:	62 f0 c9 8e 	M[r4 + 804] = r0;

84200446 <Lc_aec_reference_disconnect_23>:
                op_extra_data->mic_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
84200446:	38 04       	Null = r5 - Null;
84200448:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_25;

8420044a <Lc_aec_reference_disconnect_24>:
        {
            op_extra_data->spkr_in_endpoint=NULL;
8420044a:	60 f0 82 8e 	M[r4 + 520] = Null;

8420044e <Lc_aec_reference_disconnect_25>:
        }
        op_extra_data->input_stream[terminal_id] = NULL;
8420044e:	7a 54       	r0 = r5 LSHIFT 2;
84200450:	b0 ee       	M[r4 + r0] = Null;
84200452:	3e 6e       	jump (m) Lc_aec_reference_disconnect_46;

84200454 <Lc_aec_reference_disconnect_26>:
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
84200454:	b8 24       	Null = r5 - 2;
84200456:	fc 63       	if NE jump (m) Lc_aec_reference_disconnect_25;

84200458 <Lc_aec_reference_disconnect_27>:
        {
            op_extra_data->mic_endpoint=NULL;
84200458:	60 f0 7f 8e 	M[r4 + 508] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->mic_ext_rate_adjust_op != 0)
8420045c:	62 f0 ad 88 	r0 = M[r4 + 692];
84200460:	f7 61       	if EQ jump (m) Lc_aec_reference_disconnect_25;

84200462 <Lc_aec_reference_disconnect_28>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, TRUE);
84200462:	43 20       	r1 = Null + 1;
84200464:	13 f0 27 ef 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->mic_ext_rate_adjust_op = 0;
84200468:	60 f0 ad 8e 	M[r4 + 692] = Null;
8420046c:	f1 6f       	jump (m) Lc_aec_reference_disconnect_25;

8420046e <Lc_aec_reference_disconnect_29>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
8420046e:	f8 24       	Null = r5 - 3;
84200470:	36 64       	if NC jump (m) Lc_aec_reference_disconnect_48;

84200472 <Lc_aec_reference_disconnect_30>:
84200472:	b8 25       	Null = r5 - 6;
84200474:	09 f0 8f e0 	if LS jump (m) Lc_aec_reference_disconnect_33;

84200478 <Lc_aec_reference_disconnect_31>:
84200478:	78 27       	Null = r5 - 13;
8420047a:	27 64       	if NC jump (m) Lc_aec_reference_disconnect_45;

8420047c <Lc_aec_reference_disconnect_32>:
8420047c:	38 2c       	Null = r5 - 16;
8420047e:	08 f0 cb e0 	if HI jump (m) Lc_aec_reference_disconnect_45;

84200482 <Lc_aec_reference_disconnect_33>:
    else
    {
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
        if(IsMicrophoneOutputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->output_stream[terminal_id];
84200482:	7a 54       	r0 = r5 LSHIFT 2;
84200484:	31 00       	rMAC = r4 + Null;
84200486:	51 00       	rMAC = r0 + rMAC;
84200488:	09 a8       	rMAC = M[rMAC + 64];
            if(this_buf == op_extra_data->mic_metadata_buffer)
8420048a:	62 f0 ca 88 	r0 = M[r4 + 808];
8420048e:	88 04       	Null = rMAC - r0;
84200490:	18 62       	if NE jump (m) Lc_aec_reference_disconnect_43;

84200492 <Lc_aec_reference_disconnect_34>:
            {
                /* disconnecting buffer is the mic metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
84200492:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
84200494:	03 00       	r1 = Null + Null;
84200496:	03 6e       	jump (m) Lc_aec_reference_disconnect_36;

84200498 <Lc_aec_reference_disconnect_35>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200498:	98 24       	Null = r1 - 2;
8420049a:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_37;

8420049c <Lc_aec_reference_disconnect_36>:
8420049c:	dc 20       	r2 = r1 + 3;
8420049e:	02 6e       	jump (m) Lc_aec_reference_disconnect_38;

842004a0 <Lc_aec_reference_disconnect_37>:
842004a0:	5c 22       	r2 = r1 + 9;

842004a2 <Lc_aec_reference_disconnect_38>:
842004a2:	65 f0 40 20 	r3 = r4 + 64;
842004a6:	64 54       	r2 = r2 LSHIFT 2;
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
842004a8:	2c e9       	r2 = M[r3 + r2];
842004aa:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_41;

842004ac <Lc_aec_reference_disconnect_39>:
842004ac:	60 04       	Null = r2 - rMAC;
842004ae:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_41;

842004b0 <Lc_aec_reference_disconnect_40>:
842004b0:	65 89       	r3 = M[r2 + 20];
842004b2:	6d c6       	r3 = r3 AND 0x8000;
842004b4:	29 62       	if NE jump (m) Lc_aec_reference_disconnect_53;

842004b6 <Lc_aec_reference_disconnect_41>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
842004b6:	5b 20       	r1 = r1 + 1;
842004b8:	18 26       	Null = r1 - 8;
842004ba:	ef 69       	if LT jump (m) Lc_aec_reference_disconnect_35;

842004bc <Lc_aec_reference_disconnect_42>:
                    {
                        new_metadata_buf = out_buf;
                        break;
                    }
                }
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
842004bc:	62 f0 ca 8e 	M[r4 + 808] = r0;

842004c0 <Lc_aec_reference_disconnect_43>:
                op_extra_data->spkr_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_OUTPUT_TERMINAL1)
842004c0:	f8 24       	Null = r5 - 3;
842004c2:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_45;

842004c4 <Lc_aec_reference_disconnect_44>:
        {
            op_extra_data->mic_out_endpoint=NULL;
842004c4:	60 f0 81 8e 	M[r4 + 516] = Null;

842004c8 <Lc_aec_reference_disconnect_45>:
        }
        op_extra_data->output_stream[terminal_id] = NULL;
842004c8:	7a 54       	r0 = r5 LSHIFT 2;
842004ca:	96 01       	r4 = r0 + r4;
842004cc:	30 ae       	M[r4 + 64] = Null;

842004ce <Lc_aec_reference_disconnect_46>:
    }

    /* OP not running, accept disconnections */
    /* OP is running, validate terminals and reset config */
    if(op_data->state != OP_RUNNING)
842004ce:	91 f0 18 80 	rMAC = MBS[r7 + 24];
842004d2:	12 60       	if EQ jump (m) Lc_aec_reference_disconnect_51;

842004d4 <Lc_aec_reference_disconnect_47>:
842004d4:	a1 f0 00 e8 	rMAC = M[r8 + Null];
842004d8:	48 8e       	M[rMAC + 4] = Null;
842004da:	8a 6f       	jump (m) Lc_aec_reference_disconnect_7;

842004dc <Lc_aec_reference_disconnect_48>:
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842004dc:	78 24       	Null = r5 - 1;
842004de:	f5 63       	if NE jump (m) Lc_aec_reference_disconnect_45;

842004e0 <Lc_aec_reference_disconnect_49>:
        {
            op_extra_data->spkr_endpoint=NULL;
842004e0:	60 f0 80 8e 	M[r4 + 512] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->spkr_ext_rate_adjust_op != 0)
842004e4:	62 f0 ae 88 	r0 = M[r4 + 696];
842004e8:	f0 61       	if EQ jump (m) Lc_aec_reference_disconnect_45;

842004ea <Lc_aec_reference_disconnect_50>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, TRUE);
842004ea:	43 20       	r1 = Null + 1;
842004ec:	13 f0 3f ea 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->spkr_ext_rate_adjust_op = 0;
842004f0:	60 f0 ae 8e 	M[r4 + 696] = Null;
842004f4:	ea 6f       	jump (m) Lc_aec_reference_disconnect_45;

842004f6 <Lc_aec_reference_disconnect_51>:
    /* OP is running, validate terminals and reset config */
    if(op_data->state != OP_RUNNING)
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    else if(validate_channels_and_build(op_data))
842004f6:	4a 08       	r0 = r7 + Null;
842004f8:	0a f0 2d ec 	call (m) $_validate_channels_and_build;
842004fc:	10 04       	Null = r0 - Null;
842004fe:	eb 63       	if NE jump (m) Lc_aec_reference_disconnect_47;

84200500 <Lc_17>:
84200500:	77 6f       	jump (m) Lc_aec_reference_disconnect_7;

84200502 <Lc_aec_reference_disconnect_52>:
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
                    {
                        new_metadata_buf = inp_buf;
84200502:	22 00       	r0 = r2 + Null;
                        break;
84200504:	9f 6f       	jump (m) Lc_aec_reference_disconnect_22;

84200506 <Lc_aec_reference_disconnect_53>:
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
                    {
                        new_metadata_buf = out_buf;
84200506:	22 00       	r0 = r2 + Null;
                        break;
84200508:	da 6f       	jump (m) Lc_aec_reference_disconnect_42;

8420050a <Lc_aec_reference_disconnect_54>:
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }

    return TRUE;
}
8420050a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420050c:	d8 4c       	rts;

8420050e <$_aec_reference_start>:

    return TRUE;
}

bool aec_reference_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420050e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200510:	16 00       	r4 = r0 + Null;
84200512:	2f 00       	r5 = r3 + Null;
    patch_fn_shared(aec_reference);

    /* Setup Response to Start Request.   Assume Failure*/
    *response_id = OPCMD_START;
84200514:	81 20       	rMAC = Null + 2;
84200516:	21 ee       	M[r2 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
84200518:	73 88       	r1 = M[r4 + 4];
8420051a:	02 f0 00 60 	r0 = Null + 4096;
8420051e:	3c 00       	r2 = r5 + Null;
84200520:	ef fd fe ff 	call (m) 0x204;
84200524:	25 e7 
84200526:	10 04       	Null = r0 - Null;
84200528:	03 62       	if NE jump (m) Lc_aec_reference_start_3;

8420052a <Lc_aec_reference_start_2>:
    {
        return(FALSE);
8420052a:	02 00       	r0 = Null + Null;
8420052c:	0f 6e       	jump (m) Lc_aec_reference_start_8;

8420052e <Lc_aec_reference_start_3>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
8420052e:	31 b0       	rMAC = MBS[r4 + 24];
84200530:	0a 60       	if EQ jump (m) Lc_aec_reference_start_6;

84200532 <Lc_aec_reference_start_4>:
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
    }

    /* Validate channel configuration */
    if(!validate_channels_and_build(op_data))
84200532:	32 00       	r0 = r4 + Null;
84200534:	0a f0 31 ea 	call (m) $_validate_channels_and_build;
84200538:	10 04       	Null = r0 - Null;
8420053a:	07 60       	if EQ jump (m) Lc_aec_reference_start_7;

8420053c <Lc_aec_reference_start_5>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420053c:	32 99       	r0 = M[r4 + 48];
    }
#ifdef AEC_REFERENCE_SPKR_TTP
    {
        AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
        /* initialisation for timed playback in speaker path */
        aec_reference_spkr_ttp_init(op_extra_data);
8420053e:	11 f0 21 e0 	call (m) $_aec_reference_spkr_ttp_init;
    }
#endif /* AEC_REFERENCE_SPKR_TTP */
    /* set internal capability state variable to "running" */
    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_RUNNING;
84200542:	30 ba       	MB[r4 + 24] = Null;

84200544 <Lc_aec_reference_start_6>:
84200544:	39 e8       	rMAC = M[r5 + Null];
84200546:	48 8e       	M[rMAC + 4] = Null;

84200548 <Lc_aec_reference_start_7>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
    {
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
84200548:	42 20       	r0 = Null + 1;

8420054a <Lc_aec_reference_start_8>:
    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_RUNNING;

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}
8420054a:	f2 48       	popm <FP, r4, r5, rLink>;
8420054c:	d8 4c       	rts;

8420054e <$_aec_reference_stop>:
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}

bool aec_reference_stop(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420054e:	c8 1c       	pushm <FP(=SP), rLink>;
84200550:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Stop Request.   Assume Failure*/
    *response_id = OPCMD_STOP;
84200552:	c1 20       	rMAC = Null + 3;
84200554:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
84200556:	0e f0 2f e6 	call (m) $_aec_reference_stop_reset;

8420055a <Lc_aec_reference_stop_2>:
}
8420055a:	c8 48       	popm <FP, rLink>;
8420055c:	d8 4c       	rts;

8420055e <$_aec_reference_buffer_details>:

    return TRUE;
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420055e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200560:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200562:	16 99       	r4 = M[r0 + 48];
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned term_id =  *((unsigned *)message_data);
84200564:	1f e8       	r5 = M[r1 + Null];
    OP_BUF_DETAILS_RSP *resp;

    patch_fn_shared(aec_reference);

    if(!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200566:	ef fd fd ff 	call (m) 0xbe;
8420056a:	39 ea 
8420056c:	10 04       	Null = r0 - Null;
8420056e:	03 62       	if NE jump (m) Lc_aec_reference_buffer_details_3;

84200570 <Lc_aec_reference_buffer_details_2>:
    {
        return FALSE;
84200570:	02 00       	r0 = Null + Null;
84200572:	8e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

84200574 <Lc_aec_reference_buffer_details_3>:
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200574:	88 f0 00 e8 	r6 = M[r6 + Null];

    if ( term_id & TERMINAL_SINK_MASK)
84200578:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420057c:	00 00 
8420057e:	0d 60       	if EQ jump (m) Lc_aec_reference_buffer_details_7;

84200580 <Lc_aec_reference_buffer_details_4>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200580:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200584:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
84200586:	88 24       	Null = rMAC - 2;
84200588:	02 f0 f3 e1 	if C jump (m) Lc_aec_reference_buffer_details_28;

8420058c <Lc_aec_reference_buffer_details_5>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->input_buffer_size != 0)
8420058c:	61 f0 d6 88 	rMAC = M[r4 + 856];
84200590:	10 60       	if EQ jump (m) Lc_aec_reference_buffer_details_9;

84200592 <Lc_aec_reference_buffer_details_6>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->input_buffer_size;
84200592:	81 f0 04 8e 	M[r6 + 16] = rMAC;
84200596:	18 6e       	jump (m) Lc_aec_reference_buffer_details_10;

84200598 <Lc_aec_reference_buffer_details_7>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200598:	78 24       	Null = r5 - 1;
8420059a:	2d 62       	if NE jump (m) Lc_aec_reference_buffer_details_15;

8420059c <Lc_aec_reference_buffer_details_8>:
    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
        {
            /* override MIC endpoints */
            resp->needs_override = TRUE;
8420059c:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005a0:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
842005a4:	c9 c8       	rMAC = rMAC OR 0x4;
842005a6:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
            resp->b.buffer_size  = 0;
842005aa:	80 f0 04 8e 	M[r6 + 16] = Null;
842005ae:	21 6e       	jump (m) Lc_aec_reference_buffer_details_14;

842005b0 <Lc_aec_reference_buffer_details_9>:
                /* buffer size based on sample rate. task period + 2ms for safety,
                 * 2ms extra should be enough as assumption is that scheduling jitter
                 * assumed will not be too high.
                 */
                resp->b.buffer_size  =
                    frac_mult(op_extra_data->input_rate,FRACTIONAL(0.002)+op_extra_data->task_period_frac);
842005b0:	62 f0 64 88 	r0 = M[r4 + 400];
842005b4:	61 f0 93 88 	rMAC = M[r4 + 588];
842005b8:	06 f1 13 f0 	r1 = rMAC + 4294967;
842005bc:	37 31 
842005be:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842005c2:	82 f0 04 8e 	M[r6 + 16] = r0;

842005c6 <Lc_aec_reference_buffer_details_10>:

#ifdef AEC_REFERENCE_SUPPORT_METADATA
            /* currently metadata is supported only for
             * speaker input channels.
             */
            L3_DBG_MSG("AEC_REFERENCE: metadata is supported for speaker inputs");
842005c6:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842005ca:	c8 24       	Null = rMAC - 3;
842005cc:	07 68       	if LT jump (m) Lc_aec_reference_buffer_details_12;

842005ce <Lc_aec_reference_buffer_details_11>:
842005ce:	55 f1 02 f0 	r0 = Null + 357564489;
842005d2:	49 40 
842005d4:	ff fd 01 f0 	call (m) 0x9a2;
842005d8:	2f ee 

842005da <Lc_aec_reference_buffer_details_12>:
            resp->metadata_buffer = op_extra_data->spkr_input_metadata_buffer;
842005da:	61 f0 c9 88 	rMAC = M[r4 + 804];
842005de:	81 f0 03 8e 	M[r6 + 12] = rMAC;

842005e2 <Lc_aec_reference_buffer_details_13>:
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
                resp->supports_metadata = TRUE;
842005e2:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005e6:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
842005ea:	c9 c9       	rMAC = rMAC OR 0x10;
842005ec:	81 f0 08 8a 	MB[r6 + 8] = rMAC;

842005f0 <Lc_aec_reference_buffer_details_14>:
            }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
842005f0:	42 20       	r0 = Null + 1;
842005f2:	4e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

842005f4 <Lc_aec_reference_buffer_details_15>:
842005f4:	b8 24       	Null = r5 - 2;
842005f6:	d3 61       	if EQ jump (m) Lc_aec_reference_buffer_details_8;

842005f8 <Lc_aec_reference_buffer_details_16>:
842005f8:	f8 25       	Null = r5 - 7;
842005fa:	04 64       	if NC jump (m) Lc_aec_reference_buffer_details_18;

842005fc <Lc_aec_reference_buffer_details_17>:
842005fc:	38 27       	Null = r5 - 12;
842005fe:	f9 ff 9f ef 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200602 <Lc_aec_reference_buffer_details_18>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->output_buffer_size != 0)
84200602:	61 f0 d5 88 	rMAC = M[r4 + 852];
84200606:	14 60       	if EQ jump (m) Lc_aec_reference_buffer_details_21;

84200608 <Lc_aec_reference_buffer_details_19>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->output_buffer_size;
84200608:	81 f0 04 8e 	M[r6 + 16] = rMAC;

                if(AEC_REF_REFERENCE_TERMINAL == term_id)
8420060c:	38 04       	Null = r5 - Null;
8420060e:	26 62       	if NE jump (m) Lc_aec_reference_buffer_details_23;

84200610 <Lc_aec_reference_buffer_details_20>:
                     * within [ref_delay, ref_delay+jitter] range. For that reason we add an extra
                     * for ref buffer so mic output can use full output_buffer_size
                     */
                    unsigned ref_extra =
                        frac_mult(op_extra_data->output_rate,
                                  op_extra_data->task_period_frac + FRACTIONAL(0.001));
84200610:	62 f0 65 88 	r0 = M[r4 + 404];
84200614:	61 f0 93 88 	rMAC = M[r4 + 588];
84200618:	83 f0 13 f0 	r1 = rMAC + 2147483;
8420061c:	9b 28 
8420061e:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                    resp->b.buffer_size += ref_extra;
84200622:	81 f0 04 88 	rMAC = M[r6 + 16];
84200626:	51 00       	rMAC = r0 + rMAC;
84200628:	81 f0 04 8e 	M[r6 + 16] = rMAC;
8420062c:	17 6e       	jump (m) Lc_aec_reference_buffer_details_23;

8420062e <Lc_aec_reference_buffer_details_21>:
                }
            }
            else
            {
                unsigned two_task_period_size = frac_mult(op_extra_data->output_rate,
                                                          2*op_extra_data->task_period_frac) + 1;
8420062e:	62 f0 65 88 	r0 = M[r4 + 404];
84200632:	63 f0 93 88 	r1 = M[r4 + 588];
84200636:	1b 54       	r1 = r1 LSHIFT 1;
84200638:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420063c:	51 20       	rMAC = r0 + 1;
                /* buffer size based on sample rate */
                resp->b.buffer_size  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.0087));
8420063e:	62 f0 65 88 	r0 = M[r4 + 404];
84200642:	11 f0 83 f6 	r1 = Null + 18683107;
84200646:	e3 68 
84200648:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420064c:	82 f0 04 8e 	M[r6 + 16] = r0;
                /* given that this is for cvc-like operators and limited task periods that the
				 * operator supports, 8.7ms would be adequate for all use cases. In case of very
				 * high task period is used make sure output has space for at least two task period.
                 */
                resp->b.buffer_size = MAX(resp->b.buffer_size,
                                          two_task_period_size);
84200650:	50 04       	Null = r0 - rMAC;
84200652:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_buffer_details_23;

84200656 <Lc_aec_reference_buffer_details_22>:
84200656:	81 f0 04 8e 	M[r6 + 16] = rMAC;

8420065a <Lc_aec_reference_buffer_details_23>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
            /* Support metadta for microphone output channels (reference channel not included)
             * if enabled by the user.
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
8420065a:	60 f0 cd 88 	Null = M[r4 + 820];
8420065e:	c9 61       	if EQ jump (m) Lc_aec_reference_buffer_details_14;

84200660 <Lc_aec_reference_buffer_details_24>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200660:	f8 24       	Null = r5 - 3;
84200662:	c7 65       	if NC jump (m) Lc_aec_reference_buffer_details_14;

84200664 <Lc_aec_reference_buffer_details_25>:
84200664:	b8 25       	Null = r5 - 6;
84200666:	09 f0 8b e0 	if LS jump (m) Lc_aec_reference_buffer_details_27;

8420066a <Lc_aec_reference_buffer_details_26>:
8420066a:	38 2c       	Null = r5 - 16;
8420066c:	f8 ff 85 ef 	if HI jump (m) Lc_aec_reference_buffer_details_14;

84200670 <Lc_aec_reference_buffer_details_27>:
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
84200670:	61 f0 ca 88 	rMAC = M[r4 + 808];
84200674:	81 f0 03 8e 	M[r6 + 12] = rMAC;
84200678:	b5 6f       	jump (m) Lc_aec_reference_buffer_details_13;

8420067a <Lc_aec_reference_buffer_details_28>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
8420067a:	48 25       	Null = rMAC - 5;
8420067c:	f9 ff a1 ee 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200680 <Lc_aec_reference_buffer_details_29>:
    {
        return TRUE;
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200680:	02 00       	r0 = Null + Null;
84200682:	08 27       	Null = rMAC - 12;
84200684:	22 f0 42 ce 	if C r0 = Null + 1;
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;

    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
84200688:	10 04       	Null = r0 - Null;
8420068a:	89 63       	if NE jump (m) Lc_aec_reference_buffer_details_8;

8420068c <Lc_18>:
8420068c:	80 6f       	jump (m) Lc_aec_reference_buffer_details_5;

8420068e <Lc_aec_reference_buffer_details_30>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
}
8420068e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200690:	d8 4c       	rts;

84200692 <$_aec_reference_timer_task>:
        op_extra_data->sync_block.frm_count = 0;
    }
}

void aec_reference_timer_task(void *kick_object)
{
84200692:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200694:	13 09       	r9 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200696:	b6 f0 0c 88 	r4 = M[r9 + 48];
void aec_reference_timer_task(void *kick_object)
{
    OPERATOR_DATA         *op_data = (OPERATOR_DATA*) kick_object;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME next_fire_time;
    unsigned                 sink_kicks=0,source_kicks=0;
8420069a:	40 de       	M[FP + 32] = Null;
8420069c:	48 de       	M[FP + 36] = Null;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
8420069e:	b2 f0 08 88 	r0 = M[r9 + 32];
842006a2:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_3;

842006a4 <Lc_aec_reference_timer_task_2>:
    {
        PROFILER_START(op_data->profiler);
842006a4:	ff fd 64 f1 	call (m) 0x2d006;
842006a8:	23 eb 

842006aa <Lc_aec_reference_timer_task_3>:
    }
#endif

    patch_fn_shared(aec_reference_run);

    if(op_extra_data->ReInitFlag==TRUE)
842006aa:	61 f0 5c 88 	rMAC = M[r4 + 368];
842006ae:	48 24       	Null = rMAC - 1;
842006b0:	0c 62       	if NE jump (m) Lc_aec_reference_timer_task_7;

842006b2 <Lc_aec_reference_timer_task_4>:
    {
        op_extra_data->ReInitFlag=FALSE;
842006b2:	60 f0 5c 8e 	M[r4 + 368] = Null;

        /* Handle Reinitialize */
        if(op_extra_data->mic_sidetone_op)
842006b6:	62 f0 6c 88 	r0 = M[r4 + 432];
842006ba:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_6;

842006bc <Lc_aec_reference_timer_task_5>:
        {
            initialize_sidetone_filter_op(op_extra_data->mic_sidetone_op);
842006bc:	ff fd 58 f3 	call 0x6b82c;
842006c0:	30 eb 

842006c2 <Lc_aec_reference_timer_task_6>:
        }

        aec_reference_set_mic_gains(op_data);
842006c2:	5a 08       	r0 = r9 + Null;
842006c4:	05 f0 35 e9 	call (m) $_aec_reference_set_mic_gains;

842006c8 <Lc_aec_reference_timer_task_7>:
    }

    if(op_extra_data->mic_sidetone_op)
842006c8:	62 f0 6c 88 	r0 = M[r4 + 432];
842006cc:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_9;

842006ce <Lc_aec_reference_timer_task_8>:
    {
        update_sidetone_filter_op(op_extra_data->mic_sidetone_op,
                                  op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA,
                                  op_extra_data->shared_volume_ptr->ndvc_filter_sum_lpdnz);
842006ce:	61 f0 58 88 	rMAC = M[r4 + 352];
842006d2:	4c 88       	r2 = M[rMAC + 4];
842006d4:	61 f0 33 88 	rMAC = M[r4 + 204];
842006d8:	cb c1       	r1 = rMAC AND 0x10;
842006da:	ff fd 58 f3 	call 0x6b7d4;
842006de:	3a e7 

842006e0 <Lc_aec_reference_timer_task_9>:
        */
       && (0 != (op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA))
       /* Also check that both speaker and mic still connected */
       && (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
       && (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
       )
842006e0:	62 f0 99 88 	r0 = M[r4 + 612];
842006e4:	0e 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006e6 <Lc_aec_reference_timer_task_10>:
842006e6:	61 f0 33 88 	rMAC = M[r4 + 204];
842006ea:	c9 c1       	rMAC = rMAC AND 0x10;
842006ec:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006ee <Lc_aec_reference_timer_task_11>:
842006ee:	71 a8       	rMAC = M[r4 + 68];
842006f0:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006f2 <Lc_aec_reference_timer_task_12>:
842006f2:	b1 88       	rMAC = M[r4 + 8];
842006f4:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006f6 <Lc_aec_reference_timer_task_13>:
    {
        /* Run sidetone graph */
        cbops_process_data(op_extra_data->sidetone_graph, CBOPS_MAX_COPY_SIZE-1);
842006f6:	03 f0 ff 41 	r1 = Null + 511;
842006fa:	ff fd d9 f2 	call 0x5b9a4;
842006fe:	2a e5 

84200700 <Lc_aec_reference_timer_task_14>:
    }

    op_extra_data->task_decim_counter++;
84200700:	61 f0 98 88 	rMAC = M[r4 + 608];
84200704:	49 20       	rMAC = rMAC + 1;
84200706:	61 f0 98 8e 	M[r4 + 608] = rMAC;
    if(op_extra_data->task_decim_counter >= op_extra_data->task_decim_factor)
8420070a:	62 f0 97 88 	r0 = M[r4 + 604];
8420070e:	88 04       	Null = rMAC - r0;
84200710:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_16;

84200712 <Lc_aec_reference_timer_task_15>:
    {
        op_extra_data->task_decim_counter = 0;
84200712:	60 f0 98 8e 	M[r4 + 608] = Null;

84200716 <Lc_aec_reference_timer_task_16>:
    }
    if(op_extra_data->task_decim_counter == 0)
84200716:	60 f0 98 88 	Null = M[r4 + 608];
8420071a:	01 f0 fb e4 	if NE jump (m) Lc_aec_reference_timer_task_78;

8420071e <Lc_aec_reference_timer_task_17>:
    {
        /* Process the speaker path if we have speaker graph and
         * speaker is still connected
         */
        bool spkr_graph_active = (NULL != op_extra_data->spkr_graph) &&
            (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
8420071e:	61 f0 72 88 	rMAC = M[r4 + 456];
84200722:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_19;

84200724 <Lc_aec_reference_timer_task_18>:
84200724:	72 a8       	r0 = M[r4 + 68];
84200726:	01 00       	rMAC = Null + Null;
84200728:	80 04       	Null = Null - r0;
8420072a:	21 f0 41 ce 	if NE rMAC = Null + 1;
8420072e:	02 6e       	jump (m) Lc_aec_reference_timer_task_20;

84200730 <Lc_aec_reference_timer_task_19>:
84200730:	01 00       	rMAC = Null + Null;

84200732 <Lc_aec_reference_timer_task_20>:
84200732:	51 de       	M[FP + 40] = rMAC;

        /* Process the mic path if we have mic graph and
         * mic is still connected
         */
        bool mic_graph_active = (NULL != op_extra_data->mic_graph) &&
            (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84200734:	61 f0 6a 88 	rMAC = M[r4 + 424];
84200738:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_22;

8420073a <Lc_aec_reference_timer_task_21>:
8420073a:	b1 88       	rMAC = M[r4 + 8];
8420073c:	07 00       	r5 = Null + Null;
8420073e:	40 04       	Null = Null - rMAC;
84200740:	21 f0 47 ce 	if NE r5 = Null + 1;
84200744:	02 6e       	jump (m) Lc_aec_reference_timer_task_23;

84200746 <Lc_aec_reference_timer_task_22>:
84200746:	07 00       	r5 = Null + Null;

84200748 <Lc_aec_reference_timer_task_23>:
         * 1- we have a rate monitor op for speaker, and/or
         * 2- speaker hasn't started consuming (to detect start of flow)
         */
        if(spkr_graph_active &&
           (op_extra_data->spkr_rate_monitor_op != NULL ||
            !op_extra_data->spkr_flow_started))
84200748:	51 d8       	rMAC = M[FP + 40];
8420074a:	2f 60       	if EQ jump (m) Lc_aec_reference_timer_task_31;

8420074c <Lc_aec_reference_timer_task_24>:
8420074c:	61 f0 73 88 	rMAC = M[r4 + 460];
84200750:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_26;

84200752 <Lc_aec_reference_timer_task_25>:
84200752:	60 f0 d3 88 	Null = M[r4 + 844];
84200756:	29 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

84200758 <Lc_aec_reference_timer_task_26>:
             * since previous run and pass it to the rate monitor cbops op. The
             * op can use its transfer amount, however since speaker graph runs after mic
             * graph, the new amount will have bigger jitter which might affect
             * reference synchronisation.
             */
            tCbuffer *monbuf = op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1];
84200758:	69 f0 11 88 	r7 = M[r4 + 68];
            unsigned new_offset = cbuffer_get_read_mmu_offset(monbuf);
8420075c:	4a 08       	r0 = r7 + Null;
8420075e:	ff fd 91 f0 	call (m) 0x12a28;
84200762:	2b e6 
84200764:	10 09       	r6 = r0 + Null;
            if(new_offset >= op_extra_data->spkr_last_offset)
84200766:	61 f0 d1 88 	rMAC = M[r4 + 836];
8420076a:	1f f8 00 c2 	Null = r6 - rMAC;
8420076e:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_28;

84200770 <Lc_aec_reference_timer_task_27>:
            {
                op_extra_data->spkr_new_amount = new_offset - op_extra_data->spkr_last_offset;
84200770:	1f f8 01 c2 	rMAC = r6 - rMAC;
84200774:	61 f0 d2 8e 	M[r4 + 840] = rMAC;
84200778:	0c 6e       	jump (m) Lc_aec_reference_timer_task_29;

8420077a <Lc_aec_reference_timer_task_28>:
            }
            else
            {
                op_extra_data->spkr_new_amount = new_offset + cbuffer_get_size_in_words(monbuf) - op_extra_data->spkr_last_offset;
8420077a:	4a 08       	r0 = r7 + Null;
8420077c:	ff fd 90 f0 	call (m) 0x12858;
84200780:	3d e6 
84200782:	8f f2 01 c0 	rMAC = r0 + r6;
84200786:	62 f0 d1 88 	r0 = M[r4 + 836];
8420078a:	89 04       	rMAC = rMAC - r0;
8420078c:	61 f0 d2 8e 	M[r4 + 840] = rMAC;

84200790 <Lc_aec_reference_timer_task_29>:
            }
            op_extra_data->spkr_last_offset = new_offset;
84200790:	68 f0 d1 8e 	M[r4 + 836] = r6;

            /* Set a flag showing that speaker output has started consuming samples. */
            if(!op_extra_data->spkr_flow_started)
84200794:	60 f0 d3 88 	Null = M[r4 + 844];
84200798:	08 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

8420079a <Lc_aec_reference_timer_task_30>:
            {
                op_extra_data->spkr_flow_started = op_extra_data->spkr_new_amount != 0;
8420079a:	01 00       	rMAC = Null + Null;
8420079c:	60 f0 d2 88 	Null = M[r4 + 840];
842007a0:	21 f0 41 ce 	if NE rMAC = Null + 1;
842007a4:	61 f0 d3 8e 	M[r4 + 844] = rMAC;

842007a8 <Lc_aec_reference_timer_task_31>:
            }
        }
#endif /* AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT */

        /*  - Run MIC cbops */
        if(mic_graph_active)
842007a8:	38 04       	Null = r5 - Null;
842007aa:	7f 60       	if EQ jump (m) Lc_aec_reference_timer_task_57;

842007ac <Lc_aec_reference_timer_task_32>:
        {
            unsigned b4_space = 0;
            tCbuffer *mic_buf = op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1];
842007ac:	f7 a8       	r5 = M[r4 + 76];
            unsigned after_space;
            unsigned amount_produced;

            b4_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007ae:	3a 00       	r0 = r5 + Null;
842007b0:	ff fd 5d f1 	call (m) 0x2c1b6;
842007b4:	27 e0 
842007b6:	10 09       	r6 = r0 + Null;

            if(op_extra_data->spkr_ref_active
               || op_extra_data->mic_sync_enable)
842007b8:	60 f0 a0 88 	Null = M[r4 + 640];
842007bc:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_34;

842007be <Lc_aec_reference_timer_task_33>:
842007be:	60 f0 d4 88 	Null = M[r4 + 848];
842007c2:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_35;

842007c4 <Lc_aec_reference_timer_task_34>:
            {
                /* keep REFERENCE path and MIC output synchronised */
                aec_reference_update_mic_reference_sync(op_extra_data);
842007c4:	32 00       	r0 = r4 + Null;
842007c6:	0d f0 33 e4 	call (m) $_aec_reference_update_mic_reference_sync;

842007ca <Lc_aec_reference_timer_task_35>:
            }

            cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
842007ca:	03 f0 ff 41 	r1 = Null + 511;
842007ce:	62 f0 6a 88 	r0 = M[r4 + 424];
842007d2:	ff fd d8 f2 	call 0x5b9a4;
842007d6:	32 ee 
            after_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007d8:	3a 00       	r0 = r5 + Null;
842007da:	ff fd 5c f1 	call (m) 0x2c1b6;
842007de:	3d ee 

            /* Don't tolerate cbops writing more than available space */
            PL_ASSERT(b4_space >= after_space);
842007e0:	2f f8 00 c2 	Null = r6 - r0;
842007e4:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_timer_task_37;

842007e8 <Lc_aec_reference_timer_task_36>:
842007e8:	03 f0 db 5a 	r1 = Null + 3803;
842007ec:	02 f0 13 60 	r0 = Null + 4115;
842007f0:	ff fd 9b f0 	call (m) 0x13f12;
842007f4:	23 e9 
842007f6:	ec 6e       	jump (m) Lc_aec_reference_timer_task_81;

842007f8 <Lc_aec_reference_timer_task_37>:
            amount_produced = b4_space - after_space;
842007f8:	2f f8 0a c2 	r8 = r6 - r0;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
            if(op_extra_data->mic_metadata_buffer!= NULL
               && buff_has_metadata(op_extra_data->mic_metadata_buffer))
842007fc:	61 f0 ca 88 	rMAC = M[r4 + 808];
84200800:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_40;

84200802 <Lc_aec_reference_timer_task_38>:
84200802:	49 89       	rMAC = M[rMAC + 20];
84200804:	49 c6       	rMAC = rMAC AND 0x8000;
84200806:	05 60       	if EQ jump (m) Lc_aec_reference_timer_task_40;

84200808 <Lc_aec_reference_timer_task_39>:
            {
                aec_reference_mic_generate_metadata_with_ttp(op_extra_data, b4_space - after_space);
84200808:	53 08       	r1 = r8 + Null;
8420080a:	32 00       	r0 = r4 + Null;
8420080c:	04 f0 29 e8 	call (m) $_aec_reference_mic_generate_metadata_with_ttp;

84200810 <Lc_aec_reference_timer_task_40>:
               !op_extra_data->spkr_flow_started
#else
               /* insert silence until speaker graph hasn't started */
               !op_extra_data->spkr_ref_active
#endif
               )
84200810:	31 a8       	rMAC = M[r4 + 64];
84200812:	4b 60       	if EQ jump (m) Lc_aec_reference_timer_task_57;

84200814 <Lc_aec_reference_timer_task_41>:
84200814:	60 f0 d3 88 	Null = M[r4 + 844];
84200818:	48 62       	if NE jump (m) Lc_aec_reference_timer_task_57;

8420081a <Lc_aec_reference_timer_task_42>:
                 * Note: The synchronisation is normally done by the speaker latency operator
                 * however we don't have a running speaker graph at this situation, so is done
                 * manually here.
                 */

                unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
8420081a:	3a 00       	r0 = r5 + Null;
8420081c:	ff fd 5c f1 	call (m) 0x2c208;
84200820:	2d ef 
84200822:	17 00       	r5 = r0 + Null;
                /* if we have more than one mic, get max amount amnong all */
                unsigned idx;
                for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
84200824:	08 71       	r6 = Null + 1;
84200826:	0f 6e       	jump (m) Lc_aec_reference_timer_task_48;

84200828 <Lc_aec_reference_timer_task_43>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200828:	82 f0 09 20 	r0 = r6 + 9;

8420082c <Lc_aec_reference_timer_task_44>:
8420082c:	61 f0 40 20 	rMAC = r4 + 64;
84200830:	52 54       	r0 = r0 LSHIFT 2;
                    if(NULL != out_buf)
84200832:	8a e8       	r0 = M[rMAC + r0];
84200834:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_47;

84200836 <Lc_aec_reference_timer_task_45>:
                    {
                        unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
84200836:	ff fd 5c f1 	call (m) 0x2c208;
8420083a:	33 ee 
                        mic_out_data = MAX(out_data, mic_out_data);
8420083c:	d0 05       	Null = r0 - r5;
8420083e:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_47;

84200840 <Lc_aec_reference_timer_task_46>:
84200840:	17 00       	r5 = r0 + Null;

84200842 <Lc_aec_reference_timer_task_47>:
                 */

                unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
                /* if we have more than one mic, get max amount amnong all */
                unsigned idx;
                for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
84200842:	08 75       	r6 = r6 + 1;

84200844 <Lc_aec_reference_timer_task_48>:
84200844:	61 f0 78 88 	rMAC = M[r4 + 480];
84200848:	1f f8 00 c2 	Null = r6 - rMAC;
8420084c:	02 f0 91 e0 	if C jump (m) Lc_aec_reference_timer_task_51;

84200850 <Lc_aec_reference_timer_task_49>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200850:	80 f0 02 24 	Null = r6 - 2;
84200854:	f2 ff d5 ef 	if C jump (m) Lc_aec_reference_timer_task_43;

84200858 <Lc_aec_reference_timer_task_50>:
84200858:	02 21       	r0 = Null + 4;
8420085a:	e9 6f       	jump (m) Lc_aec_reference_timer_task_44;

8420085c <Lc_aec_reference_timer_task_51>:
                    {
                        unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
                        mic_out_data = MAX(out_data, mic_out_data);
                    }
                }
                tCbuffer *ref_buf = op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL];
8420085c:	68 f0 10 88 	r6 = M[r4 + 64];
                unsigned ref_data = cbuffer_calc_amount_data_in_words(ref_buf);
84200860:	42 08       	r0 = r6 + Null;
84200862:	ff fd 5c f1 	call (m) 0x2c208;
84200866:	27 ed 
84200868:	11 09       	r7 = r0 + Null;
                unsigned ideal_amount = mic_out_data +
                    op_extra_data->sync_block.ref_delay +
                    (op_extra_data->sync_block.jitter/2);
8420086a:	62 f0 85 88 	r0 = M[r4 + 532];
8420086e:	61 f0 8a 88 	rMAC = M[r4 + 552];
84200872:	12 50       	r0 = r0 LSHIFT -1;
84200874:	51 00       	rMAC = r0 + rMAC;
84200876:	cf 01       	r5 = rMAC + r5;
                /* We only insert, dropping is done via waiting for mic buffer to fill up */
                unsigned amount_to_insert = 0;
                if(ideal_amount > ref_data)
84200878:	9f f7 00 c2 	Null = r5 - r7;
8420087c:	09 f0 ad e0 	if LS jump (m) Lc_aec_reference_timer_task_57;

84200880 <Lc_aec_reference_timer_task_52>:
                {
                    unsigned ref_space = cbuffer_calc_amount_space_in_words(ref_buf);
84200880:	42 08       	r0 = r6 + Null;
84200882:	ff fd 5c f1 	call (m) 0x2c1b6;
84200886:	35 e9 
                    amount_to_insert = ideal_amount - ref_data;
84200888:	9f f7 03 c2 	r1 = r5 - r7;
                     * Note: limit to amount_produced*3/2, since we own only the write
                     * side of the buffer, although the read sides are syncronised by
                     * consumer but there is a chance the this operator preempt the consumer
                     * right at the middle of read pointer update. For that reason we apply this limit
                     */
                    amount_to_insert = MIN(amount_to_insert, amount_produced*3/2);
8420088c:	01 fa 94 d9 	r2 = r8 * 3 (int);
84200890:	24 50       	r2 = r2 LSHIFT -1;
84200892:	18 05       	Null = r1 - r2;
84200894:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_54;

84200896 <Lc_aec_reference_timer_task_53>:
84200896:	23 00       	r1 = r2 + Null;

84200898 <Lc_aec_reference_timer_task_54>:
                    amount_to_insert = MIN(amount_to_insert, ref_space);
84200898:	98 04       	Null = r1 - r0;
8420089a:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_56;

8420089c <Lc_aec_reference_timer_task_55>:
8420089c:	13 00       	r1 = r0 + Null;

8420089e <Lc_aec_reference_timer_task_56>:

                    /* insert silence */
                    cbuffer_block_fill(ref_buf, amount_to_insert, 0);
8420089e:	04 00       	r2 = Null + Null;
842008a0:	42 08       	r0 = r6 + Null;
842008a2:	ff fd 5d f1 	call (m) 0x2c2e8;
842008a6:	27 e2 

842008a8 <Lc_aec_reference_timer_task_57>:
                }
            }
        }

        /*  - Run SPKR cbops */
        if(spkr_graph_active)
842008a8:	51 d8       	rMAC = M[FP + 40];
842008aa:	57 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

842008ac <Lc_aec_reference_timer_task_58>:
        {
#ifdef AEC_REFERENCE_SUPPORT_METADATA
            unsigned max_to_process = CBOPS_MAX_COPY_SIZE-1;
842008ac:	01 f0 ff 41 	rMAC = Null + 511;
842008b0:	59 de       	M[FP + 44] = rMAC;
            tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
            unsigned before_amount = 0;
842008b2:	00 09       	r6 = Null + Null;
            if(met_buf!= NULL && buff_has_metadata(met_buf))
842008b4:	67 f0 c9 88 	r5 = M[r4 + 804];
842008b8:	19 60       	if EQ jump (m) Lc_aec_reference_timer_task_63;

842008ba <Lc_aec_reference_timer_task_59>:
842008ba:	79 89       	rMAC = M[r5 + 20];
842008bc:	49 c6       	rMAC = rMAC AND 0x8000;
842008be:	1f 60       	if EQ jump (m) Lc_aec_reference_timer_task_64;

842008c0 <Lc_aec_reference_timer_task_60>:
            {
                /* amount of metadata available */
                unsigned meta_data_available = buff_metadata_available_octets(met_buf)/OCTETS_PER_SAMPLE;
842008c0:	3a 00       	r0 = r5 + Null;
842008c2:	ff fd 8a f0 	call (m) 0x11d04;
842008c6:	23 e2 
842008c8:	7f f2 d9 c8 	r7 = r0 LSHIFT -2;

                /* get amount in the buffer before running cbops */
                before_amount = cbuffer_calc_amount_data_in_words(met_buf);
842008cc:	3a 00       	r0 = r5 + Null;
842008ce:	ff fd 5c f1 	call (m) 0x2c208;
842008d2:	3b e9 
842008d4:	10 09       	r6 = r0 + Null;

                /* if we have metadata enabled then limit the amount to
                 * process to the amount of available metadata
                 */
                max_to_process = MIN(max_to_process, meta_data_available);
842008d6:	59 d8       	rMAC = M[FP + 44];
842008d8:	9f f1 00 c2 	Null = rMAC - r7;
842008dc:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_62;

842008de <Lc_aec_reference_timer_task_61>:
842008de:	e9 f0 0b 8e 	M[FP + 44] = r7;

842008e2 <Lc_aec_reference_timer_task_62>:
#ifdef AEC_REFERENCE_SPKR_TTP
                /* Run TTP error control for speaker graph */
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
842008e2:	c3 12       	r1 = FP + 44;
842008e4:	32 00       	r0 = r4 + Null;
842008e6:	0e f0 3b e9 	call (m) $_aec_reference_spkr_ttp_run;

842008ea <Lc_aec_reference_timer_task_63>:
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842008ea:	5b d8       	r1 = M[FP + 44];
842008ec:	62 f0 72 88 	r0 = M[r4 + 456];
842008f0:	ff fd d8 f2 	call 0x5b9a4;
842008f4:	34 e5 

            if(met_buf!= NULL && buff_has_metadata(met_buf))
842008f6:	38 04       	Null = r5 - Null;
842008f8:	09 62       	if NE jump (m) Lc_aec_reference_timer_task_65;

842008fa <Lc_19>:
842008fa:	27 6e       	jump (m) Lc_aec_reference_timer_task_69;

842008fc <Lc_aec_reference_timer_task_64>:
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842008fc:	03 f0 ff 41 	r1 = Null + 511;
84200900:	62 f0 72 88 	r0 = M[r4 + 456];
84200904:	ff fd d8 f2 	call 0x5b9a4;
84200908:	20 e5 

8420090a <Lc_aec_reference_timer_task_65>:
8420090a:	79 89       	rMAC = M[r5 + 20];
8420090c:	49 c6       	rMAC = rMAC AND 0x8000;
8420090e:	1d 60       	if EQ jump (m) Lc_aec_reference_timer_task_69;

84200910 <Lc_aec_reference_timer_task_66>:
                 * The assumption is that the write pointer of
                 * input buffer isn't changed during cbops
                 * process.
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
84200910:	3a 00       	r0 = r5 + Null;
84200912:	ff fd 5c f1 	call (m) 0x2c208;
84200916:	37 e7 
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
84200918:	8f f2 00 c2 	Null = r0 - r6;
8420091c:	08 f0 a5 e1 	if HI jump (m) Lc_aec_reference_timer_task_80;

84200920 <Lc_aec_reference_timer_task_67>:
                amount_processed = before_amount - after_amount;
84200920:	00 f2 38 c2 	r6 = r6 - r0;
                     */
                    unsigned buff_size = cbuffer_get_size_in_words(met_buf);
                    amount_processed = buff_size + before_amount - after_amount;
                }
#endif /* TODO_AEC_REFERENCE_TTP */
                if(amount_processed > 0)
84200924:	0f f8 00 c2 	Null = r6 - Null;
84200928:	10 60       	if EQ jump (m) Lc_aec_reference_timer_task_69;

8420092a <Lc_aec_reference_timer_task_68>:
                {
                    /* delete metadata tags for consumed input */
                    unsigned b4idx, afteridx;
                    buff_metadata_tag_list_delete(
                        buff_metadata_remove(met_buf, OCTETS_PER_SAMPLE * amount_processed, &b4idx, &afteridx));
8420092a:	45 13       	r3 = FP + 52;
8420092c:	04 13       	r2 = FP + 48;
8420092e:	01 f8 d3 c8 	r1 = r6 LSHIFT 2;
84200932:	3a 00       	r0 = r5 + Null;
84200934:	ff fd 8a f0 	call (m) 0x11d7a;
84200938:	27 e2 
8420093a:	ff fd 87 f0 	call (m) 0x11906;
8420093e:	2d ee 
                    /* update timestamp */
                    aec_reference_spkr_ttp_update_last_timestamp(op_extra_data, amount_processed);
84200940:	43 08       	r1 = r6 + Null;
84200942:	32 00       	r0 = r4 + Null;
84200944:	0e f0 3d ef 	call (m) $_aec_reference_spkr_ttp_update_last_timestamp;

84200948 <Lc_aec_reference_timer_task_69>:
            }
#else /* AEC_REFERENCE_SUPPORT_METADATA */
            cbops_process_data(op_extra_data->spkr_graph, CBOPS_MAX_COPY_SIZE-1);
#endif /* AEC_REFERENCE_SUPPORT_METADATA*/
#ifdef PROFILER_ON
            if (op_data->profiler != NULL)
84200948:	b1 f0 08 88 	rMAC = M[r9 + 32];
8420094c:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

8420094e <Lc_aec_reference_timer_task_70>:
            {
                op_data->profiler->kick_inc++;
8420094e:	12 f0 2a 88 	r0 = M[rMAC + 168];
84200952:	52 20       	r0 = r0 + 1;
84200954:	12 f0 2a 8e 	M[rMAC + 168] = r0;

84200958 <Lc_aec_reference_timer_task_71>:
            }
#endif            
        }

        /* Check for Kicks (outputs).   Use Output 1 available data*/
        if(op_extra_data->sync_block.block_sync)
84200958:	60 f0 87 88 	Null = M[r4 + 540];
8420095c:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

8420095e <Lc_aec_reference_timer_task_72>:
        {
            source_kicks = op_extra_data->source_kicks;
8420095e:	61 f0 7b 88 	rMAC = M[r4 + 492];
84200962:	49 de       	M[FP + 36] = rMAC;
            op_extra_data->sync_block.block_sync = 0;
84200964:	60 f0 87 8e 	M[r4 + 540] = Null;

84200968 <Lc_aec_reference_timer_task_73>:
        }

        /* Check for Kick (inputs).   Use Input 1 available space */
        if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1])
84200968:	32 e8       	r0 = M[r4 + Null];
8420096a:	0d 60       	if EQ jump (m) Lc_aec_reference_timer_task_76;

8420096c <Lc_aec_reference_timer_task_74>:
        {
            int available_space = cbuffer_calc_amount_space_in_words(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1]);
8420096c:	ff fd 5c f1 	call (m) 0x2c1b6;
84200970:	2b e2 

            if(available_space >= op_extra_data->spkr_kick_size)
84200972:	61 f0 75 88 	rMAC = M[r4 + 468];
84200976:	50 04       	Null = r0 - rMAC;
84200978:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_76;

8420097a <Lc_aec_reference_timer_task_75>:
            {
                sink_kicks = op_extra_data->sink_kicks;
8420097a:	61 f0 7c 88 	rMAC = M[r4 + 496];
8420097e:	41 de       	M[FP + 32] = rMAC;
            }
        }


        if(sink_kicks || source_kicks)
84200980:	08 04       	Null = rMAC - Null;
84200982:	03 62       	if NE jump (m) Lc_aec_reference_timer_task_77;

84200984 <Lc_aec_reference_timer_task_76>:
84200984:	49 d8       	rMAC = M[FP + 36];
84200986:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_78;

84200988 <Lc_aec_reference_timer_task_77>:
        {
            opmgr_kick_from_operator(op_data,source_kicks,sink_kicks);
84200988:	5a 08       	r0 = r9 + Null;
8420098a:	44 d8       	r2 = M[FP + 32];
8420098c:	4b d8       	r1 = M[FP + 36];
8420098e:	ff fd 11 f0 	call (m) 0x2d10;
84200992:	23 ec 

84200994 <Lc_aec_reference_timer_task_78>:
        }
    }

/* Next Timer Event */
    next_fire_time = time_add(get_last_fire_time(), op_extra_data->kick_period);
84200994:	ff fd 9c f0 	call (m) 0x14334;
84200998:	21 ed 
8420099a:	61 f0 94 88 	rMAC = M[r4 + 592];
8420099e:	8a 00       	r0 = rMAC + r0;
    op_extra_data->kick_id = timer_schedule_event_at(next_fire_time,
                                                     aec_reference_timer_task, (void*)op_data);
842009a0:	42 f0 03 f0 	r1 = Null + 69207699;
842009a4:	93 4a 
INLINE_SECTION static inline tTimerId timer_schedule_event_at(
       TIME event_time,
       tTimerEventFunction TimerEventFunction,
       void *data_pointer)
{
    return create_add_strict_event(event_time, TimerEventFunction, data_pointer);
842009a6:	5c 08       	r2 = r9 + Null;
842009a8:	ff fd 9b f0 	call (m) 0x1402a;
842009ac:	23 e4 
}
842009ae:	62 f0 5d 8e 	M[r4 + 372] = r0;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
842009b2:	b2 f0 08 88 	r0 = M[r9 + 32];
842009b6:	0c 60       	if EQ jump (m) Lc_aec_reference_timer_task_81;

842009b8 <Lc_aec_reference_timer_task_79>:
    {
        PROFILER_STOP(op_data->profiler);
842009b8:	ff fd 63 f1 	call (m) 0x2d0d0;
842009bc:	39 e8 
842009be:	08 6e       	jump (m) Lc_aec_reference_timer_task_81;

842009c0 <Lc_aec_reference_timer_task_80>:
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
842009c0:	03 f0 50 5b 	r1 = Null + 3920;
842009c4:	02 f0 13 60 	r0 = Null + 4115;
842009c8:	ff fd 9a f0 	call (m) 0x13f12;
842009cc:	2b ea 

842009ce <Lc_aec_reference_timer_task_81>:
    if (op_data->profiler != NULL)
    {
        PROFILER_STOP(op_data->profiler);
    }
#endif
}
842009ce:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842009d0:	d8 4c       	rts;

842009d2 <$_aec_reference_opmsg_ep_get_config>:
    return;
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842009d2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842009d4:	17 99       	r5 = M[r0 + 48];

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_GET_CONFIG *msg = message_data;
    OPMSG_GET_CONFIG_RESULT *result = msg->result;
842009d6:	1e 89       	r4 = M[r1 + 16];
    unsigned term_idx = msg->header.cmd_header.client_id;
842009d8:	19 e8       	rMAC = M[r1 + Null];

    /* msg->value - Pointer which will be populated with the asked configuration value
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
842009da:	da 88       	r0 = M[r1 + 12];
842009dc:	d0 24       	Null = r0 - 3;
842009de:	62 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

842009e0 <Lc_aec_reference_opmsg_ep_get_config_2>:
842009e0:	d0 26       	Null = r0 - 11;
842009e2:	08 f0 c1 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

842009e6 <Lc_aec_reference_opmsg_ep_get_config_3>:
842009e6:	ea 7c       	r0 = r0 + -3;
842009e8:	52 54       	r0 = r0 LSHIFT 2;
842009ea:	e0 f0 22 f0 	r0 = M[r0 + 7340280];
842009ee:	3e 88 
842009f0:	da 4c       	jump r0;

842009f2 <Lc_aec_reference_opmsg_ep_get_config_4>:
    {
        case OPMSG_OP_TERMINAL_DETAILS:
            /* Return a uint32 - Is Terminal emulating a real endpoint. Called at operator endpoint creation.
             */
            if(term_idx & TERMINAL_SINK_MASK)
842009f2:	40 f0 12 f0 	r0 = rMAC AND 0x800000;
842009f6:	00 00 
842009f8:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_8;

842009fa <Lc_aec_reference_opmsg_ep_get_config_5>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
842009fa:	bf ff 11 ff 	rMAC = rMAC AND 0xff7fffff;
842009fe:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
84200a00:	88 24       	Null = rMAC - 2;
84200a02:	02 f0 a5 e1 	if C jump (m) Lc_aec_reference_opmsg_ep_get_config_29;

84200a06 <Lc_aec_reference_opmsg_ep_get_config_6>:
    {
        return FALSE;
84200a06:	02 00       	r0 = Null + Null;

84200a08 <Lc_aec_reference_opmsg_ep_get_config_7>:
            {
                result->value = (uint32)(IsMicrophoneTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200a08:	01 00       	rMAC = Null + Null;
84200a0a:	10 04       	Null = r0 - Null;
84200a0c:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84200a10:	31 ee       	M[r4 + Null] = rMAC;
84200a12:	21 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a14 <Lc_aec_reference_opmsg_ep_get_config_8>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200a14:	48 24       	Null = rMAC - 1;
84200a16:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200a18 <Lc_aec_reference_opmsg_ep_get_config_9>:
84200a18:	88 24       	Null = rMAC - 2;
84200a1a:	06 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200a1c <Lc_aec_reference_opmsg_ep_get_config_10>:
84200a1c:	c8 25       	Null = rMAC - 7;
84200a1e:	4e 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200a20 <Lc_aec_reference_opmsg_ep_get_config_11>:
84200a20:	08 27       	Null = rMAC - 12;
84200a22:	08 f0 99 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200a26 <Lc_aec_reference_opmsg_ep_get_config_12>:
84200a26:	41 20       	rMAC = Null + 1;
84200a28:	4a 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_33;

84200a2a <Lc_aec_reference_opmsg_ep_get_config_13>:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200a2a:	00 f2 10 f0 	Null = rMAC - 8388608;
84200a2e:	00 24 
84200a30:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_15;

84200a32 <Lc_aec_reference_opmsg_ep_get_config_14>:
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
84200a32:	71 f0 6f 88 	rMAC = M[r5 + 444];
84200a36:	31 ee       	M[r4 + Null] = rMAC;
84200a38:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_18;

84200a3a <Lc_aec_reference_opmsg_ep_get_config_15>:
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
                }
#endif
            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200a3a:	c8 24       	Null = rMAC - 3;
84200a3c:	0e 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200a3e <Lc_aec_reference_opmsg_ep_get_config_16>:
            {

                if(op_extra_data->mic_sync_enable)
84200a3e:	70 f0 d4 88 	Null = M[r5 + 848];
84200a42:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200a44 <Lc_aec_reference_opmsg_ep_get_config_17>:
                    result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
                }
                else
                {

                    result->value = (uint32)op_extra_data->mic_rate_ability;
84200a44:	71 f0 67 88 	rMAC = M[r5 + 412];
84200a48:	31 ee       	M[r4 + Null] = rMAC;

84200a4a <Lc_aec_reference_opmsg_ep_get_config_18>:
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
#ifdef ENABLE_FORCE_ENACTING_BY_AEC_REFERENCE
                if(RATEMATCHING_SUPPORT_SW == result->value)
84200a4a:	31 e8       	rMAC = M[r4 + Null];
84200a4c:	48 24       	Null = rMAC - 1;
84200a4e:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a50 <Lc_aec_reference_opmsg_ep_get_config_19>:
                {
                    /* Advertise HW despite planning to do it in SW
                     * this will make sure that enacting will be granted
                     * to this end.
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
84200a50:	81 20       	rMAC = Null + 2;
84200a52:	31 ee       	M[r4 + Null] = rMAC;

84200a54 <Lc_aec_reference_opmsg_ep_get_config_20>:
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
    }

    return TRUE;
84200a54:	42 20       	r0 = Null + 1;
84200a56:	39 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200a58 <Lc_aec_reference_opmsg_ep_get_config_21>:
                }

            }
            else
            {
                result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
84200a58:	c1 20       	rMAC = Null + 3;
84200a5a:	31 ee       	M[r4 + Null] = rMAC;
84200a5c:	fc 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a5e <Lc_aec_reference_opmsg_ep_get_config_22>:
            break;
        case OPMSG_OP_TERMINAL_KICK_PERIOD:       /* uint32 */
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_RATE:    /* uint32 */

            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200a5e:	00 f2 10 f0 	Null = rMAC - 8388608;
84200a62:	00 24 
84200a64:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_24;

84200a66 <Lc_aec_reference_opmsg_ep_get_config_23>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84200a66:	72 f0 73 88 	r0 = M[r5 + 460];
84200a6a:	03 00       	r1 = Null + Null;
84200a6c:	ff fd 58 f3 	call 0x6bbf0;
84200a70:	24 ec 
84200a72:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->spkr_rate_meas = (unsigned)(result->value);
84200a74:	72 f0 83 8e 	M[r5 + 524] = r0;
84200a78:	ee 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a7a <Lc_aec_reference_opmsg_ep_get_config_24>:

            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200a7a:	c8 24       	Null = rMAC - 3;
84200a7c:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_26;

84200a7e <Lc_aec_reference_opmsg_ep_get_config_25>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
84200a7e:	72 f0 6b 88 	r0 = M[r5 + 428];
84200a82:	03 00       	r1 = Null + Null;
84200a84:	ff fd 58 f3 	call 0x6bbf0;
84200a88:	2c eb 
84200a8a:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->mic_rate_meas = (unsigned)(result->value);
84200a8c:	72 f0 84 8e 	M[r5 + 528] = r0;
84200a90:	e2 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a92 <Lc_aec_reference_opmsg_ep_get_config_26>:
            }
            else
            {
                /* 1.0 in Qx.22 independent of word width */
                result->value = 1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT;
84200a92:	04 f0 01 f0 	rMAC = Null + 4194304;
84200a96:	00 40 
84200a98:	31 ee       	M[r4 + Null] = rMAC;
84200a9a:	dd 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a9c <Lc_aec_reference_opmsg_ep_get_config_27>:
            }

            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_MEASUREMENT:
            /* TODO */
            result->rm_measurement.sp_deviation = 0;
84200a9c:	30 ee       	M[r4 + Null] = Null;
            result->rm_measurement.measurement.valid = FALSE;
84200a9e:	30 8b       	MB[r4 + 4] = Null;
            break;
84200aa0:	da 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200aa2 <Lc_aec_reference_opmsg_ep_get_config_28>:
        case OPMSG_OP_TERMINAL_BLOCK_SIZE:        /* uint32 */
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
84200aa2:	02 00       	r0 = Null + Null;
84200aa4:	12 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200aa6 <Lc_aec_reference_opmsg_ep_get_config_29>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200aa6:	48 25       	Null = rMAC - 5;
84200aa8:	08 f0 89 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_31;

84200aac <Lc_aec_reference_opmsg_ep_get_config_30>:
    {
        return TRUE;
84200aac:	42 20       	r0 = Null + 1;
84200aae:	ad 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200ab0 <Lc_aec_reference_opmsg_ep_get_config_31>:
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200ab0:	02 00       	r0 = Null + Null;
84200ab2:	08 27       	Null = rMAC - 12;
84200ab4:	22 f0 42 ce 	if C r0 = Null + 1;
84200ab8:	a8 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200aba <Lc_aec_reference_opmsg_ep_get_config_32>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200aba:	01 00       	rMAC = Null + Null;

84200abc <Lc_aec_reference_opmsg_ep_get_config_33>:
            }
            else
            {
                result->value = (uint32)(IsSpeakerTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200abc:	02 00       	r0 = Null + Null;
84200abe:	08 04       	Null = rMAC - Null;
84200ac0:	20 f0 42 ce 	if EQ r0 = Null + 1;
84200ac4:	32 ee       	M[r4 + Null] = r0;
84200ac6:	c7 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200ac8 <Lc_aec_reference_opmsg_ep_get_config_34>:
        default:
            return FALSE;
    }

    return TRUE;
}
84200ac8:	f2 48       	popm <FP, r4, r5, rLink>;
84200aca:	d8 4c       	rts;

84200acc <$_aec_reference_opmsg_ep_configure>:


bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200acc:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200ace:	16 99       	r4 = M[r0 + 48];

bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_CONFIGURE  *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200ad0:	19 e8       	rMAC = M[r1 + Null];
    uint32      value = msg->value;
84200ad2:	1f 89       	r5 = M[r1 + 16];

    /* msg->value - Pointer or Value for Key
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200ad4:	da 88       	r0 = M[r1 + 12];
84200ad6:	0c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200ad8 <Lc_aec_reference_opmsg_ep_configure_2>:
84200ad8:	90 26       	Null = r0 - 10;
84200ada:	08 f0 95 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200ade <Lc_aec_reference_opmsg_ep_configure_3>:
84200ade:	52 24       	r0 = r0 - 1;
84200ae0:	52 54       	r0 = r0 LSHIFT 2;
84200ae2:	e0 f0 22 f0 	r0 = M[r0 + 7340316];
84200ae6:	47 88 
84200ae8:	da 4c       	jump r0;

84200aea <Lc_aec_reference_opmsg_ep_configure_4>:
    {
        case OPMSG_OP_TERMINAL_DATA_FORMAT:
            /* value is data type */
            if( ((AUDIO_DATA_FORMAT)msg->value)!=AUDIO_DATA_FORMAT_FIXP )
84200aea:	78 24       	Null = r5 - 1;
84200aec:	e7 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200aee <Lc_aec_reference_opmsg_ep_configure_5>:
            {
                return(FALSE);
84200aee:	02 00       	r0 = Null + Null;
84200af0:	e6 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_56;

84200af2 <Lc_aec_reference_opmsg_ep_configure_6>:
               TODO - Really need to know type of endpoint: ADC/DAC, I2S, Digital MIC

               CBOPS_DC_REMOVE | CBOPS_SHIFT (set data format --> AUDIO_DATA_FORMAT_FIXP)
               CBOPS_RATEADJUST (EP_RATEMATCH_ENACTING) */

            if(terminal_id == (AEC_REF_MIC_TERMINAL1|TERMINAL_SINK_MASK) )
84200af2:	00 f2 10 f0 	Null = rMAC - 8388610;
84200af6:	02 24 
84200af8:	08 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_8;

84200afa <Lc_aec_reference_opmsg_ep_configure_7>:
            {
                op_extra_data->mic_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200afa:	3a 00       	r0 = r5 + Null;
84200afc:	ff fd 1f f0 	call (m) 0x49da;
84200b00:	3f e6 
84200b02:	62 f0 6d 8e 	M[r4 + 436] = r0;
84200b06:	da 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b08 <Lc_aec_reference_opmsg_ep_configure_8>:
            }
            else if (terminal_id == AEC_REF_SPKR_TERMINAL1)
84200b08:	48 24       	Null = rMAC - 1;
84200b0a:	d8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b0c <Lc_aec_reference_opmsg_ep_configure_9>:
            {
                op_extra_data->spkr_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200b0c:	3a 00       	r0 = r5 + Null;
84200b0e:	ff fd 1f f0 	call (m) 0x49da;
84200b12:	2d e6 
84200b14:	62 f0 74 8e 	M[r4 + 464] = r0;
84200b18:	d1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b1a <Lc_aec_reference_opmsg_ep_configure_10>:
            /* uint32 expected block size per period

               endpoint->state.audio.block_size = (unsigned int)value;
               endpoint->state.audio.kick_period =  (unsigned int)(value * (unsigned long)STREAM_KICK_PERIOD_FROM_USECS(1000000UL) /
               endpoint->state.audio.sample_rate); */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200b1a:	00 f2 10 f0 	Null = rMAC - 8388608;
84200b1e:	00 24 
84200b20:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_12;

84200b22 <Lc_aec_reference_opmsg_ep_configure_11>:
            {
                op_extra_data->spkr_kick_size = (unsigned)value;
84200b22:	67 f0 75 8e 	M[r4 + 468] = r5;
84200b26:	ca 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b28 <Lc_aec_reference_opmsg_ep_configure_12>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1)
84200b28:	c8 24       	Null = rMAC - 3;
84200b2a:	c8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b2c <Lc_aec_reference_opmsg_ep_configure_13>:

                /* mic-ref block_size latency control only works for larger block sizes, it will fail
                 * if requested block size is small, so we apply a minimum block size, below
                 * that mic-ref latency control logic will be turned off.
                 */
                unsigned min_block_size = frac_mult(op_extra_data->output_rate, FRACTIONAL(0.006));
84200b2c:	62 f0 65 88 	r0 = M[r4 + 404];
84200b30:	0c f0 43 f2 	r1 = Null + 12884901;
84200b34:	a5 73 
84200b36:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                /* Validate block size for sync logic.   Output buffers size will be at least 8.7 msec of data */
                if(block_size && (block_size < min_block_size) )
84200b3a:	39 00       	rMAC = r5 + Null;
84200b3c:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200b3e <Lc_aec_reference_opmsg_ep_configure_14>:
84200b3e:	b8 04       	Null = r5 - r0;
84200b40:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200b44 <Lc_aec_reference_opmsg_ep_configure_15>:
                {
                    /* Disable sync logic if block_size is to small */
                    block_size = 0;
84200b44:	01 00       	rMAC = Null + Null;

84200b46 <Lc_aec_reference_opmsg_ep_configure_16>:
                }
                op_extra_data->sync_block.block_size = block_size;
84200b46:	61 f0 86 8e 	M[r4 + 536] = rMAC;
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                {
                    /* update minimum len metadata tags for mic output */
                    op_extra_data->mic_metadata_min_tag_len =
                        MAX(op_extra_data->mic_metadata_min_tag_len,
                            op_extra_data->sync_block.block_size);
84200b4a:	62 f0 cc 88 	r0 = M[r4 + 816];
84200b4e:	50 04       	Null = r0 - rMAC;
84200b50:	02 f0 eb e2 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b54 <Lc_aec_reference_opmsg_ep_configure_17>:
84200b54:	61 f0 cc 8e 	M[r4 + 816] = rMAC;
84200b58:	b1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b5a <Lc_aec_reference_opmsg_ep_configure_18>:
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ENACTING:
            /* uint32 TRUE or FALSE.   Operator should perform rate matching if TRUE  */

            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200b5a:	00 f2 10 f0 	Null = rMAC - 8388608;
84200b5e:	00 24 
84200b60:	2a 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_27;

84200b62 <Lc_aec_reference_opmsg_ep_configure_19>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint,value);
84200b62:	62 f0 80 88 	r0 = M[r4 + 512];
84200b66:	3b 00       	r1 = r5 + Null;
84200b68:	ff fd 1f f0 	call (m) 0x4a3e;
84200b6c:	37 e6 
                if(value==(uint32)FALSE)
84200b6e:	38 04       	Null = r5 - Null;
84200b70:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_21;

84200b72 <Lc_aec_reference_opmsg_ep_configure_20>:
                {
                    op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200b72:	60 f0 71 8e 	M[r4 + 452] = Null;
84200b76:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_22;

84200b78 <Lc_aec_reference_opmsg_ep_configure_21>:
                }
                else
                {
                    op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84200b78:	61 f0 6f 88 	rMAC = M[r4 + 444];
84200b7c:	61 f0 71 8e 	M[r4 + 452] = rMAC;

84200b80 <Lc_aec_reference_opmsg_ep_configure_22>:
                }

                if((op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->spkr_rate_monitor_op))
84200b80:	61 f0 71 88 	rMAC = M[r4 + 452];
84200b84:	88 24       	Null = rMAC - 2;
84200b86:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200b88 <Lc_aec_reference_opmsg_ep_configure_23>:
84200b88:	62 f0 73 88 	r0 = M[r4 + 460];
84200b8c:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200b8e <Lc_aec_reference_opmsg_ep_configure_24>:
                {
                    rate_monitor_op_initialise(op_extra_data->spkr_rate_monitor_op,op_extra_data->spkr_rate,TRUE,3*MS_PER_SEC);
84200b8e:	05 f0 b8 53 	r3 = Null + 3000;
84200b92:	44 20       	r2 = Null + 1;
84200b94:	63 f0 6e 88 	r1 = M[r4 + 440];
84200b98:	fa ff 24 e4 	call $_rate_monitor_op_initialise;

84200b9c <Lc_aec_reference_opmsg_ep_configure_25>:
                }

                if(op_extra_data->spkr_sw_rateadj_op)
84200b9c:	62 f0 7e 88 	r0 = M[r4 + 504];
84200ba0:	8d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ba2 <Lc_aec_reference_opmsg_ep_configure_26>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200ba2:	03 00       	r1 = Null + Null;
84200ba4:	60 f0 71 88 	Null = M[r4 + 452];
84200ba8:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200bac:	ff fd b0 f0 	call (m) 0x16c96;
84200bb0:	2b e7 
84200bb2:	84 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bb4 <Lc_aec_reference_opmsg_ep_configure_27>:

                }
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     && !op_extra_data->mic_sync_enable)
84200bb4:	c8 24       	Null = rMAC - 3;
84200bb6:	82 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bb8 <Lc_aec_reference_opmsg_ep_configure_28>:
84200bb8:	60 f0 d4 88 	Null = M[r4 + 848];
84200bbc:	7f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bbe <Lc_aec_reference_opmsg_ep_configure_29>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint,value);
84200bbe:	62 f0 7f 88 	r0 = M[r4 + 508];
84200bc2:	3b 00       	r1 = r5 + Null;
84200bc4:	ff fd 1f f0 	call (m) 0x4a3e;
84200bc8:	3b e3 
                if(value==(uint32)FALSE)
84200bca:	38 04       	Null = r5 - Null;
84200bcc:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_31;

84200bce <Lc_aec_reference_opmsg_ep_configure_30>:
                {
                    op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200bce:	60 f0 68 8e 	M[r4 + 416] = Null;
84200bd2:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_32;

84200bd4 <Lc_aec_reference_opmsg_ep_configure_31>:
                }
                else
                {
                    op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200bd4:	61 f0 67 88 	rMAC = M[r4 + 412];
84200bd8:	61 f0 68 8e 	M[r4 + 416] = rMAC;

84200bdc <Lc_aec_reference_opmsg_ep_configure_32>:
                }

                if((op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->mic_rate_monitor_op))
84200bdc:	61 f0 68 88 	rMAC = M[r4 + 416];
84200be0:	88 24       	Null = rMAC - 2;
84200be2:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200be4 <Lc_aec_reference_opmsg_ep_configure_33>:
84200be4:	62 f0 6b 88 	r0 = M[r4 + 428];
84200be8:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200bea <Lc_aec_reference_opmsg_ep_configure_34>:
                {
                    rate_monitor_op_initialise(op_extra_data->mic_rate_monitor_op,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
84200bea:	05 f0 b8 53 	r3 = Null + 3000;
84200bee:	44 20       	r2 = Null + 1;
84200bf0:	63 f0 66 88 	r1 = M[r4 + 408];
84200bf4:	fa ff 28 e1 	call $_rate_monitor_op_initialise;

84200bf8 <Lc_aec_reference_opmsg_ep_configure_35>:
                }

                if(op_extra_data->mic_sw_rateadj_op)
84200bf8:	62 f0 7d 88 	r0 = M[r4 + 500];
84200bfc:	5f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bfe <Lc_aec_reference_opmsg_ep_configure_36>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->mic_sw_rateadj_op,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200bfe:	03 00       	r1 = Null + Null;
84200c00:	60 f0 68 88 	Null = M[r4 + 416];
84200c04:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200c08:	ff fd b0 f0 	call (m) 0x16c96;
84200c0c:	2f e4 
84200c0e:	56 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c10 <Lc_aec_reference_opmsg_ep_configure_37>:
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ADJUSTMENT:
        {
            int svalue = (int)value;
            /*  See BlueCore audio real endpoint function "adjust_audio_rate" for details */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200c10:	00 f2 10 f0 	Null = rMAC - 8388608;
84200c14:	00 24 
84200c16:	29 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_46;

84200c18 <Lc_aec_reference_opmsg_ep_configure_38>:
            {
#ifdef AEC_REFERENCE_SPKR_TTP
                if(op_extra_data->spkr_timed_playback_mode)
84200c18:	60 f0 b2 88 	Null = M[r4 + 712];
84200c1c:	4f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c1e <Lc_aec_reference_opmsg_ep_configure_39>:
                     * rate adjustment is managed by speaker ttp */
                    break;
                }
#endif /* AEC_REFERENCE_SPKR_TTP */
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW)
84200c1e:	61 f0 71 88 	rMAC = M[r4 + 452];
84200c22:	88 24       	Null = rMAC - 2;
84200c24:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_44;

84200c26 <Lc_aec_reference_opmsg_ep_configure_40>:
                {
                    if(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200c26:	71 a8       	rMAC = M[r4 + 68];
84200c28:	49 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c2a <Lc_aec_reference_opmsg_ep_configure_41>:
                    {
                        if((op_extra_data->spkr_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->spkr_rate_monitor_op)))
84200c2a:	62 f0 73 88 	r0 = M[r4 + 460];
84200c2e:	46 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c30 <Lc_aec_reference_opmsg_ep_configure_42>:
84200c30:	ff fd 57 f3 	call 0x6bc28;
84200c34:	38 ef 
84200c36:	10 04       	Null = r0 - Null;
84200c38:	41 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c3a <Lc_aec_reference_opmsg_ep_configure_43>:
                        {
                            op_extra_data->spkr_rate_adjustment = svalue;
84200c3a:	3b 00       	r1 = r5 + Null;
84200c3c:	63 f0 70 8e 	M[r4 + 448] = r1;
                            value = op_extra_data->spkr_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint,value);
84200c40:	62 f0 80 88 	r0 = M[r4 + 512];
84200c44:	ff fd 1f f0 	call (m) 0x4aa0;
84200c48:	3d e2 
                            rate_monitor_op_restart(op_extra_data->spkr_rate_monitor_op);
84200c4a:	62 f0 73 88 	r0 = M[r4 + 460];
84200c4e:	ff fd 57 f3 	call 0x6bc14;
84200c52:	26 ee 
84200c54:	33 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c56 <Lc_aec_reference_opmsg_ep_configure_44>:
                        }
                    }
                }
                else
                {
                    op_extra_data->spkr_rate_adjustment = svalue;
84200c56:	3b 00       	r1 = r5 + Null;
84200c58:	63 f0 70 8e 	M[r4 + 448] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84200c5c:	62 f0 ae 88 	r0 = M[r4 + 696];
84200c60:	2d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c62 <Lc_aec_reference_opmsg_ep_configure_45>:
                    {

                        /* set the target rate value, this will be ignored if speaker path is doing TTP. */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->spkr_ext_rate_adjust_op,
                                                                    op_extra_data->spkr_rate_adjustment);
84200c62:	0f f0 3d ed 	call (m) $_stream_delegate_rate_adjust_set_target_rate;
84200c66:	2a 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c68 <Lc_aec_reference_opmsg_ep_configure_46>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     /* if we are syncing mic to speaker input we shouldn't
                      * receive this message, but ignore it if we received.
                      */
                     && !op_extra_data->mic_sync_enable)
84200c68:	c8 24       	Null = rMAC - 3;
84200c6a:	28 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c6c <Lc_aec_reference_opmsg_ep_configure_47>:
84200c6c:	60 f0 d4 88 	Null = M[r4 + 848];
84200c70:	25 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c72 <Lc_aec_reference_opmsg_ep_configure_48>:
            {
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200c72:	61 f0 68 88 	rMAC = M[r4 + 416];
84200c76:	88 24       	Null = rMAC - 2;
84200c78:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_53;

84200c7a <Lc_aec_reference_opmsg_ep_configure_49>:
                {
                    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
84200c7a:	b1 88       	rMAC = M[r4 + 8];
84200c7c:	1f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c7e <Lc_aec_reference_opmsg_ep_configure_50>:
                    {
                        if((op_extra_data->mic_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->mic_rate_monitor_op)))
84200c7e:	62 f0 6b 88 	r0 = M[r4 + 428];
84200c82:	1c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c84 <Lc_aec_reference_opmsg_ep_configure_51>:
84200c84:	ff fd 57 f3 	call 0x6bc28;
84200c88:	24 ed 
84200c8a:	10 04       	Null = r0 - Null;
84200c8c:	17 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c8e <Lc_aec_reference_opmsg_ep_configure_52>:
                        {
                            op_extra_data->mic_rate_adjustment = svalue;
84200c8e:	3b 00       	r1 = r5 + Null;
84200c90:	63 f0 69 8e 	M[r4 + 420] = r1;
                            value = op_extra_data->mic_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint,value);
84200c94:	62 f0 7f 88 	r0 = M[r4 + 508];
84200c98:	ff fd 1f f0 	call (m) 0x4aa0;
84200c9c:	29 e0 
                            rate_monitor_op_restart(op_extra_data->mic_rate_monitor_op);
84200c9e:	62 f0 6b 88 	r0 = M[r4 + 428];
84200ca2:	ff fd 57 f3 	call 0x6bc14;
84200ca6:	32 eb 
84200ca8:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200caa <Lc_aec_reference_opmsg_ep_configure_53>:
                        }
                    }
                }
                else
                {
                    op_extra_data->mic_rate_adjustment = svalue;
84200caa:	3b 00       	r1 = r5 + Null;
84200cac:	63 f0 69 8e 	M[r4 + 420] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->mic_ext_rate_adjust_op)
84200cb0:	62 f0 ad 88 	r0 = M[r4 + 692];
84200cb4:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cb6 <Lc_aec_reference_opmsg_ep_configure_54>:
                    {

                        /* set the target rate */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->mic_ext_rate_adjust_op,
                                                                    op_extra_data->mic_rate_adjustment);
84200cb6:	0f f0 29 eb 	call (m) $_stream_delegate_rate_adjust_set_target_rate;

84200cba <Lc_aec_reference_opmsg_ep_configure_55>:
            /* break; */
        default:
            return(FALSE);
    }

    return(TRUE);
84200cba:	42 20       	r0 = Null + 1;

84200cbc <Lc_aec_reference_opmsg_ep_configure_56>:
}
84200cbc:	f2 48       	popm <FP, r4, r5, rLink>;
84200cbe:	d8 4c       	rts;

84200cc0 <$_aec_reference_opmsg_ep_clock_id>:

   TODO.  Remove OPMSG_COMMON_GET_CLOCK_ID from table and delete this function
*/

bool aec_reference_opmsg_ep_clock_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200cc0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200cc2:	16 00       	r4 = r0 + Null;
84200cc4:	23 09       	r9 = r2 + Null;
84200cc6:	2f 00       	r5 = r3 + Null;
    unsigned *resp;
    OP_MSG_REQ *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200cc8:	3a f0 00 e8 	r8 = M[r1 + Null];
    INT_OP_ID int_id = op_data->id;
84200ccc:	69 f0 01 88 	r7 = M[r4 + 4];
     * If the Mic and Spkr share the same clock source then all real terminals
     * share the same rate.
     */

    /* Payload is a single word containing the clock ID */
    resp = xpmalloc(sizeof(unsigned));
84200cd0:	c3 20       	r1 = Null + 3;
84200cd2:	02 21       	r0 = Null + 4;
84200cd4:	ff fd 20 f0 	call (m) 0x4e2e;
84200cd8:	3b ea 
84200cda:	10 09       	r6 = r0 + Null;
    if (!resp)
84200cdc:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_3;

84200cde <Lc_aec_reference_opmsg_ep_clock_id_2>:
    {
        return FALSE;
84200cde:	02 00       	r0 = Null + Null;
84200ce0:	20 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_10;

84200ce2 <Lc_aec_reference_opmsg_ep_clock_id_3>:
    }
    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)resp;
84200ce2:	78 f0 00 ee 	M[r5 + Null] = r6;
    *resp_length = 1;
84200ce6:	41 20       	rMAC = Null + 1;
84200ce8:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
      clock ID will be reported as zero before this operation is called.

      If MIC and SPKR real endpoints are not connected then we report the same clock source.
    */

    if (terminal_id & TERMINAL_SINK_MASK)
84200cec:	40 f0 a1 f0 	rMAC = r8 AND 0x800000;
84200cf0:	00 00 
84200cf2:	14 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200cf4 <Lc_aec_reference_opmsg_ep_clock_id_4>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200cf4:	31 99       	rMAC = M[r4 + 48];
         * same clock source as the mic then report the same clock source of
         * the op id. If they differ then report op_id and 1 << 7 as the op id
         * is 7 bits long.
         */
        if (!op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] ||
            !op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200cf6:	8a 88       	r0 = M[rMAC + 8];
84200cf8:	11 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200cfa <Lc_aec_reference_opmsg_ep_clock_id_5>:
84200cfa:	4a a8       	r0 = M[rMAC + 68];
84200cfc:	0f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200cfe <Lc_aec_reference_opmsg_ep_clock_id_6>:
        {
            *resp = int_id;
        }
        else if (override_endpoints_have_same_clock_source(op_extra_data->spkr_endpoint,
                                                           op_extra_data->mic_endpoint))
84200cfe:	13 f0 7f 88 	r1 = M[rMAC + 508];
84200d02:	12 f0 80 88 	r0 = M[rMAC + 512];
84200d06:	ff fd 1e f0 	call (m) 0x4a96;
84200d0a:	31 ec 
84200d0c:	10 04       	Null = r0 - Null;
84200d0e:	06 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200d10 <Lc_aec_reference_opmsg_ep_clock_id_7>:
        {
            *resp = int_id;
        }
        else
        {
            *resp = int_id | (1 << 7);
84200d10:	40 f9 51 c8 	rMAC = r7 OR 0x80;
84200d14:	81 f0 00 ee 	M[r6 + Null] = rMAC;
84200d18:	03 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_9;

84200d1a <Lc_aec_reference_opmsg_ep_clock_id_8>:
    {
        /* The sources that this is relevant to is Outputs and Reference. These
         * all have the same clock source. Report default clock source as the
         * op id.
         */
        *resp = int_id;
84200d1a:	89 f0 00 ee 	M[r6 + Null] = r7;

84200d1e <Lc_aec_reference_opmsg_ep_clock_id_9>:
    }

    return TRUE;
84200d1e:	42 20       	r0 = Null + 1;

84200d20 <Lc_aec_reference_opmsg_ep_clock_id_10>:
}
84200d20:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200d22:	d8 4c       	rts;

84200d24 <$_aec_reference_set_rates>:

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
}

bool aec_reference_set_rates(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d24:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200d26:	17 00       	r5 = r0 + Null;
    AEC_REFERENCE_OP_DATA   *op_extra_data = (AEC_REFERENCE_OP_DATA*)op_data->extra_op_data;
84200d28:	3e 99       	r4 = M[r5 + 48];
    unsigned irate,orate;
    bool rebuild = FALSE;
84200d2a:	02 09       	r8 = Null + Null;

    patch_fn_shared(aec_reference);

    /* Rates needed for creating cbops and for "aec_reference_buffer_details" */
    irate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, INPUT_RATE);
84200d2c:	d9 88       	rMAC = M[r1 + 12];
84200d2e:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;
    orate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, OUTPUT_RATE);
84200d32:	19 89       	rMAC = M[r1 + 16];
84200d34:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;

    L2_DBG_MSG2("AEC REFERENCE: set rates = %d %d", irate, orate);
84200d38:	55 f1 02 f0 	r0 = Null + 357564799;
84200d3c:	7f 41 
84200d3e:	44 08       	r2 = r6 + Null;
84200d40:	4b 08       	r1 = r7 + Null;
84200d42:	ef fd fe ff 	call (m) 0x9c8;
84200d46:	27 e4 

    if(op_extra_data->input_rate!=irate)
84200d48:	61 f0 64 88 	rMAC = M[r4 + 400];
84200d4c:	9f f1 00 c2 	Null = rMAC - r7;
84200d50:	0c 60       	if EQ jump (m) Lc_aec_reference_set_rates_4;

84200d52 <Lc_aec_reference_set_rates_2>:
    {
        op_extra_data->input_rate = irate;
84200d52:	69 f0 64 8e 	M[r4 + 400] = r7;
        if(op_data->state == OP_RUNNING)
84200d56:	39 b0       	rMAC = MBS[r5 + 24];
84200d58:	08 62       	if NE jump (m) Lc_aec_reference_set_rates_4;

84200d5a <Lc_aec_reference_set_rates_3>:
        {
            /* if the operator is running, any change in input
             * rate should trigger a rebuild of speaker graph
             */
            SetSpkrChannelStatus(op_extra_data, 0);
84200d5a:	61 f0 76 88 	rMAC = M[r4 + 472];
84200d5e:	11 fe 0f 00 	rMAC = rMAC AND 0xffffc00f;
84200d62:	61 f0 76 8e 	M[r4 + 472] = rMAC;
            rebuild = TRUE;
84200d66:	0a 71       	r8 = Null + 1;

84200d68 <Lc_aec_reference_set_rates_4>:
        }
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* configure sample rate for MIC ttp */
    ttp_configure_rate(op_extra_data->mic_time_to_play, orate);
84200d68:	62 f0 cf 88 	r0 = M[r4 + 828];
84200d6c:	43 08       	r1 = r6 + Null;
84200d6e:	ff fd ad f0 	call (m) 0x1684c;
84200d72:	3f e6 
#endif

    if(op_extra_data->output_rate!=orate)
84200d74:	61 f0 65 88 	rMAC = M[r4 + 404];
84200d78:	8f f1 00 c2 	Null = rMAC - r6;
84200d7c:	15 60       	if EQ jump (m) Lc_aec_reference_set_rates_8;

84200d7e <Lc_aec_reference_set_rates_5>:
    {
        op_extra_data->output_rate = orate;
84200d7e:	68 f0 65 8e 	M[r4 + 404] = r6;
        if(op_data->state == OP_RUNNING)
84200d82:	39 b0       	rMAC = MBS[r5 + 24];
84200d84:	11 62       	if NE jump (m) Lc_aec_reference_set_rates_8;

84200d86 <Lc_aec_reference_set_rates_6>:
        {
            /* if the operator is running, any change in output
             * rate should trigger a rebuild of microphone graph
             */
            SetMicChannelStatus(op_extra_data, 0);
84200d86:	61 f0 76 88 	rMAC = M[r4 + 472];
84200d8a:	f8 ff 11 f7 	rMAC = rMAC AND 0xfff0fff0;
84200d8e:	f0 1f 
84200d90:	61 f0 76 8e 	M[r4 + 472] = rMAC;

84200d94 <Lc_aec_reference_set_rates_7>:
        /* At least one of input or output rate has changed while the operator
         * is running. This will require fresh rebuild of the affected cbops graphs.
         * No need to do this when operator isn't running since this will be done
         * at start point.
         */
        if(!validate_channels_and_build(op_data))
84200d94:	3a 00       	r0 = r5 + Null;
84200d96:	06 f0 2f e7 	call (m) $_validate_channels_and_build;
        {
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
84200d9a:	11 00       	rMAC = r0 + Null;
84200d9c:	02 00       	r0 = Null + Null;
84200d9e:	08 04       	Null = rMAC - Null;
84200da0:	21 f0 42 ce 	if NE r0 = Null + 1;
84200da4:	05 6e       	jump (m) Lc_aec_reference_set_rates_10;

84200da6 <Lc_aec_reference_set_rates_8>:
            SetMicChannelStatus(op_extra_data, 0);
            rebuild = TRUE;
        }
    }

    if(rebuild)
84200da6:	0f fa 00 c2 	Null = r8 - Null;
84200daa:	f5 63       	if NE jump (m) Lc_aec_reference_set_rates_7;

84200dac <Lc_aec_reference_set_rates_9>:
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
        }
    }

    return TRUE;
84200dac:	42 20       	r0 = Null + 1;

84200dae <Lc_aec_reference_set_rates_10>:
}
84200dae:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200db0:	d8 4c       	rts;

84200db2 <$_aec_reference_opmsg_get_ps_id>:

    return TRUE;
}

bool aec_reference_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200db2:	c8 1c       	pushm <FP(=SP), rLink>;
84200db4:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200db6:	12 99       	r0 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
84200db8:	29 1c       	pushm <r3>;
84200dba:	23 f0 59 88 	r1 = M[r0 + 356];
84200dbe:	25 00       	r3 = r2 + Null;
84200dc0:	02 f0 78 45 	r0 = r0 + 376;
84200dc4:	0c 00       	r2 = rMAC + Null;
84200dc6:	ef fd fc ff 	call (m) 0x6d2;
84200dca:	2d e8 
84200dcc:	7f 4c       	SP = SP + -4;

84200dce <Lc_aec_reference_opmsg_get_ps_id_2>:
}
84200dce:	c8 48       	popm <FP, rLink>;
84200dd0:	d8 4c       	rts;

84200dd2 <$_aec_reference_opmsg_mute_mic_output>:

    return TRUE;
}

bool aec_reference_opmsg_mute_mic_output(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200dd2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200dd4:	16 99       	r4 = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned mute_enable;

    patch_fn_shared(aec_reference);

    if(NULL == op_extra_data->mic_mute_op)
84200dd6:	61 f0 9d 88 	rMAC = M[r4 + 628];
84200dda:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_mute_mic_output_3;

84200ddc <Lc_aec_reference_opmsg_mute_mic_output_2>:
    {
        /* No mute operator found */
        return FALSE;
84200ddc:	02 00       	r0 = Null + Null;
84200dde:	14 6e       	jump (m) Lc_aec_reference_opmsg_mute_mic_output_4;

84200de0 <Lc_aec_reference_opmsg_mute_mic_output_3>:
    }

    /* read the enable field */
    mute_enable  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_MUTE_MIC_OUTPUT, ENABLE);
84200de0:	d9 88       	rMAC = M[r1 + 12];
84200de2:	8f c6       	r5 = rMAC AND 0xffff;
    L2_DBG_MSG1("ACE REFERENCE muting mic, mute=%d", mute_enable);
84200de4:	55 f1 02 f0 	r0 = Null + 357564765;
84200de8:	5d 41 
84200dea:	3b 00       	r1 = r5 + Null;
84200dec:	ef fd fd ff 	call (m) 0x9b4;
84200df0:	29 ee 

    /* configure mute operator */
    cbops_mute_enable(op_extra_data->mic_mute_op, mute_enable != 0);
84200df2:	03 00       	r1 = Null + Null;
84200df4:	38 04       	Null = r5 - Null;
84200df6:	21 f0 43 ce 	if NE r1 = Null + 1;
84200dfa:	62 f0 9d 88 	r0 = M[r4 + 628];
84200dfe:	ff ff 16 f0 	call (m) 0x4003b9a;
84200e02:	3d ec 

    return TRUE;
84200e04:	42 20       	r0 = Null + 1;

84200e06 <Lc_aec_reference_opmsg_mute_mic_output_4>:
}
84200e06:	f2 48       	popm <FP, r4, r5, rLink>;
84200e08:	d8 4c       	rts;

84200e0a <$_aec_reference_opmsg_set_task_period>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200e0a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200e0c:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200e0e:	17 99       	r5 = M[r0 + 48];
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
84200e10:	0e f0 35 ed 	call (m) $_opmgr_op_is_running;
84200e14:	10 04       	Null = r0 - Null;
84200e16:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_task_period_3;

84200e18 <Lc_aec_reference_opmsg_set_task_period_2>:
    {
        return FALSE;
84200e18:	02 00       	r0 = Null + Null;
84200e1a:	07 6e       	jump (m) Lc_aec_reference_opmsg_set_task_period_4;

84200e1c <Lc_aec_reference_opmsg_set_task_period_3>:
    }

    /* get the task period */
    unsigned task_period = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, TASK_PERIOD);
84200e1c:	f1 88       	rMAC = M[r4 + 12];
84200e1e:	8b c6       	r1 = rMAC AND 0xffff;

    /* get decimation factor */
    unsigned decim_factor = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, DECIM_FACTOR);
84200e20:	31 89       	rMAC = M[r4 + 16];
84200e22:	8c c6       	r2 = rMAC AND 0xffff;

    return aec_reference_set_task_period(op_extra_data, task_period, decim_factor);
84200e24:	3a 00       	r0 = r5 + Null;
84200e26:	03 4e       	call (m) $_aec_reference_set_task_period;

84200e28 <Lc_aec_reference_opmsg_set_task_period_4>:
}
84200e28:	f2 48       	popm <FP, r4, r5, rLink>;
84200e2a:	d8 4c       	rts;

84200e2c <$_aec_reference_set_task_period>:
 * \param decim_factor decimation factor for sidetone mixing task
 *
 * \return whether the task period update successfully
 */
bool aec_reference_set_task_period(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned task_period, unsigned decim_factor)
{
84200e2c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200e2e:	17 00       	r5 = r0 + Null;
84200e30:	1e 00       	r4 = r1 + Null;
84200e32:	20 09       	r6 = r2 + Null;
    /* check the limits */
    if(task_period > AEC_REFERENCE_MAX_TASK_PERIOD ||
       task_period < AEC_REFERENCE_MIN_TASK_PERIOD)
84200e34:	60 f1 88 27 	Null = r4 - 5000;
84200e38:	08 f0 8d e0 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84200e3c <Lc_aec_reference_set_task_period_2>:
84200e3c:	60 f0 e8 27 	Null = r4 - 1000;
84200e40:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_task_period_4;

84200e44 <Lc_aec_reference_set_task_period_3>:
    {
        return FALSE;
84200e44:	02 00       	r0 = Null + Null;
84200e46:	5d 6e       	jump (m) Lc_aec_reference_set_task_period_12;

84200e48 <Lc_aec_reference_set_task_period_4>:
    }

    /* see if task period is an integer factor of a second */
    if(0 != (SECOND % task_period))
84200e48:	00 f0 a2 f7 	r0 = Null + 1000000;
84200e4c:	40 42 
84200e4e:	ff fd b1 f0 	call (m) 0x171d6;
84200e52:	29 ec 
84200e54:	10 04       	Null = r0 - Null;
84200e56:	f7 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84200e58 <Lc_aec_reference_set_task_period_5>:
    }

    /* Also we don't expect AEC_REFERENCE task period becoms
     * larger than system kick period
     */
    if(task_period > (unsigned)stream_if_get_system_kick_period())
84200e58:	ff fd 2f f0 	call (m) 0x6dc0;
84200e5c:	29 eb 
84200e5e:	b0 04       	Null = r4 - r0;
84200e60:	f8 ff e5 ef 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84200e64 <Lc_aec_reference_set_task_period_6>:

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* if a decimation factor supplied it should be a factor of
     * task period
     */
    if(decim_factor > 1)
84200e64:	80 f0 01 24 	Null = r6 - 1;
84200e68:	09 f0 95 e0 	if LS jump (m) Lc_aec_reference_set_task_period_8;

84200e6c <Lc_aec_reference_set_task_period_7>:
    {
        if((task_period % decim_factor) != 0)
84200e6c:	32 00       	r0 = r4 + Null;
84200e6e:	43 08       	r1 = r6 + Null;
84200e70:	ff fd b1 f0 	call (m) 0x171d6;
84200e74:	27 eb 
84200e76:	10 04       	Null = r0 - Null;
84200e78:	e6 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84200e7a <Lc_20>:
84200e7a:	02 6e       	jump (m) Lc_aec_reference_set_task_period_9;

84200e7c <Lc_aec_reference_set_task_period_8>:
            return FALSE;
        }
    }
    else
    {
        decim_factor = 1;
84200e7c:	08 71       	r6 = Null + 1;

84200e7e <Lc_aec_reference_set_task_period_9>:
    }
    op_extra_data->task_decim_factor = decim_factor;
84200e7e:	78 f0 97 8e 	M[r5 + 604] = r6;
    op_extra_data->task_decim_counter = 0;
84200e82:	70 f0 98 8e 	M[r5 + 608] = Null;
    op_extra_data->kick_period = task_period / decim_factor;
84200e86:	32 00       	r0 = r4 + Null;
84200e88:	43 08       	r1 = r6 + Null;
84200e8a:	ff fd b1 f0 	call (m) 0x171b8;
84200e8e:	2f e9 
84200e90:	72 f0 94 8e 	M[r5 + 592] = r0;
    op_extra_data->kick_period_frac = frac_div(op_extra_data->kick_period, SECOND);
84200e94:	00 f0 a1 f7 	rMAC = Null + 1000000;
84200e98:	40 42 
84200e9a:	7f f2 1f d9 	rMACB = r0 ASHIFT -1 (56bit);
84200e9e:	00 f1 9f cd 	Div = rMACB / rMAC;
84200ea2:	c2 4c       	r0 = DivResult;
84200ea4:	72 f0 96 8e 	M[r5 + 600] = r0;
    op_extra_data->kick_period = task_period;
    decim_factor = 1;
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /* All are fine, set the task period*/
    op_extra_data->task_period = task_period;
84200ea8:	76 f0 63 8e 	M[r5 + 396] = r4;
    op_extra_data->task_frequency = (unsigned)SECOND/task_period;
84200eac:	33 00       	r1 = r4 + Null;
84200eae:	0a 00       	r0 = rMAC + Null;
84200eb0:	ff fd b1 f0 	call (m) 0x171b8;
84200eb4:	29 e8 
84200eb6:	72 f0 92 8e 	M[r5 + 584] = r0;
    op_extra_data->task_period_frac = frac_div(task_period, SECOND);
84200eba:	00 f0 a1 f7 	rMAC = Null + 1000000;
84200ebe:	40 42 
84200ec0:	7f f6 1f d9 	rMACB = r4 ASHIFT -1 (56bit);
84200ec4:	00 f1 9f cd 	Div = rMACB / rMAC;
84200ec8:	c2 4c       	r0 = DivResult;
84200eca:	72 f0 93 8e 	M[r5 + 588] = r0;
     * stage does an upsample by a factor of 2.1.
     * 48000.0 (fs in : 21/10) --> 100800.0 (fs internal : 7/16) --> 44100.0 (fs out)
     *
     * (2*task period) @100800
     */
    op_extra_data->resampler_temp_buffer_size = frac_mult(100800, 2*op_extra_data->task_period_frac) + 4;
84200ece:	c3 f0 c0 51 	r1 = Null + 100800;
84200ed2:	12 54       	r0 = r0 LSHIFT 1;
84200ed4:	2f f3 42 c9 	r0 = r1 * r0 (frac);
84200ed8:	11 21       	rMAC = r0 + 4;
84200eda:	71 f0 91 8e 	M[r5 + 580] = rMAC;
    op_extra_data->resampler_temp_buffer_size = MAX(op_extra_data->resampler_temp_buffer_size,
                                                        AEC_REF_RESAMPLER_TEMP_MIN_BUF_SIZE);
84200ede:	10 f0 cc 24 	Null = rMAC - 204;
84200ee2:	02 f0 8d e0 	if C jump (m) Lc_aec_reference_set_task_period_11;

84200ee6 <Lc_aec_reference_set_task_period_10>:
84200ee6:	01 f0 cc 40 	rMAC = Null + 204;
84200eea:	71 f0 91 8e 	M[r5 + 580] = rMAC;

84200eee <Lc_aec_reference_set_task_period_11>:

    L2_DBG_MSG2("AEC REFERENCE: task period set @%dus, decimation factor=%d", task_period, decim_factor);
84200eee:	55 f1 02 f0 	r0 = Null + 357564589;
84200ef2:	ad 40 
84200ef4:	44 08       	r2 = r6 + Null;
84200ef6:	33 00       	r1 = r4 + Null;
84200ef8:	ef fd fd ff 	call (m) 0x9c8;
84200efc:	31 e6 

    return TRUE;
84200efe:	42 20       	r0 = Null + 1;

84200f00 <Lc_aec_reference_set_task_period_12>:
}
84200f00:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200f02:	d8 4c       	rts;

84200f04 <$_aec_reference_opmsg_enable_mic_sync>:
 *             backend input and output are from same clock
 * Note: the msaage shall not be sent when any MIC/OUTPUT/REF
 *       terminal is connected.
 */
bool aec_reference_opmsg_enable_mic_sync(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f04:	c8 1c       	pushm <FP(=SP), rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f06:	11 99       	rMAC = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    patch_fn_shared(aec_reference);

    if((NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]) ||
       (NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]) ||
       (NULL != op_extra_data->input_stream[AEC_REF_OUTPUT_TERMINAL1]))
84200f08:	8a 88       	r0 = M[rMAC + 8];
84200f0a:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

84200f0c <Lc_aec_reference_opmsg_enable_mic_sync_2>:
84200f0c:	0a a8       	r0 = M[rMAC + 64];
84200f0e:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

84200f10 <Lc_aec_reference_opmsg_enable_mic_sync_3>:
84200f10:	ca 88       	r0 = M[rMAC + 12];
84200f12:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_enable_mic_sync_5;

84200f14 <Lc_aec_reference_opmsg_enable_mic_sync_4>:
    {
        /* This message can be handled only if MIC and REF are disconnected */
        return FALSE;
84200f14:	02 00       	r0 = Null + Null;
84200f16:	0f 6e       	jump (m) Lc_aec_reference_opmsg_enable_mic_sync_6;

84200f18 <Lc_aec_reference_opmsg_enable_mic_sync_5>:
    }

    /* read the enable field */
    op_extra_data->mic_sync_enable = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_SAME_INPUT_OUTPUT_CLOCK_SOURCE, SAME_CLK_SRC)) != 0;
84200f18:	da 88       	r0 = M[r1 + 12];
84200f1a:	03 00       	r1 = Null + Null;
84200f1c:	92 c6       	r0 = r0 AND 0xffff;
84200f1e:	21 f0 43 ce 	if NE r1 = Null + 1;
84200f22:	13 f0 d4 8e 	M[rMAC + 848] = r1;
    L2_DBG_MSG1("ACE REFERENCE input-output use same clock: ", op_extra_data->mic_sync_enable);
84200f26:	55 f1 02 f0 	r0 = Null + 357564545;
84200f2a:	81 40 
84200f2c:	ef fd fd ff 	call (m) 0x9b4;
84200f30:	29 e4 

    return TRUE;
84200f32:	42 20       	r0 = Null + 1;

84200f34 <Lc_aec_reference_opmsg_enable_mic_sync_6>:
}
84200f34:	c8 48       	popm <FP, rLink>;
84200f36:	d8 4c       	rts;

84200f38 <$_aec_reference_opmsg_set_buffer_size>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data,
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f38:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f3a:	28 f0 0c 88 	r6 = M[r0 + 48];
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    /* get the required buffer size */
    unsigned buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE, BUFFER_SIZE);
84200f3e:	d9 88       	rMAC = M[r1 + 12];
84200f40:	8e c6       	r4 = rMAC AND 0xffff;
    /* get the sink terminals that need configuration */
    unsigned sinks = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                     SINKS);
84200f42:	19 89       	rMAC = M[r1 + 16];
    /* get the source terminals that need configuration */
    unsigned sources = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                       SOURCES);
84200f44:	0f c0       	r5 = rMAC AND 0x1;
84200f46:	59 89       	rMAC = M[r1 + 20];

    /* Output buffer size is allowd to change if none of outputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sources != 0)
84200f48:	49 c1       	rMAC = rMAC AND 0x8;
84200f4a:	16 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_10;

84200f4c <Lc_aec_reference_opmsg_set_buffer_size_2>:
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84200f4c:	02 00       	r0 = Null + Null;
84200f4e:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_4;

84200f50 <Lc_aec_reference_opmsg_set_buffer_size_3>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
84200f50:	10 25       	Null = r0 - 4;
84200f52:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_5;

84200f56 <Lc_aec_reference_opmsg_set_buffer_size_4>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84200f56:	d3 20       	r1 = r0 + 3;
84200f58:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_6;

84200f5a <Lc_aec_reference_opmsg_set_buffer_size_5>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84200f5a:	53 22       	r1 = r0 + 9;

84200f5c <Lc_aec_reference_opmsg_set_buffer_size_6>:
        {
            if(NULL != op_extra_data->output_stream[OutputTerminalByIndex(idx)])
84200f5c:	84 f0 40 20 	r2 = r6 + 64;
84200f60:	5b 54       	r1 = r1 LSHIFT 2;
84200f62:	e3 e8       	r1 = M[r2 + r1];
84200f64:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_8;

84200f66 <Lc_aec_reference_opmsg_set_buffer_size_7>:
            {
                return FALSE;
84200f66:	02 00       	r0 = Null + Null;
84200f68:	2f 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_22;

84200f6a <Lc_aec_reference_opmsg_set_buffer_size_8>:
    if(sources != 0)
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84200f6a:	52 20       	r0 = r0 + 1;
84200f6c:	10 26       	Null = r0 - 8;
84200f6e:	f1 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_3;

84200f70 <Lc_aec_reference_opmsg_set_buffer_size_9>:
            {
                return FALSE;
            }
        }
        /* Also REFERENCE must also be disconnected */
        if(NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL])
84200f70:	82 f0 10 88 	r0 = M[r6 + 64];
84200f74:	f9 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84200f76 <Lc_aec_reference_opmsg_set_buffer_size_10>:

    /* Input buffer size is allowd to change if none of inputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sinks != 0)
84200f76:	38 04       	Null = r5 - Null;
84200f78:	10 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_17;

84200f7a <Lc_aec_reference_opmsg_set_buffer_size_11>:
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200f7a:	02 00       	r0 = Null + Null;
84200f7c:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_13;

84200f7e <Lc_aec_reference_opmsg_set_buffer_size_12>:
        {
            if(NULL != op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)])
84200f7e:	90 24       	Null = r0 - 2;
84200f80:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_14;

84200f84 <Lc_aec_reference_opmsg_set_buffer_size_13>:
84200f84:	13 00       	r1 = r0 + Null;
84200f86:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_15;

84200f88 <Lc_aec_reference_opmsg_set_buffer_size_14>:
84200f88:	13 21       	r1 = r0 + 4;

84200f8a <Lc_aec_reference_opmsg_set_buffer_size_15>:
84200f8a:	5b 54       	r1 = r1 LSHIFT 2;
84200f8c:	83 f0 03 e8 	r1 = M[r6 + r1];
84200f90:	eb 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84200f92 <Lc_aec_reference_opmsg_set_buffer_size_16>:
    if(sinks != 0)
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200f92:	52 20       	r0 = r0 + 1;
84200f94:	10 26       	Null = r0 - 8;
84200f96:	f4 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_12;

84200f98 <Lc_aec_reference_opmsg_set_buffer_size_17>:
                return FALSE;
            }
        }
    }

    if(sources != 0)
84200f98:	08 04       	Null = rMAC - Null;
84200f9a:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_19;

84200f9c <Lc_aec_reference_opmsg_set_buffer_size_18>:
    {
        /* set the output buffer size */
        op_extra_data->output_buffer_size = buffer_size;
84200f9c:	86 f0 d5 8e 	M[r6 + 852] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum output buffer size set to %d words ", buffer_size);
84200fa0:	55 f1 02 f0 	r0 = Null + 357564648;
84200fa4:	e8 40 
84200fa6:	33 00       	r1 = r4 + Null;
84200fa8:	ef fd fd ff 	call (m) 0x9b4;
84200fac:	2d e0 

84200fae <Lc_aec_reference_opmsg_set_buffer_size_19>:
    }

    if(sinks != 0)
84200fae:	38 04       	Null = r5 - Null;
84200fb0:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_21;

84200fb2 <Lc_aec_reference_opmsg_set_buffer_size_20>:
    {
        op_extra_data->input_buffer_size = buffer_size;
84200fb2:	86 f0 d6 8e 	M[r6 + 856] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum input buffer size set to %d words ", buffer_size);
84200fb6:	55 f1 02 f0 	r0 = Null + 357564707;
84200fba:	23 41 
84200fbc:	33 00       	r1 = r4 + Null;
84200fbe:	ef fd fc ff 	call (m) 0x9b4;
84200fc2:	37 ef 

84200fc4 <Lc_aec_reference_opmsg_set_buffer_size_21>:
    }

    return TRUE;
84200fc4:	42 20       	r0 = Null + 1;

84200fc6 <Lc_aec_reference_opmsg_set_buffer_size_22>:
}
84200fc6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200fc8:	d8 4c       	rts;

84200fca <$_aec_reference_update_sidetone_status>:
    if((op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONE_DISABLE) == 0)
    {
        /* a sidetone path will be formed whenever
         * we have both speaker and mic paths
         */
        op_extra_data->using_sidetone = SIDETONE_ENABLE_FLAG;
84200fca:	21 f0 33 88 	rMAC = M[r0 + 204];
84200fce:	03 00       	r1 = Null + Null;
84200fd0:	49 c1       	rMAC = rMAC AND 0x8;
84200fd2:	a0 f0 43 ce 	if EQ r1 = Null + 2;
84200fd6:	23 f0 7a 8e 	M[r0 + 488] = r1;
        /* User doesn't want sidetone at all */
        op_extra_data->using_sidetone = 0;
    }

    /* see if we need sidetone */
    if((op_extra_data->num_mic_channels > 0) && (op_extra_data->num_spkr_channels > 0))
84200fda:	20 f0 78 88 	Null = M[r0 + 480];
84200fde:	0a 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84200fe0 <Lc_aec_reference_update_sidetone_status_2>:
84200fe0:	20 f0 77 88 	Null = M[r0 + 476];
84200fe4:	07 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84200fe6 <Lc_aec_reference_update_sidetone_status_3>:
    {
        op_extra_data->using_sidetone |= SIDETONE_MIC_SPKR_FLAG;
84200fe6:	21 f0 7a 88 	rMAC = M[r0 + 488];
84200fea:	09 c8       	rMAC = rMAC OR 0x1;
84200fec:	21 f0 7a 8e 	M[r0 + 488] = rMAC;
84200ff0:	06 6e       	jump (m) Lc_aec_reference_update_sidetone_status_5;

84200ff2 <Lc_aec_reference_update_sidetone_status_4>:
    }
    else
    {
        op_extra_data->using_sidetone &= SIDETONE_ENABLE_FLAG;
84200ff2:	21 f0 7a 88 	rMAC = M[r0 + 488];
84200ff6:	49 c0       	rMAC = rMAC AND 0x2;
84200ff8:	21 f0 7a 8e 	M[r0 + 488] = rMAC;

84200ffc <Lc_aec_reference_update_sidetone_status_5>:
84200ffc:	d8 4c       	rts;

84200ffe <$_aec_reference_spkr_check_external_rate_adjust_op>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 */
void aec_reference_spkr_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84200ffe:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
84201000:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->spkr_endpoint, &val) && val != 0)
84201002:	c3 10       	r1 = FP + 12;
84201004:	62 f0 80 88 	r0 = M[r4 + 512];
84201008:	0d f0 29 ee 	call (m) $_get_override_ep_rate_adjust_op;
8420100c:	10 04       	Null = r0 - Null;
8420100e:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

84201010 <Lc_aec_reference_spkr_check_external_rate_adjust_op_2>:
84201010:	1a d8       	r0 = M[FP + 12];
84201012:	11 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

84201014 <Lc_aec_reference_spkr_check_external_rate_adjust_op_3>:
    {
        /* Speaker graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->spkr_ext_rate_adjust_op = val;
84201014:	62 f0 ae 8e 	M[r4 + 696] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if spkr is able to use HW warping */
        op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_SW;
84201018:	41 20       	rMAC = Null + 1;
8420101a:	61 f0 6f 8e 	M[r4 + 444] = rMAC;

        /* Speaker path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
8420101e:	03 00       	r1 = Null + Null;
84201020:	0e f0 2b e1 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Speaker path will use standalone rate adjust: opid=0x%x", val);
84201024:	1b d8       	r1 = M[FP + 12];
84201026:	55 f1 02 f0 	r0 = Null + 357564832;
8420102a:	a0 41 
8420102c:	ef fd fc ff 	call (m) 0x9b4;
84201030:	29 ec 
84201032:	03 6e       	jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_5;

84201034 <Lc_aec_reference_spkr_check_external_rate_adjust_op_4>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->spkr_ext_rate_adjust_op = 0;
84201034:	60 f0 ae 8e 	M[r4 + 696] = Null;

84201038 <Lc_aec_reference_spkr_check_external_rate_adjust_op_5>:

    return;
}
84201038:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
8420103a:	d8 4c       	rts;

8420103c <$_aec_reference_mic_check_external_rate_adjust_op>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 * \return TRUE if there is a standalone rate adjust operator linked to the microphne path
 */
void aec_reference_mic_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420103c:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
8420103e:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->mic_endpoint, &val) && val != 0)
84201040:	c3 10       	r1 = FP + 12;
84201042:	62 f0 7f 88 	r0 = M[r4 + 508];
84201046:	0d f0 2b ec 	call (m) $_get_override_ep_rate_adjust_op;
8420104a:	10 04       	Null = r0 - Null;
8420104c:	1e 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

8420104e <Lc_aec_reference_mic_check_external_rate_adjust_op_2>:
8420104e:	1a d8       	r0 = M[FP + 12];
84201050:	1c 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

84201052 <Lc_aec_reference_mic_check_external_rate_adjust_op_3>:
    {
        /* If we have been told to synchronise mic to speaker input then
         * we shouldn't have been told to use standalone rate adjust.
         */
        PL_ASSERT(!op_extra_data->mic_sync_enable);
84201052:	60 f0 d4 88 	Null = M[r4 + 848];
84201056:	09 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_5;

84201058 <Lc_aec_reference_mic_check_external_rate_adjust_op_4>:
84201058:	03 f0 d5 5b 	r1 = Null + 4053;
8420105c:	02 f0 13 60 	r0 = Null + 4115;
84201060:	ff fd 97 f0 	call (m) 0x13f12;
84201064:	33 e5 
84201066:	13 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

84201068 <Lc_aec_reference_mic_check_external_rate_adjust_op_5>:

        /* Microphone graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->mic_ext_rate_adjust_op = val;
84201068:	62 f0 ad 8e 	M[r4 + 692] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if mic is able to use HW warping */
        op_extra_data->mic_rate_ability = RATEMATCHING_SUPPORT_SW;
8420106c:	41 20       	rMAC = Null + 1;
8420106e:	61 f0 67 8e 	M[r4 + 412] = rMAC;

        /* Microphone path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, FALSE);
84201072:	03 00       	r1 = Null + Null;
84201074:	0d f0 37 ee 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Microphone path will use standalone rate adjust: opid=0x%x", val);
84201078:	1b d8       	r1 = M[FP + 12];
8420107a:	55 f1 02 f0 	r0 = Null + 357564903;
8420107e:	e7 41 
84201080:	ef fd fc ff 	call (m) 0x9b4;
84201084:	35 e9 
84201086:	03 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

84201088 <Lc_aec_reference_mic_check_external_rate_adjust_op_6>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->mic_ext_rate_adjust_op = 0;
84201088:	60 f0 ad 8e 	M[r4 + 692] = Null;

8420108c <Lc_aec_reference_mic_check_external_rate_adjust_op_7>:

    return;
}
8420108c:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
8420108e:	d8 4c       	rts;

84201090 <$_aec_reference_opmsg_set_ttp_latency>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data,
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201090:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201092:	16 99       	r4 = M[r0 + 48];
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
84201094:	11 b0       	rMAC = MBS[r0 + 24];
84201096:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_latency_3;

84201098 <Lc_aec_reference_opmsg_set_ttp_latency_2>:

    {
        return FALSE;
84201098:	02 00       	r0 = Null + Null;
8420109a:	15 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_latency_4;

8420109c <Lc_aec_reference_opmsg_set_ttp_latency_3>:
    }

    /* get the latency from payload */
    op_extra_data->mic_target_latency = ttp_get_msg_latency(message_data);
8420109c:	1a 00       	r0 = r1 + Null;
8420109e:	ff fd ab f0 	call (m) 0x16706;
842010a2:	29 e3 
842010a4:	13 00       	r1 = r0 + Null;
842010a6:	63 f0 ce 8e 	M[r4 + 824] = r1;

    /* configure latency */
    ttp_configure_latency(op_extra_data->mic_time_to_play, op_extra_data->mic_target_latency);
842010aa:	62 f0 cf 88 	r0 = M[r4 + 828];
842010ae:	ff fd ab f0 	call (m) 0x167da;
842010b2:	2d e9 

    /* receiving this message (with latenct != 0) will enable metadata generation */
    op_extra_data->mic_metadata_enable = op_extra_data->mic_target_latency != 0;
842010b4:	01 00       	rMAC = Null + Null;
842010b6:	60 f0 ce 88 	Null = M[r4 + 824];
842010ba:	21 f0 41 ce 	if NE rMAC = Null + 1;
842010be:	61 f0 cd 8e 	M[r4 + 820] = rMAC;

    return TRUE;
842010c2:	42 20       	r0 = Null + 1;

842010c4 <Lc_aec_reference_opmsg_set_ttp_latency_4>:
}
842010c4:	f1 48       	popm <FP, r4, rLink>;
842010c6:	d8 4c       	rts;

842010c8 <$_aec_reference_opmsg_set_ttp_params>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010c8:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010ca:	16 99       	r4 = M[r0 + 48];

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    ttp_params params;

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
842010cc:	11 b0       	rMAC = MBS[r0 + 24];
842010ce:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_params_3;

842010d0 <Lc_aec_reference_opmsg_set_ttp_params_2>:
    {
        return FALSE;
842010d0:	02 00       	r0 = Null + Null;
842010d2:	0c 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_params_4;

842010d4 <Lc_aec_reference_opmsg_set_ttp_params_3>:
    }

    /* configure ttp params */
    ttp_get_msg_params(&params, message_data);
842010d4:	c2 10       	r0 = FP + 12;
842010d6:	ff fd ab f0 	call (m) 0x16786;
842010da:	31 e5 
    ttp_configure_params(op_extra_data->mic_time_to_play, &params);
842010dc:	c3 10       	r1 = FP + 12;
842010de:	62 f0 cf 88 	r0 = M[r4 + 828];
842010e2:	ff fd ab f0 	call (m) 0x16822;
842010e6:	21 ea 

    return TRUE;
842010e8:	42 20       	r0 = Null + 1;

842010ea <Lc_aec_reference_opmsg_set_ttp_params_4>:
}
842010ea:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
842010ec:	d8 4c       	rts;

842010ee <$_aec_reference_opmsg_set_latency_limits>:
 * aec_reference_opmsg_set_latency_limits
 * \brief message handler to set ttp latency limits for mic output channels
 */
bool aec_reference_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data,
                                        unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010ee:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842010f0:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010f2:	16 99       	r4 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    /* get the limits from the message payload and configure the time to play limits */
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
842010f4:	04 11       	r2 = FP + 16;
842010f6:	c3 10       	r1 = FP + 12;
842010f8:	0a 00       	r0 = rMAC + Null;
842010fa:	ff fd ab f0 	call (m) 0x1673c;
842010fe:	23 e2 
    ttp_configure_latency_limits(op_extra_data->mic_time_to_play, min_latency, max_latency);
84201100:	24 d8       	r2 = M[FP + 16];
84201102:	1b d8       	r1 = M[FP + 12];
84201104:	62 f0 cf 88 	r0 = M[r4 + 828];
84201108:	ff fd ab f0 	call (m) 0x167fa;
8420110c:	33 e7 

    return TRUE;
8420110e:	42 20       	r0 = Null + 1;

84201110 <Lc_aec_reference_opmsg_set_latency_limits_2>:
}
84201110:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84201112:	d8 4c       	rts;

84201114 <$_aec_reference_mic_generate_metadata_with_ttp>:
 * \brief generates metadata for microphone output channels
 * \param op_extra_data Pointer to AEC_REFERENCE operator specific data
 * \param samples number of samples in the to-be-copied chunk
 */
void aec_reference_mic_generate_metadata_with_ttp(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned samples)
{
84201114:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84201116:	10 09       	r6 = r0 + Null;
84201118:	8b f0 ca 88 	r9 = M[r6 + 808];
8420111c:	1f 00       	r5 = r1 + Null;
    metadata_tag *mtag;
    unsigned b4idx, afteridx;
    tCbuffer *met_buf = op_extra_data->mic_metadata_buffer;

    /* no update needed if no new samples arrived */
    if(samples == 0)
8420111e:	6b 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

84201120 <Lc_aec_reference_mic_generate_metadata_with_ttp_2>:
    {
        return;
    }

    /* if previous tag was incomplete, we need first to complete the tag */
    if(op_extra_data->mic_metadata_tag_left_words > 0)
84201120:	81 f0 cb 88 	rMAC = M[r6 + 812];
84201124:	15 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_6;

84201126 <Lc_aec_reference_mic_generate_metadata_with_ttp_3>:
    {
        /* last written tag was incomplete, we keep adding
         * Null tag until full length of incomplete tag is
         * covered.
         */
        unsigned null_tag_len = op_extra_data->mic_metadata_tag_left_words;
84201126:	0e 00       	r4 = rMAC + Null;
        if(null_tag_len > samples)
84201128:	c8 05       	Null = rMAC - r5;
8420112a:	09 f0 87 e0 	if LS jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_5;

8420112e <Lc_aec_reference_mic_generate_metadata_with_ttp_4>:
        {
            null_tag_len = samples;
8420112e:	3e 00       	r4 = r5 + Null;

84201130 <Lc_aec_reference_mic_generate_metadata_with_ttp_5>:
        }

        /* append Null tag, with length = null_tag_len */
        b4idx = 0;
        afteridx = null_tag_len*OCTETS_PER_SAMPLE;
84201130:	75 54       	r3 = r4 LSHIFT 2;
        buff_metadata_append(met_buf, NULL, b4idx, afteridx);
84201132:	04 00       	r2 = Null + Null;
84201134:	03 00       	r1 = Null + Null;
84201136:	5a 08       	r0 = r9 + Null;
84201138:	ff fd 84 f0 	call (m) 0x11adc;
8420113c:	25 ed 

        /* update amount left */
        op_extra_data->mic_metadata_tag_left_words -= null_tag_len;
8420113e:	81 f0 cb 88 	rMAC = M[r6 + 812];
84201142:	89 05       	rMAC = rMAC - r4;
84201144:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
        samples -= null_tag_len;
84201148:	bf 05       	r5 = r5 - r4;
        if(samples == 0)
8420114a:	38 04       	Null = r5 - Null;
8420114c:	54 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

8420114e <Lc_aec_reference_mic_generate_metadata_with_ttp_6>:
        }
    }

    /* create a new tag to append */
    b4idx = 0;
    afteridx = samples*OCTETS_PER_SAMPLE;
8420114e:	7a 54       	r0 = r5 LSHIFT 2;
84201150:	42 de       	M[FP + 32] = r0;
    mtag = buff_metadata_new_tag();
84201152:	ff fd 83 f0 	call (m) 0x11862;
84201156:	31 e8 
84201158:	16 00       	r4 = r0 + Null;
    if (mtag != NULL)
8420115a:	46 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_11;

8420115c <Lc_aec_reference_mic_generate_metadata_with_ttp_7>:
    {
        /* calculating time of arrival for first sample of the tag,
         * we do that by looking how many samples are in the mic buffer,
         * this could be short by up to 1 sample as our reading isn't aligned.
         */
        TIME current_time = hal_get_time();
8420115c:	ff fd 83 f1 	call (m) 0x317e8;
84201160:	2d e4 
84201162:	12 09       	r8 = r0 + Null;

        /* amount of data in the mic buffer */
        unsigned amount_in_buffer =
            cbuffer_calc_amount_data_in_words(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84201164:	82 f0 02 88 	r0 = M[r6 + 8];
84201168:	ff fd 58 f1 	call (m) 0x2c208;
8420116c:	21 e5 

        /* convert samples to time,
         * Note: some inaccuracies because of rate adjustment, but jitter will be filtered by ttp filter */
        INTERVAL time_passed = (INTERVAL) (((uint48)(amount_in_buffer)*SECOND)/op_extra_data->mic_rate) +
            (INTERVAL) (((uint48)(samples)*SECOND)/op_extra_data->output_rate);
8420116e:	00 f0 42 ff 	rMAC = r0 * 0.00023283064365386962890625 (UU);
84201172:	40 f2 11 cc 
84201176:	84 f0 66 88 	r2 = M[r6 + 408];
8420117a:	05 00       	r3 = Null + Null;
8420117c:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
8420117e:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
84201182:	ca 57       	r0 = rMAC LSHIFT 32;
84201184:	ff fd af f0 	call (m) 0x17130;
84201188:	2d ed 
8420118a:	11 09       	r7 = r0 + Null;
8420118c:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
84201190:	40 f7 11 cc 
84201194:	84 f0 65 88 	r2 = M[r6 + 404];
84201198:	05 00       	r3 = Null + Null;
8420119a:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
8420119c:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
842011a0:	ca 57       	r0 = rMAC LSHIFT 32;
842011a2:	ff fd af f0 	call (m) 0x17130;
842011a6:	2f ec 
842011a8:	11 00       	rMAC = r0 + Null;
842011aa:	49 0c       	rMAC = r7 + rMAC;

        TIME time_of_arrival = time_sub(current_time, time_passed);
842011ac:	1f fa 03 c2 	r1 = r8 - rMAC;

        /* see if we have minimum amount for tag */
        if(samples >= op_extra_data->mic_metadata_min_tag_len)
842011b0:	82 f0 cc 88 	r0 = M[r6 + 816];
842011b4:	b8 04       	Null = r5 - r0;
842011b6:	04 64       	if NC jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_9;

842011b8 <Lc_aec_reference_mic_generate_metadata_with_ttp_8>:
        {
            /* we have enough new samples to append a complete tag */
            mtag->length = samples*OCTETS_PER_SAMPLE;
842011b8:	7a 54       	r0 = r5 LSHIFT 2;
842011ba:	f2 8e       	M[r4 + 12] = r0;
842011bc:	08 6e       	jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_10;

842011be <Lc_aec_reference_mic_generate_metadata_with_ttp_9>:
             * new complete tag, we append a new tag with
             * minimum length, this tag is incomplete and
             * will be completed in next calls when we receive
             * new samples by appending Null tags.
             */
            mtag->length = op_extra_data->mic_metadata_min_tag_len*OCTETS_PER_SAMPLE;
842011be:	52 54       	r0 = r0 LSHIFT 2;
842011c0:	f2 8e       	M[r4 + 12] = r0;
            op_extra_data->mic_metadata_tag_left_words = op_extra_data->mic_metadata_min_tag_len - samples;
842011c2:	81 f0 cc 88 	rMAC = M[r6 + 816];
842011c6:	c9 05       	rMAC = rMAC - r5;
842011c8:	81 f0 cb 8e 	M[r6 + 812] = rMAC;

842011cc <Lc_aec_reference_mic_generate_metadata_with_ttp_10>:
        }

        ttp_status status;
        ttp_update_ttp(op_extra_data->mic_time_to_play, time_of_arrival,
                       mtag->length/OCTETS_PER_SAMPLE, &status);
842011cc:	45 12       	r3 = FP + 36;
842011ce:	f2 88       	r0 = M[r4 + 12];
842011d0:	54 50       	r2 = r0 LSHIFT -2;
842011d2:	82 f0 cf 88 	r0 = M[r6 + 828];
842011d6:	ff fd ab f0 	call (m) 0x16860;
842011da:	2b e4 
        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
842011dc:	43 12       	r1 = FP + 36;
842011de:	32 00       	r0 = r4 + Null;
842011e0:	ef fd fb ff 	call (m) 0x8d0;
842011e4:	31 e7 

842011e6 <Lc_aec_reference_mic_generate_metadata_with_ttp_11>:
    }
    /* append generated metadata to the output buffer */
    buff_metadata_append(met_buf, mtag, b4idx, afteridx);
842011e6:	04 00       	r2 = Null + Null;
842011e8:	33 00       	r1 = r4 + Null;
842011ea:	5a 08       	r0 = r9 + Null;
842011ec:	45 d8       	r3 = M[FP + 32];
842011ee:	ff fd 84 f0 	call (m) 0x11adc;
842011f2:	2f e7 

842011f4 <Lc_aec_reference_mic_generate_metadata_with_ttp_12>:
}
842011f4:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842011f6:	d8 4c       	rts;

842011f8 <$_aec_reference_set_mic_gains>:
    return TRUE;
}


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
842011f8:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842011fa:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842011fc:	a9 f0 0c 88 	r7 = M[r8 + 48];


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;
84201200:	97 f0 d0 20 	r5 = r7 + 208;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
84201204:	06 00       	r4 = Null + Null;
84201206:	17 6e       	jump (m) Lc_aec_reference_set_mic_gains_6;

84201208 <Lc_aec_reference_set_mic_gains_2>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201208:	31 22       	rMAC = r4 + 8;

8420120a <Lc_aec_reference_set_mic_gains_3>:
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
8420120a:	08 f0 00 f0 	r1 = rMAC OR 0x800000;
8420120e:	00 f1 53 c8 
84201212:	a2 f0 01 88 	r0 = M[r8 + 4];
84201216:	ff fd 1c f0 	call (m) 0x4ab0;
8420121a:	3b e4 
8420121c:	43 08       	r1 = r6 + Null;
8420121e:	ff fd 1b f0 	call (m) 0x4a1c;
84201222:	3f ef 

84201224 <Lc_aec_reference_set_mic_gains_4>:
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
84201224:	76 20       	r4 = r4 + 1;
84201226:	3f 21       	r5 = r5 + 4;
84201228:	30 26       	Null = r4 - 8;
8420122a:	02 f0 a7 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_11;

8420122e <Lc_aec_reference_set_mic_gains_5>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
8420122e:	30 25       	Null = r4 - 4;
84201230:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_7;

84201234 <Lc_aec_reference_set_mic_gains_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201234:	b2 20       	r0 = r4 + 2;
84201236:	02 6e       	jump (m) Lc_aec_reference_set_mic_gains_8;

84201238 <Lc_aec_reference_set_mic_gains_7>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201238:	32 22       	r0 = r4 + 8;

8420123a <Lc_aec_reference_set_mic_gains_8>:
    {
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
8420123a:	52 54       	r0 = r0 LSHIFT 2;
8420123c:	91 f0 02 e8 	rMAC = M[r7 + r0];
84201240:	f2 61       	if EQ jump (m) Lc_aec_reference_set_mic_gains_4;

84201242 <Lc_aec_reference_set_mic_gains_9>:
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
84201242:	78 f0 00 e8 	r6 = M[r5 + Null];
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201246:	30 25       	Null = r4 - 4;
84201248:	f2 ff c1 ef 	if C jump (m) Lc_aec_reference_set_mic_gains_2;

8420124c <Lc_aec_reference_set_mic_gains_10>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
8420124c:	b1 20       	rMAC = r4 + 2;
8420124e:	de 6f       	jump (m) Lc_aec_reference_set_mic_gains_3;

84201250 <Lc_aec_reference_set_mic_gains_11>:
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
        }
    }
}
84201250:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201252:	d8 4c       	rts;

84201254 <$_aec_reference_cleanup>:
 * Note: This function is the same as aec_reference_cleanup_graphs
 *       except that it will reset the entire channel status so any new attempt
 *       to build the graphs will rebuild everything from scratch.
 */
void aec_reference_cleanup(OPERATOR_DATA *op_data)
{
84201254:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201256:	16 99       	r4 = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* cleanup all the graphs */
    aec_reference_cleanup_graphs(op_extra_data);
84201258:	32 00       	r0 = r4 + Null;
8420125a:	06 f0 23 eb 	call (m) $_aec_reference_cleanup_graphs;

    /* reset channel status, so any new trying
     * of building graphs will rebuild every thing
     * from scratch
     */
    op_extra_data->channel_status = 0;
8420125e:	60 f0 76 8e 	M[r4 + 472] = Null;

84201262 <Lc_aec_reference_cleanup_2>:
}
84201262:	f1 48       	popm <FP, r4, rLink>;
84201264:	d8 4c       	rts;

84201266 <$_build_mic_graph>:
 *        whenever there is a change in microphone channel status.
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201266:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201268:	11 09       	r7 = r0 + Null;
    cbops_graph *mic_graph;
    cbops_op *op_ptr;
    unsigned i, num_mics = op_extra_data->num_mic_channels,j,num_io;
8420126a:	9a f0 78 88 	r8 = M[r7 + 480];
    unsigned* idxs;
    unsigned  out_idx,intern_idx;
    unsigned  st_idx=0,st_rs_idx=0;
8420126e:	40 de       	M[FP + 32] = Null;
84201270:	48 de       	M[FP + 36] = Null;
                             SIDETONE

    **********************************************************************/

    /* Is there a MIC path */
    if(!(op_extra_data->channel_status&CHAN_STATE_MIC_MASK))
84201272:	91 f0 76 88 	rMAC = M[r7 + 472];
84201276:	07 f0 11 f8 	rMAC = rMAC AND 0xf000f;
8420127a:	0f 00 
8420127c:	b6 60       	if EQ jump (m) Lc_build_mic_graph_18;

8420127e <Lc_build_mic_graph_2>:
    {
        return(TRUE);
    }

    /* create shared sidetone buffer */
    if(op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH)
8420127e:	91 f0 70 90 	rMAC = MBS[r7 + 624];
84201282:	88 24       	Null = rMAC - 2;
84201284:	be 62       	if NE jump (m) Lc_build_mic_graph_20;

84201286 <Lc_build_mic_graph_3>:
    {
        /* side tone buffer size, 2ms more than task period */
        unsigned sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                               op_extra_data->task_period_frac + FRACTIONAL(0.002));
84201286:	92 f0 6e 88 	r0 = M[r7 + 440];
8420128a:	91 f0 93 88 	rMAC = M[r7 + 588];
8420128e:	06 f1 13 f0 	r1 = rMAC + 4294967;
84201292:	37 31 
84201294:	00 f3 72 c9 	r0 = r0 * r1 (frac);
        /* we don't expect SidetoneOA buffer already existing at this point */
        PL_ASSERT(op_extra_data->sidetone_buf == NULL);
84201298:	91 f0 31 88 	rMAC = M[r7 + 196];
8420129c:	a9 60       	if EQ jump (m) Lc_build_mic_graph_19;

8420129e <Lc_build_mic_graph_4>:
8420129e:	03 f0 94 42 	r1 = Null + 660;
842012a2:	02 f0 13 60 	r0 = Null + 4115;
842012a6:	ff fd 96 f0 	call (m) 0x13f12;
842012aa:	2d e3 
842012ac:	0f f0 ab e7 	jump (m) Lc_build_mic_graph_66;

842012b0 <Lc_build_mic_graph_5>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }
    else if (st_idx != 0)
842012b0:	41 d8       	rMAC = M[FP + 32];
842012b2:	75 60       	if EQ jump (m) Lc_build_mic_graph_15;

842012b4 <Lc_build_mic_graph_6>:
    {
        /* Need to copy internal buffer to output before sidetone */
        op_ptr = create_shift_op(num_mics,&idxs[intern_idx], &idxs[out_idx],0);
842012b4:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842012b8:	54 d8       	r2 = M[FP + 40];
842012ba:	05 00       	r3 = Null + Null;
842012bc:	23 00       	r1 = r2 + Null;
842012be:	14 01       	r2 = r0 + r2;
842012c0:	5a d8       	r0 = M[FP + 44];
842012c2:	52 54       	r0 = r0 LSHIFT 2;
842012c4:	d3 00       	r1 = r0 + r1;
842012c6:	52 08       	r0 = r8 + Null;
842012c8:	ff fd 25 f1 	call (m) 0x25e08;
842012cc:	21 ea 

842012ce <Lc_build_mic_graph_7>:
        /*  Add Resampler Operators per channel (mic_rate --> output_rate) */
        op_ptr = create_iir_resamplerv2_op(num_mics, &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
        if(!op_ptr)
842012ce:	10 04       	Null = r0 - Null;
842012d0:	bd 60       	if EQ jump (m) Lc_build_mic_graph_25;

842012d2 <Lc_build_mic_graph_8>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842012d2:	13 00       	r1 = r0 + Null;
842012d4:	5a 08       	r0 = r9 + Null;
842012d6:	ff fd ad f0 	call (m) 0x16e96;
842012da:	21 ee 
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    /* Handle sidetone */
    if(st_idx != 0)
842012dc:	41 d8       	rMAC = M[FP + 32];
842012de:	5f 60       	if EQ jump (m) Lc_build_mic_graph_15;

842012e0 <Lc_build_mic_graph_9>:
    {
        /* Minimum space needed in buffer */
        unsigned threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
842012e0:	92 f0 6e 88 	r0 = M[r7 + 440];
842012e4:	93 f0 93 88 	r1 = M[r7 + 588];
842012e8:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842012ec:	56 20       	r4 = r0 + 1;

        cbops_set_output_io_buffer(mic_graph,st_idx,st_idx,op_extra_data->sidetone_buf);
842012ee:	95 f0 31 88 	r3 = M[r7 + 196];
842012f2:	5a 08       	r0 = r9 + Null;
842012f4:	44 d8       	r2 = M[FP + 32];
842012f6:	23 00       	r1 = r2 + Null;
842012f8:	ff fd ad f0 	call (m) 0x16e34;
842012fc:	3d e9 
            Note:  Sidetone is before resampler.
            Better solution is to place it at lowest sample rate */

        op_ptr = create_sidetone_filter_op(intern_idx, st_rs_idx, 3,
                                           (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                           (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
842012fe:	01 f0 0c ff 	push r7 + 268;
84201302:	19 cf 
84201304:	95 f0 f0 20 	r3 = r7 + 240;
84201308:	c4 20       	r2 = Null + 3;
8420130a:	4b d8       	r1 = M[FP + 36];
8420130c:	5a d8       	r0 = M[FP + 44];
8420130e:	0c f0 29 e3 	call (m) $_create_sidetone_filter_op;
84201312:	7f 4c       	SP = SP + -4;

        op_extra_data->mic_sidetone_op = op_ptr;
        if(!op_ptr)
84201314:	92 f0 6c 8e 	M[r7 + 432] = r0;
84201318:	99 60       	if EQ jump (m) Lc_build_mic_graph_25;

8420131a <Lc_build_mic_graph_10>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
8420131a:	13 00       	r1 = r0 + Null;
8420131c:	5a 08       	r0 = r9 + Null;
8420131e:	ff fd ad f0 	call (m) 0x16e96;
84201322:	39 eb 

        if(st_rs_idx!=st_idx)
84201324:	4a d8       	r0 = M[FP + 36];
84201326:	41 d8       	rMAC = M[FP + 32];
84201328:	50 04       	Null = r0 - rMAC;
8420132a:	26 60       	if EQ jump (m) Lc_build_mic_graph_13;

8420132c <Lc_build_mic_graph_11>:
                                               &idxs[st_rs_idx],
                                               &idxs[st_idx],
                                               op_extra_data->mic_rate,
                                               op_extra_data->spkr_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
8420132c:	00 f0 30 cf 	push Null;
84201330:	00 f0 30 cf 	push Null;
84201334:	00 f0 30 cf 	push Null;
84201338:	91 f0 32 88 	rMAC = M[r7 + 200];
8420133c:	09 1c       	pushm <rMAC>;
8420133e:	91 f0 91 88 	rMAC = M[r7 + 580];
84201342:	09 1c       	pushm <rMAC>;
84201344:	91 f0 6e 88 	rMAC = M[r7 + 440];
84201348:	09 1c       	pushm <rMAC>;
8420134a:	95 f0 66 88 	r3 = M[r7 + 408];
8420134e:	42 d8       	r0 = M[FP + 32];
84201350:	54 d8       	r2 = M[FP + 40];
84201352:	52 54       	r0 = r0 LSHIFT 2;
84201354:	23 00       	r1 = r2 + Null;
84201356:	14 01       	r2 = r0 + r2;
84201358:	4a d8       	r0 = M[FP + 36];
8420135a:	52 54       	r0 = r0 LSHIFT 2;
8420135c:	d3 00       	r1 = r0 + r1;
8420135e:	42 20       	r0 = Null + 1;
84201360:	ff fd ae f0 	call (m) 0x16fb2;
84201364:	33 e2 
84201366:	7a 4c       	SP = SP + -24;
            if(!op_ptr)
84201368:	10 04       	Null = r0 - Null;
8420136a:	70 60       	if EQ jump (m) Lc_build_mic_graph_25;

8420136c <Lc_build_mic_graph_12>:
            {
                goto aFailed;
            }
            cbops_append_operator_to_graph(mic_graph,op_ptr);
8420136c:	13 00       	r1 = r0 + Null;
8420136e:	5a 08       	r0 = r9 + Null;
84201370:	ff fd ad f0 	call (m) 0x16e96;
84201374:	27 e9 

84201376 <Lc_build_mic_graph_13>:
        }

        /* Add in disgard on sidetone */

        op_ptr = create_sink_overflow_disgard_op(1,&idxs[st_idx],threshold);
84201376:	42 d8       	r0 = M[FP + 32];
84201378:	53 d8       	r1 = M[FP + 40];
8420137a:	52 54       	r0 = r0 LSHIFT 2;
8420137c:	d3 00       	r1 = r0 + r1;
8420137e:	42 20       	r0 = Null + 1;
84201380:	34 00       	r2 = r4 + Null;
84201382:	ff fd 55 f1 	call (m) 0x2bdc4;
84201386:	23 e2 
#if defined(IO_DEBUG)
        st_disgard_op = op_ptr;
84201388:	e0 f0 02 f0 	M[Null + $_st_disgard_op] = r0;
8420138c:	5a 8e 
#endif
        if(!op_ptr)
8420138e:	10 04       	Null = r0 - Null;
84201390:	5d 60       	if EQ jump (m) Lc_build_mic_graph_25;

84201392 <Lc_build_mic_graph_14>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
84201392:	13 00       	r1 = r0 + Null;
84201394:	5a 08       	r0 = r9 + Null;
84201396:	ff fd ad f0 	call (m) 0x16e96;
8420139a:	21 e8 

8420139c <Lc_build_mic_graph_15>:
    }

    /* add mute operator, it can be controlled by
     * message to the operator
     */
    op_ptr = create_mute_op(num_mics, &idxs[out_idx]);
8420139c:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842013a0:	53 d8       	r1 = M[FP + 40];
842013a2:	d3 00       	r1 = r0 + r1;
842013a4:	52 08       	r0 = r8 + Null;
842013a6:	0e f0 39 e7 	call (m) $_create_mute_op;
842013aa:	16 00       	r4 = r0 + Null;
    if(!op_ptr)
842013ac:	4f 60       	if EQ jump (m) Lc_build_mic_graph_25;

842013ae <Lc_build_mic_graph_16>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
842013ae:	33 00       	r1 = r4 + Null;
842013b0:	5a 08       	r0 = r9 + Null;
842013b2:	ff fd ad f0 	call (m) 0x16e96;
842013b6:	25 e7 
    op_extra_data->mic_mute_op = op_ptr;
842013b8:	96 f0 9d 8e 	M[r7 + 628] = r4;

    /* Insert latency operator */
    op_ptr = create_mic_latency_op(out_idx,&op_extra_data->sync_block);
842013bc:	93 f0 14 22 	r1 = r7 + 532;
842013c0:	52 08       	r0 = r8 + Null;
842013c2:	ff fd 37 f1 	call (m) 0x2822e;
842013c6:	2d e3 
    if(!op_ptr)
842013c8:	10 04       	Null = r0 - Null;
842013ca:	40 60       	if EQ jump (m) Lc_build_mic_graph_25;

842013cc <Lc_build_mic_graph_17>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
842013cc:	13 00       	r1 = r0 + Null;
842013ce:	5a 08       	r0 = r9 + Null;
842013d0:	ff fd ad f0 	call (m) 0x16e96;
842013d4:	27 e6 

    pfree(idxs);
842013d6:	52 d8       	r0 = M[FP + 40];
842013d8:	ff fd 1d f0 	call (m) 0x4f62;
842013dc:	2b ec 

    /* Each mic input has a corresponding output,
     * so it's safe to purge all channels now
     */
    aec_ref_purge_mics(mic_graph,num_mics);
842013de:	53 08       	r1 = r8 + Null;
842013e0:	5a 08       	r0 = r9 + Null;
842013e2:	ff fd 76 f1 	call (m) 0x300d6;
842013e6:	35 e7 

842013e8 <Lc_build_mic_graph_18>:
    **********************************************************************/

    /* Is there a MIC path */
    if(!(op_extra_data->channel_status&CHAN_STATE_MIC_MASK))
    {
        return(TRUE);
842013e8:	42 20       	r0 = Null + 1;
842013ea:	0f f0 ed e4 	jump (m) Lc_build_mic_graph_66;

842013ee <Lc_build_mic_graph_19>:
                                               op_extra_data->task_period_frac + FRACTIONAL(0.002));
        /* we don't expect SidetoneOA buffer already existing at this point */
        PL_ASSERT(op_extra_data->sidetone_buf == NULL);

        /* Allocate Buffer between cbops Graphs */
        op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
842013ee:	03 00       	r1 = Null + Null;
842013f0:	ff fd 89 f0 	call (m) 0x1279c;
842013f4:	2d ed 
842013f6:	92 f0 31 8e 	M[r7 + 196] = r0;

        if(!op_extra_data->sidetone_buf)
842013fa:	91 f0 31 88 	rMAC = M[r7 + 196];
842013fe:	2a 60       	if EQ jump (m) Lc_build_mic_graph_26;

84201400 <Lc_build_mic_graph_20>:
       MIC Internal
       SIDETONE OUT
    */

    out_idx    = num_mics;
    intern_idx = out_idx;
84201400:	ea f0 0b 8e 	M[FP + 44] = r8;
    num_io     = 2*num_mics;
84201404:	00 fa d6 d8 	r4 = r8 LSHIFT 1;

    if(op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH)
84201408:	91 f0 70 90 	rMAC = MBS[r7 + 624];
8420140c:	88 24       	Null = rMAC - 2;
8420140e:	25 62       	if NE jump (m) Lc_build_mic_graph_27;

84201410 <Lc_build_mic_graph_21>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
84201410:	5e de       	M[FP + 44] = r4;
        num_io    += num_mics;
84201412:	56 0c       	r4 = r8 + r4;

        /* sidetone output */
        st_idx        = num_io;
84201414:	46 de       	M[FP + 32] = r4;
        num_io++;

        st_rs_idx = st_idx;
84201416:	4e de       	M[FP + 36] = r4;
        intern_idx = num_io;
        num_io    += num_mics;

        /* sidetone output */
        st_idx        = num_io;
        num_io++;
84201418:	76 20       	r4 = r4 + 1;

        st_rs_idx = st_idx;
        if(op_extra_data->mic_rate!=op_extra_data->spkr_rate)
8420141a:	91 f0 66 88 	rMAC = M[r7 + 408];
8420141e:	92 f0 6e 88 	r0 = M[r7 + 440];
84201422:	88 04       	Null = rMAC - r0;
84201424:	2e 60       	if EQ jump (m) Lc_build_mic_graph_32;

84201426 <Lc_build_mic_graph_22>:
        {
            /* Sidetone is inplace */
            st_rs_idx = intern_idx;
84201426:	59 d8       	rMAC = M[FP + 44];
84201428:	49 de       	M[FP + 36] = rMAC;
8420142a:	2b 6e       	jump (m) Lc_build_mic_graph_32;

8420142c <Lc_build_mic_graph_23>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);

    }
    else if(intern_idx != 0)
8420142c:	59 d8       	rMAC = M[FP + 44];
8420142e:	ed 60       	if EQ jump (m) Lc_build_mic_graph_61;

84201430 <Lc_build_mic_graph_24>:
    {
        /* Otherwise, just copy data to next section */
        op_ptr = create_shift_op(num_mics, idxs, &idxs[intern_idx], op_extra_data->mic_shift);
84201430:	95 f0 6d 88 	r3 = M[r7 + 436];
84201434:	5a d8       	r0 = M[FP + 44];
84201436:	54 d8       	r2 = M[FP + 40];
84201438:	52 54       	r0 = r0 LSHIFT 2;
8420143a:	23 00       	r1 = r2 + Null;
8420143c:	14 01       	r2 = r0 + r2;
8420143e:	52 08       	r0 = r8 + Null;
84201440:	ff fd 24 f1 	call (m) 0x25e08;
84201444:	29 ee 
84201446:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201448:	cb 62       	if NE jump (m) Lc_build_mic_graph_59;

8420144a <Lc_build_mic_graph_25>:

    return(TRUE);
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
8420144a:	52 d8       	r0 = M[FP + 40];
8420144c:	ff fd 1d f0 	call (m) 0x4f62;
84201450:	37 e8 

84201452 <Lc_build_mic_graph_26>:
        if(!op_extra_data->sidetone_buf)
        {
            /* Not going ahead with creating mic graph if we
             * cannot create shared buffer for sidetone path.
             */
            return FALSE;
84201452:	02 00       	r0 = Null + Null;
84201454:	0f f0 83 e4 	jump (m) Lc_build_mic_graph_66;

84201458 <Lc_build_mic_graph_27>:
            /* Sidetone is inplace */
            st_rs_idx = intern_idx;
        }
    }
    else if( (op_extra_data->mic_rate_ability==RATEMATCHING_SUPPORT_SW) &&
             (op_extra_data->mic_rate!=op_extra_data->output_rate))
84201458:	91 f0 67 88 	rMAC = M[r7 + 412];
8420145c:	48 24       	Null = rMAC - 1;
8420145e:	0a 62       	if NE jump (m) Lc_build_mic_graph_30;

84201460 <Lc_build_mic_graph_28>:
84201460:	91 f0 66 88 	rMAC = M[r7 + 408];
84201464:	92 f0 65 88 	r0 = M[r7 + 404];
84201468:	88 04       	Null = rMAC - r0;
8420146a:	0b 60       	if EQ jump (m) Lc_build_mic_graph_32;

8420146c <Lc_build_mic_graph_29>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
8420146c:	5e de       	M[FP + 44] = r4;
        num_io    += num_mics;
8420146e:	56 0c       	r4 = r8 + r4;
84201470:	08 6e       	jump (m) Lc_build_mic_graph_32;

84201472 <Lc_build_mic_graph_30>:
    }
    else if (op_extra_data->mic_rate!=op_extra_data->output_rate)
84201472:	91 f0 66 88 	rMAC = M[r7 + 408];
84201476:	92 f0 65 88 	r0 = M[r7 + 404];
8420147a:	88 04       	Null = rMAC - r0;
8420147c:	02 60       	if EQ jump (m) Lc_build_mic_graph_32;

8420147e <Lc_build_mic_graph_31>:
    {
        /* No ratematching or sidetone.  Just resampling  */
        intern_idx = 0;
8420147e:	58 de       	M[FP + 44] = Null;

84201480 <Lc_build_mic_graph_32>:
    }

    idxs = create_default_indexes(num_io);
84201480:	32 00       	r0 = r4 + Null;
84201482:	ff fd ad f0 	call (m) 0x16f08;
84201486:	27 e4 
84201488:	52 de       	M[FP + 40] = r0;
    if(idxs == NULL)
8420148a:	11 00       	rMAC = r0 + Null;
8420148c:	e3 61       	if EQ jump (m) Lc_build_mic_graph_26;

8420148e <Lc_build_mic_graph_33>:
    {
        return(FALSE);
    }

    /* Allocate mic graph */
    mic_graph = cbops_alloc_graph(num_io);
8420148e:	32 00       	r0 = r4 + Null;
84201490:	ff fd ac f0 	call (m) 0x16d76;
84201494:	27 e7 
84201496:	13 09       	r9 = r0 + Null;
    if(!mic_graph)
84201498:	d9 61       	if EQ jump (m) Lc_build_mic_graph_25;

8420149a <Lc_build_mic_graph_34>:
    {
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;
8420149a:	9b f0 6a 8e 	M[r7 + 424] = r9;

    /* Setup IO Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
8420149e:	07 00       	r5 = Null + Null;
842014a0:	06 00       	r4 = Null + Null;
842014a2:	04 6e       	jump (m) Lc_build_mic_graph_36;

842014a4 <Lc_build_mic_graph_35>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
842014a4:	30 25       	Null = r4 - 4;
842014a6:	02 f0 91 e0 	if C jump (m) Lc_build_mic_graph_37;

842014aa <Lc_build_mic_graph_36>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
842014aa:	b2 20       	r0 = r4 + 2;
    {
        tCbuffer    *buffer_ptr_src,*buffer_ptr_snk;
        /* MICs may not be consecutive */
        buffer_ptr_src = op_extra_data->input_stream[MicrophoneTerminalByIndex(j)];
842014ac:	52 54       	r0 = r0 LSHIFT 2;
842014ae:	95 f0 02 e8 	r3 = M[r7 + r0];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
842014b2:	f2 20       	r0 = r4 + 3;
842014b4:	06 6e       	jump (m) Lc_build_mic_graph_38;

842014b6 <Lc_build_mic_graph_37>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
842014b6:	32 22       	r0 = r4 + 8;
842014b8:	52 54       	r0 = r0 LSHIFT 2;
842014ba:	95 f0 02 e8 	r3 = M[r7 + r0];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
842014be:	72 22       	r0 = r4 + 9;

842014c0 <Lc_build_mic_graph_38>:
        buffer_ptr_snk = op_extra_data->output_stream[OutputTerminalByIndex(j)];
842014c0:	91 f0 40 20 	rMAC = r7 + 64;
842014c4:	52 54       	r0 = r0 LSHIFT 2;
842014c6:	18 f0 02 e8 	r6 = M[rMAC + r0];
        if(buffer_ptr_src && buffer_ptr_snk && (i < num_mics))
842014ca:	28 04       	Null = r3 - Null;
842014cc:	17 60       	if EQ jump (m) Lc_build_mic_graph_42;

842014ce <Lc_build_mic_graph_39>:
842014ce:	0f f8 00 c2 	Null = r6 - Null;
842014d2:	14 60       	if EQ jump (m) Lc_build_mic_graph_42;

842014d4 <Lc_build_mic_graph_40>:
842014d4:	af f7 00 c2 	Null = r5 - r8;
842014d8:	02 f0 a3 e0 	if C jump (m) Lc_build_mic_graph_42;

842014dc <Lc_build_mic_graph_41>:
        {
            /* Inputs */
            cbops_set_input_io_buffer(mic_graph,i,0,buffer_ptr_src);
842014dc:	04 00       	r2 = Null + Null;
842014de:	3b 00       	r1 = r5 + Null;
842014e0:	5a 08       	r0 = r9 + Null;
842014e2:	ff fd ac f0 	call (m) 0x16e02;
842014e6:	21 e9 
            /* Outputs */
            cbops_set_output_io_buffer(mic_graph,out_idx+i,out_idx,buffer_ptr_snk);
842014e8:	7f fa 03 c0 	r1 = r8 + r5;
842014ec:	45 08       	r3 = r6 + Null;
842014ee:	54 08       	r2 = r8 + Null;
842014f0:	5a 08       	r0 = r9 + Null;
842014f2:	ff fd ac f0 	call (m) 0x16e34;
842014f6:	23 ea 
            i++;
842014f8:	7f 20       	r5 = r5 + 1;

842014fa <Lc_build_mic_graph_42>:
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;

    /* Setup IO Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
842014fa:	76 20       	r4 = r4 + 1;
842014fc:	30 26       	Null = r4 - 8;
842014fe:	d3 65       	if NC jump (m) Lc_build_mic_graph_35;

84201500 <Lc_build_mic_graph_43>:
            cbops_set_output_io_buffer(mic_graph,out_idx+i,out_idx,buffer_ptr_snk);
            i++;
        }
    }

    if(intern_idx > out_idx)
84201500:	59 d8       	rMAC = M[FP + 44];
84201502:	af f1 00 c2 	Null = rMAC - r8;
84201506:	09 f0 a9 e0 	if LS jump (m) Lc_build_mic_graph_47;

8420150a <Lc_build_mic_graph_44>:
    {
        for(i=0;i<num_mics;i++)
8420150a:	06 00       	r4 = Null + Null;
8420150c:	97 f0 84 20 	r5 = r7 + 132;

84201510 <Lc_build_mic_graph_45>:
84201510:	af f6 00 c2 	Null = r4 - r8;
84201514:	02 f0 9b e0 	if C jump (m) Lc_build_mic_graph_47;

84201518 <Lc_build_mic_graph_46>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
84201518:	3d e8       	r3 = M[r5 + Null];
8420151a:	59 d8       	rMAC = M[FP + 44];
8420151c:	0c 00       	r2 = rMAC + Null;
8420151e:	73 00       	r1 = r4 + rMAC;
84201520:	5a 08       	r0 = r9 + Null;
84201522:	ff fd ac f0 	call (m) 0x16e66;
84201526:	25 ea 
        }
    }

    if(intern_idx > out_idx)
    {
        for(i=0;i<num_mics;i++)
84201528:	76 20       	r4 = r4 + 1;
8420152a:	3f 21       	r5 = r5 + 4;
8420152c:	f2 6f       	jump (m) Lc_build_mic_graph_45;

8420152e <Lc_build_mic_graph_47>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
        }
    }

    op_extra_data->mic_rate_adjustment = 0;
8420152e:	90 f0 69 8e 	M[r7 + 420] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_HW)
84201532:	91 f0 67 88 	rMAC = M[r7 + 412];
84201536:	88 24       	Null = rMAC - 2;
84201538:	13 62       	if NE jump (m) Lc_build_mic_graph_51;

8420153a <Lc_build_mic_graph_48>:
    {
        /* With HW rate adjustmen we always need rate monitor,
         * except when we are syncing MIC to REF.
         */
        if(!op_extra_data->mic_sync_enable)
8420153a:	90 f0 d4 88 	Null = M[r7 + 848];
8420153e:	2c 62       	if NE jump (m) Lc_build_mic_graph_55;

84201540 <Lc_build_mic_graph_49>:
        {
            op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201540:	92 f0 92 88 	r0 = M[r7 + 584];
84201544:	03 00       	r1 = Null + Null;
84201546:	0a f0 33 ef 	call (m) $_create_rate_monitor_operator;
8420154a:	16 00       	r4 = r0 + Null;
            if(!op_ptr)
8420154c:	7f 61       	if EQ jump (m) Lc_build_mic_graph_25;

8420154e <Lc_build_mic_graph_50>:
            {
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
8420154e:	05 f0 b8 53 	r3 = Null + 3000;
84201552:	44 20       	r2 = Null + 1;
84201554:	93 f0 66 88 	r1 = M[r7 + 408];
84201558:	f5 ff 24 e6 	call $_rate_monitor_op_initialise;
8420155c:	16 6e       	jump (m) Lc_build_mic_graph_54;

8420155e <Lc_build_mic_graph_51>:
        }
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->mic_endpoint))
8420155e:	92 f0 7f 88 	r0 = M[r7 + 508];
84201562:	ff fd 1a f0 	call (m) 0x4a8c;
84201566:	2b e9 
84201568:	10 04       	Null = r0 - Null;
8420156a:	16 62       	if NE jump (m) Lc_build_mic_graph_55;

8420156c <Lc_build_mic_graph_52>:
    {
        /* With SW rate adjustment we need rate monitor if mic isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
8420156c:	92 f0 92 88 	r0 = M[r7 + 584];
84201570:	03 00       	r1 = Null + Null;
84201572:	0a f0 27 ee 	call (m) $_create_rate_monitor_operator;
84201576:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201578:	69 61       	if EQ jump (m) Lc_build_mic_graph_25;

8420157a <Lc_build_mic_graph_53>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate, FALSE,
                                    100*MILLISECOND/MILLISECOND);
8420157a:	05 f0 64 40 	r3 = Null + 100;
8420157e:	93 f0 66 88 	r1 = M[r7 + 408];
84201582:	04 00       	r2 = Null + Null;
84201584:	f5 ff 38 e4 	call $_rate_monitor_op_initialise;

84201588 <Lc_build_mic_graph_54>:
    }
    if(NULL != op_ptr)
    {
        /* insert rate monitor op into the graph */
        op_extra_data->mic_rate_monitor_op = op_ptr;
84201588:	96 f0 6b 8e 	M[r7 + 428] = r4;
        cbops_append_operator_to_graph(mic_graph,op_ptr);
8420158c:	33 00       	r1 = r4 + Null;
8420158e:	5a 08       	r0 = r9 + Null;
84201590:	ff fd ac f0 	call (m) 0x16e96;
84201594:	27 e8 

84201596 <Lc_build_mic_graph_55>:
    /* Handle input */
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       && (0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
       )
84201596:	91 f0 67 88 	rMAC = M[r7 + 412];
8420159a:	48 24       	Null = rMAC - 1;
8420159c:	48 63       	if NE jump (m) Lc_build_mic_graph_23;

8420159e <Lc_build_mic_graph_56>:
8420159e:	90 f0 ad 88 	Null = M[r7 + 692];
842015a2:	45 63       	if NE jump (m) Lc_build_mic_graph_23;

842015a4 <Lc_build_mic_graph_57>:
    {
        /* Apply Software Rate Adjustment */
        op_ptr = create_sw_rate_adj_op(num_mics, idxs, &idxs[intern_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->mic_rate_adjustment, op_extra_data->mic_shift);
842015a4:	91 f0 6d 88 	rMAC = M[r7 + 436];
842015a8:	09 1c       	pushm <rMAC>;
842015aa:	01 f0 a4 ff 	push r7 + 420;
842015ae:	19 cf 
842015b0:	85 2a       	r3 = Null + 26;
842015b2:	5a d8       	r0 = M[FP + 44];
842015b4:	54 d8       	r2 = M[FP + 40];
842015b6:	52 54       	r0 = r0 LSHIFT 2;
842015b8:	23 00       	r1 = r2 + Null;
842015ba:	14 01       	r2 = r0 + r2;
842015bc:	52 08       	r0 = r8 + Null;
842015be:	ff fd ab f0 	call (m) 0x16bea;
842015c2:	2d e1 
842015c4:	7e 4c       	SP = SP + -8;
842015c6:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842015c8:	41 61       	if EQ jump (m) Lc_build_mic_graph_25;

842015ca <Lc_build_mic_graph_58>:
        {
            goto aFailed;
        }

        op_extra_data->mic_sw_rateadj_op=op_ptr;
842015ca:	96 f0 7d 8e 	M[r7 + 500] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
842015ce:	03 00       	r1 = Null + Null;
842015d0:	90 f0 68 88 	Null = M[r7 + 416];
842015d4:	20 f0 43 ce 	if EQ r1 = Null + 1;
842015d8:	ff fd ab f0 	call (m) 0x16c96;
842015dc:	3f e5 

842015de <Lc_build_mic_graph_59>:

        cbops_append_operator_to_graph(mic_graph,op_ptr);
842015de:	33 00       	r1 = r4 + Null;
842015e0:	5a 08       	r0 = r9 + Null;
842015e2:	ff fd ac f0 	call (m) 0x16e96;
842015e6:	35 e5 

        /* Early DC remove on mic path. Before Sidetone split so the signal split
           to the speaker doesn't have DC */
        op_ptr = create_dc_remove_op(num_mics, &idxs[intern_idx], &idxs[intern_idx]);
842015e8:	5a d8       	r0 = M[FP + 44];
842015ea:	53 d8       	r1 = M[FP + 40];
842015ec:	52 54       	r0 = r0 LSHIFT 2;
842015ee:	d3 00       	r1 = r0 + r1;
842015f0:	1c 00       	r2 = r1 + Null;
842015f2:	52 08       	r0 = r8 + Null;
842015f4:	ff fd 24 f1 	call (m) 0x25e40;
842015f8:	2d e2 
        if(!op_ptr)
842015fa:	10 04       	Null = r0 - Null;
842015fc:	27 61       	if EQ jump (m) Lc_build_mic_graph_25;

842015fe <Lc_build_mic_graph_60>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842015fe:	13 00       	r1 = r0 + Null;
84201600:	5a 08       	r0 = r9 + Null;
84201602:	ff fd ac f0 	call (m) 0x16e96;
84201606:	35 e4 

84201608 <Lc_build_mic_graph_61>:
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    /* Handle output */
    if(op_extra_data->mic_rate!=op_extra_data->output_rate)
84201608:	95 f0 66 88 	r3 = M[r7 + 408];
8420160c:	92 f0 65 88 	r0 = M[r7 + 404];
84201610:	a8 04       	Null = r3 - r0;
84201612:	f0 ff 9f e9 	if EQ jump (m) Lc_build_mic_graph_5;

84201616 <Lc_build_mic_graph_62>:
    {
        /* If only operator then shift input to output */
        unsigned shift_amount = (intern_idx != 0) ? 0 :  op_extra_data->mic_shift;
84201616:	59 d8       	rMAC = M[FP + 44];
84201618:	03 60       	if EQ jump (m) Lc_build_mic_graph_64;

8420161a <Lc_build_mic_graph_63>:
8420161a:	01 00       	rMAC = Null + Null;
8420161c:	03 6e       	jump (m) Lc_build_mic_graph_65;

8420161e <Lc_build_mic_graph_64>:
8420161e:	91 f0 6d 88 	rMAC = M[r7 + 436];

84201622 <Lc_build_mic_graph_65>:

        /*  Add Resampler Operators per channel (mic_rate --> output_rate) */
        op_ptr = create_iir_resamplerv2_op(num_mics, &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84201622:	00 f0 30 cf 	push Null;
84201626:	00 f0 30 cf 	push Null;
8420162a:	09 1c       	pushm <rMAC>;
8420162c:	91 f0 32 88 	rMAC = M[r7 + 200];
84201630:	09 1c       	pushm <rMAC>;
84201632:	91 f0 91 88 	rMAC = M[r7 + 580];
84201636:	0a 1c       	pushm <rMAC, r0>;
84201638:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
8420163c:	54 d8       	r2 = M[FP + 40];
8420163e:	23 00       	r1 = r2 + Null;
84201640:	14 01       	r2 = r0 + r2;
84201642:	5a d8       	r0 = M[FP + 44];
84201644:	52 54       	r0 = r0 LSHIFT 2;
84201646:	d3 00       	r1 = r0 + r1;
84201648:	52 08       	r0 = r8 + Null;
8420164a:	ff fd ac f0 	call (m) 0x16fb2;
8420164e:	29 eb 
84201650:	7a 4c       	SP = SP + -24;
84201652:	ff ff fd e8 	jump (m) Lc_build_mic_graph_7;

84201656 <Lc_build_mic_graph_66>:
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
    return(FALSE);
}
84201656:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201658:	d8 4c       	rts;

8420165a <$_build_spkr_graph>:
 *       depending on the connections and microphone state, however they
 *       aren't included by this function, instead they are added to the
 *       speaker graph later.
 */
bool build_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420165a:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420165c:	13 09       	r9 = r0 + Null;
    cbops_op    *overrid_op_ptr;
    unsigned    num_io;
    tCbuffer    *buffer_ptr;
    unsigned    *idxs;
    unsigned    out_indx,intern_ins_idx,intern_rs_idx,intern_rm_idx;
    unsigned    spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420165e:	b2 f0 76 88 	r0 = M[r9 + 472];
84201662:	21 f1 f0 1f 	rMAC = r0 AND 0x3ff0;
         "Sidetone Mix" is added/removed to/from the graph by aec_reference_spkr_include_sidetone function.
         "Reference sub-path" is added/removed to/from the graph by aec_reference_spkr_include_ref_path function.

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
84201666:	22 f0 f0 0f 	r0 = r0 AND 0xff0;
8420166a:	42 60       	if EQ jump (m) Lc_build_spkr_graph_10;

8420166c <Lc_build_spkr_graph_2>:
    {
        return(TRUE);
    }

    /* Determine IO configuration */
    num_spkrs  = op_extra_data->num_spkr_channels;
8420166c:	b9 f0 77 88 	r7 = M[r9 + 476];
84201670:	e9 f0 08 8e 	M[FP + 32] = r7;
    num_inputs = op_extra_data->num_spkr_channels;
    if(!(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA))
84201674:	ca c5       	r0 = rMAC AND 0x1000;
84201676:	40 62       	if NE jump (m) Lc_build_spkr_graph_12;

84201678 <Lc_build_spkr_graph_3>:
    {
        if(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX)
84201678:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
8420167c:	3c 60       	if EQ jump (m) Lc_build_spkr_graph_11;

8420167e <Lc_build_spkr_graph_4>:
        {
            /* Multiple inputs, mono output */
            num_spkrs=1;
8420167e:	41 20       	rMAC = Null + 1;
84201680:	41 de       	M[FP + 32] = rMAC;
84201682:	3a 6e       	jump (m) Lc_build_spkr_graph_12;

84201684 <Lc_build_spkr_graph_5>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->spkr_endpoint))
84201684:	b2 f0 80 88 	r0 = M[r9 + 512];
84201688:	ff fd 1a f0 	call (m) 0x4a8c;
8420168c:	25 e0 
8420168e:	10 04       	Null = r0 - Null;
84201690:	22 62       	if NE jump (m) Lc_build_spkr_graph_9;

84201692 <Lc_build_spkr_graph_6>:
    {
        /* With SW rate adjustment we need rate monitor if speaker isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201692:	b2 f0 92 88 	r0 = M[r9 + 584];
84201696:	03 00       	r1 = Null + Null;
84201698:	0a f0 21 e5 	call (m) $_create_rate_monitor_operator;
8420169c:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420169e:	89 60       	if EQ jump (m) Lc_build_spkr_graph_27;

842016a0 <Lc_build_spkr_graph_7>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, FALSE,
                                    100*MILLISECOND/MILLISECOND);
842016a0:	05 f0 64 40 	r3 = Null + 100;
842016a4:	b3 f0 6e 88 	r1 = M[r9 + 440];
842016a8:	04 00       	r2 = Null + Null;
842016aa:	f4 ff 32 eb 	call $_rate_monitor_op_initialise;

842016ae <Lc_build_spkr_graph_8>:
    if(NULL != op_ptr)
    {
#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /*  directly pass new amount read by speaker to the operator */
    op_extra_data->spkr_last_offset =
        cbuffer_get_read_mmu_offset(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
842016ae:	b2 f0 11 88 	r0 = M[r9 + 68];
842016b2:	ff fd 89 f0 	call (m) 0x12a28;
842016b6:	37 eb 
842016b8:	b2 f0 d1 8e 	M[r9 + 836] = r0;
    set_rate_monitor_new_amount_ptr(op_ptr, &op_extra_data->spkr_new_amount);
842016bc:	b3 f0 48 23 	r1 = r9 + 840;
842016c0:	32 00       	r0 = r4 + Null;
842016c2:	f4 ff 3e e9 	call $_set_rate_monitor_new_amount_ptr;
#endif
        /* insert rate monitor op into the graph */
        op_extra_data->spkr_rate_monitor_op = op_ptr;
842016c6:	b6 f0 73 8e 	M[r9 + 460] = r4;
        cbops_append_operator_to_graph(spkr_graph, op_ptr);
842016ca:	33 00       	r1 = r4 + Null;
842016cc:	52 08       	r0 = r8 + Null;
842016ce:	ff fd ab f0 	call (m) 0x16e96;
842016d2:	29 ee 

842016d4 <Lc_build_spkr_graph_9>:
    }

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
842016d4:	b0 f0 d3 8e 	M[r9 + 844] = Null;

#ifdef ENABLE_SW_DAC_DC_OFFSET_COMPENSATION
#ifndef RUNNING_ON_KALSIM    
    /* compensate for HW dc offset addition */
    op_extra_data->spkr_dc_offset_op =
        setup_cbops_dc_offset_compensation(spkr_graph, op_extra_data->task_frequency);
842016d8:	b3 f0 92 88 	r1 = M[r9 + 584];
842016dc:	52 08       	r0 = r8 + Null;
842016de:	0c f0 25 ef 	call (m) $M.download_support_lib.setup_cbops_dc_offset_compensation.return_null;
842016e2:	b2 f0 9e 8e 	M[r9 + 632] = r0;
#endif    
#endif
    pfree(idxs);
842016e6:	4a d8       	r0 = M[FP + 36];
842016e8:	ff fd 1c f0 	call (m) 0x4f62;
842016ec:	3b e3 

842016ee <Lc_build_spkr_graph_10>:

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
    {
        return(TRUE);
842016ee:	42 20       	r0 = Null + 1;
842016f0:	0f f0 91 e7 	jump (m) Lc_build_spkr_graph_77;

842016f4 <Lc_build_spkr_graph_11>:
            num_spkrs=1;
        }
        else
        {
            /* Mono input, multiple outputs */
            num_inputs=1;
842016f4:	09 71       	r7 = Null + 1;

842016f6 <Lc_build_spkr_graph_12>:
        }
    }

    /* outputs follow inputs */
    /* Internal buffers for output of insert follow outputs */
    out_indx       = num_inputs;
842016f6:	e9 f0 0a 8e 	M[FP + 40] = r7;

    /* Count the buffers needed */
    num_io         = num_inputs+num_spkrs;
842016fa:	41 d8       	rMAC = M[FP + 32];
842016fc:	49 0c       	rMAC = r7 + rMAC;

    /* Assume no resampler or rate matching */
    intern_rs_idx = 0;
842016fe:	58 de       	M[FP + 44] = Null;
    intern_rm_idx = 0;
84201700:	60 de       	M[FP + 48] = Null;
    intern_ins_idx = 0;
84201702:	68 de       	M[FP + 52] = Null;

    /* reserve one index for sidetone input buffer */
    op_extra_data->spkr_st_in_idx = num_io;
84201704:	b1 f0 a5 8e 	M[r9 + 660] = rMAC;
    num_io++;
84201708:	49 20       	rMAC = rMAC + 1;
8420170a:	71 de       	M[FP + 56] = rMAC;

    /* Check if resampler is required */
    if(op_extra_data->input_rate!=op_extra_data->spkr_rate)
8420170c:	b1 f0 64 88 	rMAC = M[r9 + 400];
84201710:	b2 f0 6e 88 	r0 = M[r9 + 440];
84201714:	88 04       	Null = rMAC - r0;
84201716:	35 60       	if EQ jump (m) Lc_build_spkr_graph_22;

84201718 <Lc_build_spkr_graph_13>:
    {
        intern_rs_idx = out_indx;
84201718:	e9 f0 0b 8e 	M[FP + 44] = r7;

        if(op_extra_data->spkr_rate_ability==RATEMATCHING_SUPPORT_SW)
8420171c:	b1 f0 6f 88 	rMAC = M[r9 + 444];
84201720:	48 24       	Null = rMAC - 1;
84201722:	19 62       	if NE jump (m) Lc_build_spkr_graph_19;

84201724 <Lc_build_spkr_graph_14>:
        {
            /* Need buffers following resampler */
            intern_rs_idx    = num_io;
84201724:	71 d8       	rMAC = M[FP + 56];
84201726:	59 de       	M[FP + 44] = rMAC;
            if(num_spkrs>num_inputs)
84201728:	41 d8       	rMAC = M[FP + 32];
8420172a:	9f f1 00 c2 	Null = rMAC - r7;
8420172e:	09 f0 cb e0 	if LS jump (m) Lc_build_spkr_graph_21;

84201732 <Lc_build_spkr_graph_15>:
            {
                /* Resampler is Mono.  Feeds shift */
                num_io++;
84201732:	71 d8       	rMAC = M[FP + 56];
84201734:	49 20       	rMAC = rMAC + 1;
84201736:	71 de       	M[FP + 56] = rMAC;

84201738 <Lc_build_spkr_graph_16>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
84201738:	b0 f0 ae 88 	Null = M[r9 + 696];
8420173c:	0c 62       	if NE jump (m) Lc_build_spkr_graph_19;

8420173e <Lc_build_spkr_graph_17>:
    {
        intern_rm_idx = out_indx;
8420173e:	e9 f0 0c 8e 	M[FP + 48] = r7;
        /* Split needs buffer following rate matching (Mono)*/
        if(num_spkrs>num_inputs)
84201742:	41 d8       	rMAC = M[FP + 32];
84201744:	9f f1 00 c2 	Null = rMAC - r7;
84201748:	09 f0 8d e0 	if LS jump (m) Lc_build_spkr_graph_19;

8420174c <Lc_build_spkr_graph_18>:
        {
            intern_rm_idx = num_io;
8420174c:	71 d8       	rMAC = M[FP + 56];
8420174e:	61 de       	M[FP + 48] = rMAC;
            num_io++;
84201750:	49 20       	rMAC = rMAC + 1;
84201752:	71 de       	M[FP + 56] = rMAC;

84201754 <Lc_build_spkr_graph_19>:
    /* reserve 2 indexes for reference sub-path,
     * one is for reference output buffer, the
     * other one for scratch buffer for possible
     * resampler in the sub-path.
     */
    op_extra_data->spkr_ref_idx  = num_io;
84201754:	71 d8       	rMAC = M[FP + 56];
84201756:	b1 f0 a4 8e 	M[r9 + 656] = rMAC;
    num_io +=2;
8420175a:	89 20       	rMAC = rMAC + 2;
8420175c:	71 de       	M[FP + 56] = rMAC;

    /* Allocate buffer index array for easy setup */
    if(num_inputs<num_spkrs)
8420175e:	41 d8       	rMAC = M[FP + 32];
84201760:	1f f9 00 c2 	Null = r7 - rMAC;
84201764:	02 f0 a7 e0 	if C jump (m) Lc_build_spkr_graph_23;

84201768 <Lc_build_spkr_graph_20>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
84201768:	72 d8       	r0 = M[FP + 56];
8420176a:	41 d8       	rMAC = M[FP + 32];
8420176c:	8a 00       	r0 = rMAC + r0;
8420176e:	ff fd ab f0 	call (m) 0x16f08;
84201772:	3b ec 
84201774:	4a de       	M[FP + 36] = r0;
84201776:	0f 6e       	jump (m) Lc_build_spkr_graph_24;

84201778 <Lc_build_spkr_graph_21>:
                num_io++;
            }
            else
            {
                /* Resampler is multi channel */
                num_io += num_inputs;
84201778:	71 d8       	rMAC = M[FP + 56];
8420177a:	49 0c       	rMAC = r7 + rMAC;
8420177c:	71 de       	M[FP + 56] = rMAC;
8420177e:	dd 6f       	jump (m) Lc_build_spkr_graph_16;

84201780 <Lc_build_spkr_graph_22>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
84201780:	b1 f0 6f 88 	rMAC = M[r9 + 444];
84201784:	48 24       	Null = rMAC - 1;
84201786:	d9 61       	if EQ jump (m) Lc_build_spkr_graph_16;

84201788 <Lc_21>:
84201788:	e6 6f       	jump (m) Lc_build_spkr_graph_19;

8420178a <Lc_build_spkr_graph_23>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
    }
    else
    {
        idxs = create_default_indexes(num_io);
8420178a:	72 d8       	r0 = M[FP + 56];
8420178c:	ff fd ab f0 	call (m) 0x16f08;
84201790:	3d eb 
84201792:	4a de       	M[FP + 36] = r0;

84201794 <Lc_build_spkr_graph_24>:
    }
    if(idxs == NULL)
84201794:	49 d8       	rMAC = M[FP + 36];
84201796:	11 60       	if EQ jump (m) Lc_build_spkr_graph_28;

84201798 <Lc_build_spkr_graph_25>:
    {
        return(FALSE);
    }

    /* Allocate num_io buffers in spkr graph */
    spkr_graph = cbops_alloc_graph(num_io);
84201798:	72 d8       	r0 = M[FP + 56];
8420179a:	ff fd aa f0 	call (m) 0x16d76;
8420179e:	3d ee 
842017a0:	12 09       	r8 = r0 + Null;
    if(!spkr_graph)
842017a2:	07 60       	if EQ jump (m) Lc_build_spkr_graph_27;

842017a4 <Lc_build_spkr_graph_26>:
    {
        goto aFailed;
    }
    op_extra_data->spkr_graph = spkr_graph;
842017a4:	ba f0 72 8e 	M[r9 + 456] = r8;
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
842017a8:	07 00       	r5 = Null + Null;
842017aa:	00 09       	r6 = Null + Null;
842017ac:	06 00       	r4 = Null + Null;
842017ae:	0b 6e       	jump (m) Lc_build_spkr_graph_30;

842017b0 <Lc_build_spkr_graph_27>:

    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Done!" );
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
842017b0:	4a d8       	r0 = M[FP + 36];
842017b2:	ff fd 1b f0 	call (m) 0x4f62;
842017b6:	31 ed 

842017b8 <Lc_build_spkr_graph_28>:
    {
        idxs = create_default_indexes(num_io);
    }
    if(idxs == NULL)
    {
        return(FALSE);
842017b8:	02 00       	r0 = Null + Null;
842017ba:	0f f0 c7 e5 	jump (m) Lc_build_spkr_graph_77;

842017be <Lc_build_spkr_graph_29>:

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
    {
        /* Inputs may not be contiguous */
        buffer_ptr =  op_extra_data->input_stream[SpeakerInputTerminalByIndex(j)];
842017be:	b0 24       	Null = r4 - 2;
842017c0:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_31;

842017c4 <Lc_build_spkr_graph_30>:
842017c4:	32 00       	r0 = r4 + Null;
842017c6:	02 6e       	jump (m) Lc_build_spkr_graph_32;

842017c8 <Lc_build_spkr_graph_31>:
842017c8:	32 21       	r0 = r4 + 4;

842017ca <Lc_build_spkr_graph_32>:
842017ca:	52 54       	r0 = r0 LSHIFT 2;
        if(buffer_ptr)
842017cc:	b5 f0 02 e8 	r3 = M[r9 + r0];
842017d0:	08 60       	if EQ jump (m) Lc_build_spkr_graph_34;

842017d2 <Lc_build_spkr_graph_33>:
        {
            /* Inputs */
            cbops_set_input_io_buffer(spkr_graph,i,0,buffer_ptr);
842017d2:	04 00       	r2 = Null + Null;
842017d4:	3b 00       	r1 = r5 + Null;
842017d6:	52 08       	r0 = r8 + Null;
842017d8:	ff fd ab f0 	call (m) 0x16e02;
842017dc:	2b e1 
            i++;
842017de:	7f 20       	r5 = r5 + 1;

842017e0 <Lc_build_spkr_graph_34>:
        }
        /* Outputs may not be contiguous */
        buffer_ptr =  op_extra_data->output_stream[SpeakerTerminalByIndex(j)];
842017e0:	b0 24       	Null = r4 - 2;
842017e2:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_36;

842017e6 <Lc_build_spkr_graph_35>:
842017e6:	72 20       	r0 = r4 + 1;
842017e8:	02 6e       	jump (m) Lc_build_spkr_graph_37;

842017ea <Lc_build_spkr_graph_36>:
842017ea:	72 21       	r0 = r4 + 5;

842017ec <Lc_build_spkr_graph_37>:
842017ec:	b1 f0 40 20 	rMAC = r9 + 64;
842017f0:	52 54       	r0 = r0 LSHIFT 2;
        if(buffer_ptr)
842017f2:	8d e8       	r3 = M[rMAC + r0];
842017f4:	09 60       	if EQ jump (m) Lc_build_spkr_graph_39;

842017f6 <Lc_build_spkr_graph_38>:
        {
            cbops_set_output_io_buffer(spkr_graph,out_indx + k,out_indx,buffer_ptr);
842017f6:	8f f9 03 c0 	r1 = r7 + r6;
842017fa:	4c 08       	r2 = r7 + Null;
842017fc:	52 08       	r0 = r8 + Null;
842017fe:	ff fd ab f0 	call (m) 0x16e34;
84201802:	37 e1 
            k++;
84201804:	08 75       	r6 = r6 + 1;

84201806 <Lc_build_spkr_graph_39>:
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
84201806:	76 20       	r4 = r4 + 1;
84201808:	30 26       	Null = r4 - 8;
8420180a:	da 65       	if NC jump (m) Lc_build_spkr_graph_29;

8420180c <Lc_build_spkr_graph_40>:
            k++;
        }
    }

    /* DC remove before reference tap */
    op_ptr = create_dc_remove_op(num_inputs, idxs, idxs);
8420180c:	4a 08       	r0 = r7 + Null;
8420180e:	4c d8       	r2 = M[FP + 36];
84201810:	23 00       	r1 = r2 + Null;
84201812:	ff fd 23 f1 	call (m) 0x25e40;
84201816:	2f e1 
84201818:	17 00       	r5 = r0 + Null;
    if(!op_ptr)
8420181a:	cb 61       	if EQ jump (m) Lc_build_spkr_graph_27;

8420181c <Lc_build_spkr_graph_41>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(spkr_graph,op_ptr);
8420181c:	3b 00       	r1 = r5 + Null;
8420181e:	52 08       	r0 = r8 + Null;
84201820:	ff fd ab f0 	call (m) 0x16e96;
84201824:	37 e3 

    /* Thresholds for Insertion, keep a copy in main structure */
    op_extra_data->spkr_in_threshold  = frac_mult(op_extra_data->input_rate,op_extra_data->task_period_frac) + 1;
84201826:	b2 f0 64 88 	r0 = M[r9 + 400];
8420182a:	b3 f0 93 88 	r1 = M[r9 + 588];
8420182e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201832:	51 20       	rMAC = r0 + 1;
84201834:	b1 f0 af 8e 	M[r9 + 700] = rMAC;
    op_extra_data->spkr_out_threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
84201838:	b2 f0 6e 88 	r0 = M[r9 + 440];
8420183c:	b3 f0 93 88 	r1 = M[r9 + 588];
84201840:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201844:	51 20       	rMAC = r0 + 1;
84201846:	b1 f0 b0 8e 	M[r9 + 704] = rMAC;
     * task period there will be ~(spkr_out_threshold + max_jitter) in the output buffer,
     * this is to cover a full task period plus possible scheduling uncertainties.
     * 1ms max_jitter might be enough, 0.5ms added in case sidetone mixing will run
     * in decimated task period.
     */
    unsigned max_jitter = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.0015));
8420184a:	b2 f0 6e 88 	r0 = M[r9 + 440];
8420184e:	03 f0 93 f0 	r1 = Null + 3221225;
84201852:	e9 4a 
84201854:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    overrid_op_ptr = create_aec_ref_spkr_op(num_inputs, idxs,
                                            op_extra_data->spkr_in_threshold,
                                            num_spkrs,&idxs[out_indx],
                                            op_extra_data->spkr_out_threshold,
                                            max_jitter);
84201858:	11 1c       	pushm <r0>;
8420185a:	b1 f0 b0 88 	rMAC = M[r9 + 704];
8420185e:	09 1c       	pushm <rMAC>;
84201860:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201864:	49 d8       	rMAC = M[FP + 36];
84201866:	0b 00       	r1 = rMAC + Null;
84201868:	51 00       	rMAC = r0 + rMAC;
8420186a:	09 1c       	pushm <rMAC>;
8420186c:	b4 f0 af 88 	r2 = M[r9 + 700];
84201870:	4a 08       	r0 = r7 + Null;
84201872:	45 d8       	r3 = M[FP + 32];
84201874:	06 f0 3f ea 	call (m) $_create_aec_ref_spkr_op;
84201878:	7d 4c       	SP = SP + -12;
#if defined(IO_DEBUG)
    insert_op  = overrid_op_ptr;
8420187a:	e0 f0 02 f0 	M[Null + $_insert_op] = r0;
8420187e:	59 8e 
#endif
    if(!overrid_op_ptr)
84201880:	10 04       	Null = r0 - Null;
84201882:	97 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201884 <Lc_build_spkr_graph_42>:
    {
        goto aFailed;
    }

    cbops_set_override_operator(spkr_graph,overrid_op_ptr);
84201884:	13 00       	r1 = r0 + Null;
84201886:	52 08       	r0 = r8 + Null;
84201888:	ff fd ab f0 	call (m) 0x16ec2;
8420188c:	3b e1 

    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
8420188e:	41 d8       	rMAC = M[FP + 32];
84201890:	1f f9 00 c2 	Null = r7 - rMAC;
84201894:	09 f0 b9 e0 	if LS jump (m) Lc_build_spkr_graph_48;

84201898 <Lc_build_spkr_graph_43>:
    {
        for(i=1;i<num_inputs;i++)
84201898:	46 20       	r4 = Null + 1;

8420189a <Lc_build_spkr_graph_44>:
8420189a:	9f f6 00 c2 	Null = r4 - r7;
8420189e:	02 f0 ad e0 	if C jump (m) Lc_build_spkr_graph_47;

842018a2 <Lc_build_spkr_graph_45>:
        {
            /* NOTE: left scratch input reused for output (inplace) */
            /*  - Add Mix Operator - stereo to mono (left = (left+right)/2 */
            op_ptr = create_mixer_op(intern_ins_idx, intern_ins_idx+i, intern_ins_idx, 0, FRACTIONAL(0.5));
842018a2:	ff f3 ff ff 	push Null + 1073741823;
842018a6:	5f ef 
842018a8:	05 00       	r3 = Null + Null;
842018aa:	04 00       	r2 = Null + Null;
842018ac:	02 00       	r0 = Null + Null;
842018ae:	33 00       	r1 = r4 + Null;
842018b0:	ff fd 52 f1 	call (m) 0x2bcbc;
842018b4:	2d e0 
842018b6:	7f 4c       	SP = SP + -4;
842018b8:	17 00       	r5 = r0 + Null;
            if(!op_ptr)
842018ba:	7b 61       	if EQ jump (m) Lc_build_spkr_graph_27;

842018bc <Lc_build_spkr_graph_46>:
            {
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
842018bc:	3b 00       	r1 = r5 + Null;
842018be:	52 08       	r0 = r8 + Null;
842018c0:	ff fd aa f0 	call (m) 0x16e96;
842018c4:	37 ee 
    cbops_set_override_operator(spkr_graph,overrid_op_ptr);

    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
    {
        for(i=1;i<num_inputs;i++)
842018c6:	76 20       	r4 = r4 + 1;
842018c8:	e9 6f       	jump (m) Lc_build_spkr_graph_44;

842018ca <Lc_build_spkr_graph_47>:
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
        }
        /* Input is now mono */
        num_inputs = 1;
842018ca:	09 71       	r7 = Null + 1;

842018cc <Lc_build_spkr_graph_48>:
    /* This is the point where we take input for the
     * reference sub-path, store information about
     * where in the graph the reference sub-path
     * should be inserted to.
     */
    op_extra_data->spkr_ref_input_idx = intern_ins_idx;
842018cc:	b0 f0 a1 8e 	M[r9 + 644] = Null;
    op_extra_data->spkr_ref_point_op = op_ptr;
842018d0:	b7 f0 a8 8e 	M[r9 + 672] = r5;
    op_extra_data->spkr_ref_scratch_idx = num_inputs;
842018d4:	b9 f0 a2 8e 	M[r9 + 648] = r7;

    /* Add sample rate conversion per channel [num_inputs] (input_rate --> spkr_rate) */
    if(intern_rs_idx!=0)
842018d8:	59 d8       	rMAC = M[FP + 44];
842018da:	41 60       	if EQ jump (m) Lc_build_spkr_graph_56;

842018dc <Lc_build_spkr_graph_49>:
    {
        int shift_amount = op_extra_data->spkr_shift;
842018dc:	b1 f0 74 88 	rMAC = M[r9 + 464];

        if(intern_rs_idx!=out_indx)
842018e0:	5b d8       	r1 = M[FP + 44];
842018e2:	52 d8       	r0 = M[FP + 40];
842018e4:	98 04       	Null = r1 - r0;
842018e6:	18 60       	if EQ jump (m) Lc_build_spkr_graph_54;

842018e8 <Lc_build_spkr_graph_50>:
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
842018e8:	06 00       	r4 = Null + Null;
842018ea:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842018ee:	59 08       	rMAC = r9 + Null;
842018f0:	51 00       	rMAC = r0 + rMAC;
842018f2:	17 f0 84 20 	r5 = rMAC + 132;

842018f6 <Lc_build_spkr_graph_51>:
842018f6:	9f f6 00 c2 	Null = r4 - r7;
842018fa:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_53;

842018fe <Lc_build_spkr_graph_52>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,op_extra_data->scratch_bufs[num_inputs+i]);
842018fe:	3d e8       	r3 = M[r5 + Null];
84201900:	59 d8       	rMAC = M[FP + 44];
84201902:	0c 00       	r2 = rMAC + Null;
84201904:	73 00       	r1 = r4 + rMAC;
84201906:	52 08       	r0 = r8 + Null;
84201908:	ff fd aa f0 	call (m) 0x16e66;
8420190c:	3f ea 
        int shift_amount = op_extra_data->spkr_shift;

        if(intern_rs_idx!=out_indx)
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
8420190e:	76 20       	r4 = r4 + 1;
84201910:	3f 21       	r5 = r5 + 4;
84201912:	f2 6f       	jump (m) Lc_build_spkr_graph_51;

84201914 <Lc_build_spkr_graph_53>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,op_extra_data->scratch_bufs[num_inputs+i]);
            }
            shift_amount=0;
84201914:	01 00       	rMAC = Null + Null;

84201916 <Lc_build_spkr_graph_54>:
        }

        op_ptr = create_iir_resamplerv2_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rs_idx],
                                           op_extra_data->input_rate, op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84201916:	00 f0 30 cf 	push Null;
8420191a:	00 f0 30 cf 	push Null;
8420191e:	09 1c       	pushm <rMAC>;
84201920:	b1 f0 32 88 	rMAC = M[r9 + 200];
84201924:	09 1c       	pushm <rMAC>;
84201926:	b1 f0 91 88 	rMAC = M[r9 + 580];
8420192a:	09 1c       	pushm <rMAC>;
8420192c:	b1 f0 6e 88 	rMAC = M[r9 + 440];
84201930:	09 1c       	pushm <rMAC>;
84201932:	b5 f0 64 88 	r3 = M[r9 + 400];
84201936:	5a d8       	r0 = M[FP + 44];
84201938:	4c d8       	r2 = M[FP + 36];
8420193a:	52 54       	r0 = r0 LSHIFT 2;
8420193c:	23 00       	r1 = r2 + Null;
8420193e:	14 01       	r2 = r0 + r2;
84201940:	4a 08       	r0 = r7 + Null;
84201942:	ff fd ab f0 	call (m) 0x16fb2;
84201946:	31 e3 
84201948:	7a 4c       	SP = SP + -24;
8420194a:	17 00       	r5 = r0 + Null;
        if(!op_ptr)
8420194c:	32 61       	if EQ jump (m) Lc_build_spkr_graph_27;

8420194e <Lc_build_spkr_graph_55>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
8420194e:	3b 00       	r1 = r5 + Null;
84201950:	52 08       	r0 = r8 + Null;
84201952:	ff fd aa f0 	call (m) 0x16e96;
84201956:	25 ea 

        /* Move next input to output of resampler */
        intern_ins_idx = intern_rs_idx;
84201958:	59 d8       	rMAC = M[FP + 44];
8420195a:	69 de       	M[FP + 52] = rMAC;

8420195c <Lc_build_spkr_graph_56>:
    /* This is the point where we insert possible sidetone
     * mix operator, store both the operator and the input
     * buffer index for the operator. Sidetone mixing
     * will always be done in-place.
     */
    op_extra_data->spkr_st_point_op = op_ptr;
8420195c:	b7 f0 a9 8e 	M[r9 + 676] = r5;
    op_extra_data->spkr_stmix_in_idx = intern_ins_idx;
84201960:	69 d8       	rMAC = M[FP + 52];
84201962:	b1 f0 a3 8e 	M[r9 + 652] = rMAC;

    /* Optional section for SW rate matching */
    if(intern_rm_idx != 0)
84201966:	61 d8       	rMAC = M[FP + 48];
84201968:	48 60       	if EQ jump (m) Lc_build_spkr_graph_67;

8420196a <Lc_build_spkr_graph_57>:
    {
        int shift_amount =  op_extra_data->spkr_shift;
8420196a:	b1 f0 74 88 	rMAC = M[r9 + 464];

        if(intern_rm_idx!=out_indx)
8420196e:	63 d8       	r1 = M[FP + 48];
84201970:	52 d8       	r0 = M[FP + 40];
84201972:	98 04       	Null = r1 - r0;
84201974:	1c 60       	if EQ jump (m) Lc_build_spkr_graph_65;

84201976 <Lc_build_spkr_graph_58>:
        {
            /* Use alternate set of scratch buffers from resampler */
            unsigned scratch_offset = (intern_rs_idx!=0)? 0 : num_inputs;
84201976:	59 d8       	rMAC = M[FP + 44];
84201978:	03 60       	if EQ jump (m) Lc_build_spkr_graph_60;

8420197a <Lc_build_spkr_graph_59>:
8420197a:	02 00       	r0 = Null + Null;
8420197c:	02 6e       	jump (m) Lc_build_spkr_graph_61;

8420197e <Lc_build_spkr_graph_60>:
8420197e:	4a 08       	r0 = r7 + Null;

84201980 <Lc_build_spkr_graph_61>:

            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
84201980:	06 00       	r4 = Null + Null;
84201982:	52 54       	r0 = r0 LSHIFT 2;
84201984:	59 08       	rMAC = r9 + Null;
84201986:	51 00       	rMAC = r0 + rMAC;
84201988:	17 f0 84 20 	r5 = rMAC + 132;

8420198c <Lc_build_spkr_graph_62>:
8420198c:	9f f6 00 c2 	Null = r4 - r7;
84201990:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_64;

84201994 <Lc_build_spkr_graph_63>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,op_extra_data->scratch_bufs[scratch_offset+i]);
84201994:	3d e8       	r3 = M[r5 + Null];
84201996:	61 d8       	rMAC = M[FP + 48];
84201998:	0c 00       	r2 = rMAC + Null;
8420199a:	73 00       	r1 = r4 + rMAC;
8420199c:	52 08       	r0 = r8 + Null;
8420199e:	ff fd aa f0 	call (m) 0x16e66;
842019a2:	29 e6 
        {
            /* Use alternate set of scratch buffers from resampler */
            unsigned scratch_offset = (intern_rs_idx!=0)? 0 : num_inputs;

            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
842019a4:	76 20       	r4 = r4 + 1;
842019a6:	3f 21       	r5 = r5 + 4;
842019a8:	f2 6f       	jump (m) Lc_build_spkr_graph_62;

842019aa <Lc_build_spkr_graph_64>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,op_extra_data->scratch_bufs[scratch_offset+i]);
            }
            shift_amount=0;
842019aa:	01 00       	rMAC = Null + Null;

842019ac <Lc_build_spkr_graph_65>:
        }

        /*  SW rate adjustment per channel [num_inputs] */
        op_ptr = create_sw_rate_adj_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rm_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->spkr_rate_adjustment,shift_amount);
842019ac:	09 1c       	pushm <rMAC>;
842019ae:	01 f0 c0 ff 	push r9 + 448;
842019b2:	1b cf 
842019b4:	85 2a       	r3 = Null + 26;
842019b6:	62 d8       	r0 = M[FP + 48];
842019b8:	4c d8       	r2 = M[FP + 36];
842019ba:	52 54       	r0 = r0 LSHIFT 2;
842019bc:	23 00       	r1 = r2 + Null;
842019be:	14 01       	r2 = r0 + r2;
842019c0:	6a d8       	r0 = M[FP + 52];
842019c2:	52 54       	r0 = r0 LSHIFT 2;
842019c4:	d3 00       	r1 = r0 + r1;
842019c6:	4a 08       	r0 = r7 + Null;
842019c8:	ff fd a9 f0 	call (m) 0x16bea;
842019cc:	23 e1 
842019ce:	7e 4c       	SP = SP + -8;
842019d0:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842019d2:	f0 ff df eb 	if EQ jump (m) Lc_build_spkr_graph_27;

842019d6 <Lc_build_spkr_graph_66>:
        {
            goto aFailed;
        }

        op_extra_data->spkr_sw_rateadj_op=op_ptr;
842019d6:	b6 f0 7e 8e 	M[r9 + 504] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
842019da:	03 00       	r1 = Null + Null;
842019dc:	b0 f0 71 88 	Null = M[r9 + 452];
842019e0:	20 f0 43 ce 	if EQ r1 = Null + 1;
842019e4:	ff fd a9 f0 	call (m) 0x16c96;
842019e8:	33 e5 

        cbops_append_operator_to_graph(spkr_graph,op_ptr);
842019ea:	33 00       	r1 = r4 + Null;
842019ec:	52 08       	r0 = r8 + Null;
842019ee:	ff fd aa f0 	call (m) 0x16e96;
842019f2:	29 e5 

        /* Move next input to output of ratematch */
        intern_ins_idx = intern_rm_idx;
842019f4:	61 d8       	rMAC = M[FP + 48];
842019f6:	69 de       	M[FP + 52] = rMAC;

842019f8 <Lc_build_spkr_graph_67>:
    }


    /* Did previous operator terminate route? */
    if(intern_ins_idx!=out_indx)
842019f8:	6a d8       	r0 = M[FP + 52];
842019fa:	51 d8       	rMAC = M[FP + 40];
842019fc:	50 04       	Null = r0 - rMAC;
842019fe:	29 60       	if EQ jump (m) Lc_build_spkr_graph_74;

84201a00 <Lc_build_spkr_graph_68>:
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
84201a00:	41 d8       	rMAC = M[FP + 32];
84201a02:	1f f9 00 c2 	Null = r7 - rMAC;
84201a06:	02 f0 9f e0 	if C jump (m) Lc_build_spkr_graph_72;

84201a0a <Lc_build_spkr_graph_69>:
        {
            for(i=0; i < num_spkrs; i++)
84201a0a:	01 00       	rMAC = Null + Null;
84201a0c:	72 d8       	r0 = M[FP + 56];
84201a0e:	49 d8       	rMAC = M[FP + 36];
84201a10:	52 54       	r0 = r0 LSHIFT 2;
84201a12:	51 00       	rMAC = r0 + rMAC;
84201a14:	42 d8       	r0 = M[FP + 32];
84201a16:	14 09       	r10 = r0 + Null;
84201a18:	04 4c       	do (m) Lc__loop0;

84201a1a <Lc_build_spkr_graph_70>:
            {
                idxs[num_io+i] = intern_ins_idx;
84201a1a:	6a d8       	r0 = M[FP + 52];
84201a1c:	0a ee       	M[rMAC + Null] = r0;
84201a1e:	09 21       	rMAC = rMAC + 4;

84201a20 <Lc__loop0>:
    if(intern_ins_idx!=out_indx)
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
        {
            for(i=0; i < num_spkrs; i++)
84201a20:	71 d8       	rMAC = M[FP + 56];
84201a22:	69 de       	M[FP + 52] = rMAC;

84201a24 <Lc_build_spkr_graph_72>:
                idxs[num_io+i] = intern_ins_idx;
            }
            intern_ins_idx = num_io;
        }

        op_ptr = create_shift_op(num_spkrs, &idxs[intern_ins_idx], &idxs[out_indx], op_extra_data->spkr_shift);
84201a24:	b5 f0 74 88 	r3 = M[r9 + 464];
84201a28:	52 d8       	r0 = M[FP + 40];
84201a2a:	4c d8       	r2 = M[FP + 36];
84201a2c:	52 54       	r0 = r0 LSHIFT 2;
84201a2e:	23 00       	r1 = r2 + Null;
84201a30:	14 01       	r2 = r0 + r2;
84201a32:	6a d8       	r0 = M[FP + 52];
84201a34:	52 54       	r0 = r0 LSHIFT 2;
84201a36:	d3 00       	r1 = r0 + r1;
84201a38:	42 d8       	r0 = M[FP + 32];
84201a3a:	ff fd 21 f1 	call (m) 0x25e08;
84201a3e:	2f ee 
        if(!op_ptr)
84201a40:	10 04       	Null = r0 - Null;
84201a42:	f0 ff ef ea 	if EQ jump (m) Lc_build_spkr_graph_27;

84201a46 <Lc_build_spkr_graph_73>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201a46:	13 00       	r1 = r0 + Null;
84201a48:	52 08       	r0 = r8 + Null;
84201a4a:	ff fd aa f0 	call (m) 0x16e96;
84201a4e:	2d e2 

84201a50 <Lc_build_spkr_graph_74>:
    }

    op_extra_data->spkr_rate_adjustment=0;
84201a50:	b0 f0 70 8e 	M[r9 + 448] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84201a54:	b1 f0 6f 88 	rMAC = M[r9 + 444];
84201a58:	88 24       	Null = rMAC - 2;
84201a5a:	f1 ff ab e8 	if NE jump (m) Lc_build_spkr_graph_5;

84201a5e <Lc_build_spkr_graph_75>:
    {
        /* With HW rate adjustmen we always need rate monitor */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, out_indx);
84201a5e:	b2 f0 92 88 	r0 = M[r9 + 584];
84201a62:	53 d8       	r1 = M[FP + 40];
84201a64:	08 f0 35 e6 	call (m) $_create_rate_monitor_operator;
84201a68:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201a6a:	f0 ff c7 ea 	if EQ jump (m) Lc_build_spkr_graph_27;

84201a6e <Lc_build_spkr_graph_76>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
84201a6e:	05 f0 b8 53 	r3 = Null + 3000;
84201a72:	44 20       	r2 = Null + 1;
84201a74:	b3 f0 6e 88 	r1 = M[r9 + 440];
84201a78:	f2 ff 24 ed 	call $_rate_monitor_op_initialise;
84201a7c:	ff ff b3 e8 	jump (m) Lc_build_spkr_graph_8;

84201a80 <Lc_build_spkr_graph_77>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
    return FALSE;
}
84201a80:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201a82:	d8 4c       	rts;

84201a84 <$_validate_channels_and_build>:
 *        paths and rebuild the cbops graphs for each path when needed.
 *
 * \param op_data Pointer to the AEC reference operator data.
 */
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
84201a84:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201a86:	42 de       	M[FP + 32] = r0;
84201a88:	11 00       	rMAC = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201a8a:	0e 99       	r4 = M[rMAC + 48];
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* check changes in speaker, microphone and reference paths */
    bool spkr_changed = aec_reference_update_spkr_channel_status(op_extra_data);
84201a8c:	32 00       	r0 = r4 + Null;
84201a8e:	dc 4e       	call (m) $_aec_reference_update_spkr_channel_status;
84201a90:	10 09       	r6 = r0 + Null;
    bool mic_changed = aec_reference_update_mic_channel_status(op_extra_data);
84201a92:	32 00       	r0 = r4 + Null;
84201a94:	85 4e       	call (m) $_aec_reference_update_mic_channel_status;
84201a96:	17 00       	r5 = r0 + Null;
    bool ref_changed = aec_reference_update_ref_channel_status(op_extra_data);
84201a98:	32 00       	r0 = r4 + Null;
84201a9a:	01 f0 3b e3 	call (m) $_aec_reference_update_ref_channel_status;
84201a9e:	12 09       	r8 = r0 + Null;
    bool interrupts_blocked = FALSE;
84201aa0:	03 09       	r9 = Null + Null;

    bool mic_changed_while_spkr_running = (!spkr_changed) && (op_extra_data->spkr_graph!=NULL) &&
        (mic_changed || ref_changed);
84201aa2:	0f f8 00 c2 	Null = r6 - Null;
84201aa6:	0b 62       	if NE jump (m) Lc_validate_channels_and_build_6;

84201aa8 <Lc_validate_channels_and_build_2>:
84201aa8:	61 f0 72 88 	rMAC = M[r4 + 456];
84201aac:	08 60       	if EQ jump (m) Lc_validate_channels_and_build_6;

84201aae <Lc_validate_channels_and_build_3>:
84201aae:	38 04       	Null = r5 - Null;
84201ab0:	04 62       	if NE jump (m) Lc_validate_channels_and_build_5;

84201ab2 <Lc_validate_channels_and_build_4>:
84201ab2:	0f fa 00 c2 	Null = r8 - Null;
84201ab6:	03 60       	if EQ jump (m) Lc_validate_channels_and_build_6;

84201ab8 <Lc_validate_channels_and_build_5>:
84201ab8:	41 20       	rMAC = Null + 1;
84201aba:	02 6e       	jump (m) Lc_validate_channels_and_build_7;

84201abc <Lc_validate_channels_and_build_6>:
84201abc:	01 00       	rMAC = Null + Null;

84201abe <Lc_validate_channels_and_build_7>:
84201abe:	49 de       	M[FP + 36] = rMAC;

    bool spkr_changed_while_mic_running = (!mic_changed) && (op_extra_data->mic_graph!=NULL) &&
        spkr_changed ;
84201ac0:	38 04       	Null = r5 - Null;
84201ac2:	0a 62       	if NE jump (m) Lc_validate_channels_and_build_10;

84201ac4 <Lc_validate_channels_and_build_8>:
84201ac4:	61 f0 6a 88 	rMAC = M[r4 + 424];
84201ac8:	07 60       	if EQ jump (m) Lc_validate_channels_and_build_10;

84201aca <Lc_validate_channels_and_build_9>:
84201aca:	01 09       	r7 = Null + Null;
84201acc:	0f f8 00 c2 	Null = r6 - Null;
84201ad0:	21 f0 49 ce 	if NE r7 = Null + 1;
84201ad4:	02 6e       	jump (m) Lc_validate_channels_and_build_11;

84201ad6 <Lc_validate_channels_and_build_10>:
84201ad6:	01 09       	r7 = Null + Null;

84201ad8 <Lc_validate_channels_and_build_11>:

    patch_fn_shared(aec_reference);

    /* update sidetone method */
    aec_reference_update_sidetone_method(op_extra_data);
84201ad8:	32 00       	r0 = r4 + Null;
84201ada:	01 f0 35 e3 	call (m) $_aec_reference_update_sidetone_method;

    /* see if graph builds need to be done with
     * interrupts blocked.
     */
    if (opmgr_op_is_running(op_data) &&
        (mic_changed_while_spkr_running || spkr_changed_while_mic_running))
84201ade:	42 d8       	r0 = M[FP + 32];
84201ae0:	08 f0 25 e7 	call (m) $_opmgr_op_is_running;
84201ae4:	10 04       	Null = r0 - Null;
84201ae6:	0a 60       	if EQ jump (m) Lc_validate_channels_and_build_15;

84201ae8 <Lc_validate_channels_and_build_12>:
84201ae8:	49 d8       	rMAC = M[FP + 36];
84201aea:	04 62       	if NE jump (m) Lc_validate_channels_and_build_14;

84201aec <Lc_validate_channels_and_build_13>:
84201aec:	0f f9 00 c2 	Null = r7 - Null;
84201af0:	05 60       	if EQ jump (m) Lc_validate_channels_and_build_15;

84201af2 <Lc_validate_channels_and_build_14>:
        /* if we have a change in mic/ref paths while
         * speaker graph is already running, then we block the
         * interrupts so new additions wont disrupt speaker
         * path.
         */
        LOCK_INTERRUPTS;
84201af2:	ff fd 58 f1 	call (m) 0x2cc9c;
84201af6:	2b ed 
        interrupts_blocked = TRUE;
84201af8:	0b 71       	r9 = Null + 1;

84201afa <Lc_validate_channels_and_build_15>:
    }

    /* rebuild graphs if there is change in
     * speaker or microphone path
     */
    if(!aec_reference_build_graphs(op_extra_data, spkr_changed, mic_changed))
84201afa:	3c 00       	r2 = r5 + Null;
84201afc:	43 08       	r1 = r6 + Null;
84201afe:	32 00       	r0 = r4 + Null;
84201b00:	01 f0 3f e3 	call (m) $_aec_reference_build_graphs;
84201b04:	10 04       	Null = r0 - Null;
84201b06:	41 60       	if EQ jump (m) Lc_validate_channels_and_build_27;

84201b08 <Lc_validate_channels_and_build_16>:
    }

    /* also if there is changes in reference path, then
     * apply that change to speaker graph
     */
    if(ref_changed || spkr_changed)
84201b08:	0f fa 00 c2 	Null = r8 - Null;
84201b0c:	04 62       	if NE jump (m) Lc_validate_channels_and_build_18;

84201b0e <Lc_validate_channels_and_build_17>:
84201b0e:	0f f8 00 c2 	Null = r6 - Null;
84201b12:	0a 60       	if EQ jump (m) Lc_validate_channels_and_build_19;

84201b14 <Lc_validate_channels_and_build_18>:
84201b14:	61 f0 76 88 	rMAC = M[r4 + 472];
84201b18:	13 f2 00 00 	r1 = rMAC AND 0x4000;
84201b1c:	32 00       	r0 = r4 + Null;
84201b1e:	02 f0 3f ea 	call (m) $_aec_reference_spkr_include_ref_path;
84201b22:	10 04       	Null = r0 - Null;
84201b24:	32 60       	if EQ jump (m) Lc_validate_channels_and_build_27;

84201b26 <Lc_validate_channels_and_build_19>:
84201b26:	0f fb 00 c2 	Null = r9 - Null;
84201b2a:	f1 fd 58 f1 	if NE call (m) 0x2ccb8;
84201b2e:	2f ec 
    {
        UNLOCK_INTERRUPTS;
    }

    if(op_extra_data->mic_graph != NULL ||
       op_extra_data->spkr_graph!= NULL)
84201b30:	61 f0 6a 88 	rMAC = M[r4 + 424];
84201b34:	04 62       	if NE jump (m) Lc_validate_channels_and_build_21;

84201b36 <Lc_validate_channels_and_build_20>:
84201b36:	61 f0 72 88 	rMAC = M[r4 + 456];
84201b3a:	16 60       	if EQ jump (m) Lc_validate_channels_and_build_24;

84201b3c <Lc_validate_channels_and_build_21>:
    {
        /* start running the graphs if not already running
         */
        if(op_extra_data->kick_id == TIMER_ID_INVALID)
84201b3c:	60 f0 5d 88 	Null = M[r4 + 372];
84201b40:	11 62       	if NE jump (m) Lc_validate_channels_and_build_23;

84201b42 <Lc_validate_channels_and_build_22>:
        {
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
84201b42:	42 f0 07 f0 	r5 = Null + 69207699;
84201b46:	93 4a 
84201b48:	68 f0 94 88 	r6 = M[r4 + 592];
        INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(hal_get_time(), time_in), TimerEventFunction, data_pointer);
84201b4c:	ff fd 7e f1 	call (m) 0x317e8;
84201b50:	3d e4 
84201b52:	42 0c       	r0 = r6 + r0;
84201b54:	3b 00       	r1 = r5 + Null;
84201b56:	44 d8       	r2 = M[FP + 32];
84201b58:	ff fd 92 f0 	call (m) 0x1402a;
84201b5c:	33 e6 
}
84201b5e:	62 f0 5d 8e 	M[r4 + 372] = r0;

84201b62 <Lc_validate_channels_and_build_23>:
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
    }

    return TRUE;
84201b62:	42 20       	r0 = Null + 1;
84201b64:	1b 6e       	jump (m) Lc_validate_channels_and_build_28;

84201b66 <Lc_validate_channels_and_build_24>:
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
        }
    }
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
84201b66:	06 f0 74 45 	r4 = r4 + 372;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84201b6a:	ff fd 58 f1 	call (m) 0x2cc9c;
84201b6e:	33 e9 
    if (*timer_id != TIMER_ID_INVALID)
84201b70:	32 e8       	r0 = M[r4 + Null];
84201b72:	07 60       	if EQ jump (m) Lc_validate_channels_and_build_26;

84201b74 <Lc_validate_channels_and_build_25>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84201b74:	04 00       	r2 = Null + Null;
84201b76:	03 00       	r1 = Null + Null;
84201b78:	ff fd 93 f0 	call (m) 0x141bc;
84201b7c:	25 e2 
        *timer_id = TIMER_ID_INVALID;
84201b7e:	30 ee       	M[r4 + Null] = Null;

84201b80 <Lc_validate_channels_and_build_26>:
    }
    interrupt_unblock();
84201b80:	ff fd 58 f1 	call (m) 0x2ccb8;
84201b84:	39 e9 
84201b86:	ee 6f       	jump (m) Lc_validate_channels_and_build_23;

84201b88 <Lc_validate_channels_and_build_27>:

  aFailed:
    /* it failed to complete the build for some reason,
     * clean up all the graphs.
     */
    aec_reference_cleanup(op_data);
84201b88:	42 d8       	r0 = M[FP + 32];
84201b8a:	fb ff 2b e6 	call (m) $_aec_reference_cleanup;
84201b8e:	0f fb 00 c2 	Null = r9 - Null;
84201b92:	f1 fd 58 f1 	if NE call (m) 0x2ccb8;
84201b96:	27 e9 
    if(interrupts_blocked)
    {
        UNLOCK_INTERRUPTS;
    }
    return FALSE;
84201b98:	02 00       	r0 = Null + Null;

84201b9a <Lc_validate_channels_and_build_28>:
}
84201b9a:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201b9c:	d8 4c       	rts;

84201b9e <$_aec_reference_update_mic_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_mic_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201b9e:	72 1c       	pushm <FP(=SP), r4, r5>;
    patch_fn_shared(aec_reference);
    unsigned i;
    unsigned mic_channel_status=0;
84201ba0:	03 00       	r1 = Null + Null;
    unsigned number_mics=0;
84201ba2:	04 00       	r2 = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
84201ba4:	20 f0 7b 8e 	M[r0 + 492] = Null;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
84201ba8:	91 88       	rMAC = M[r0 + 8];
84201baa:	2c 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_13;

84201bac <Lc_aec_reference_update_mic_channel_status_2>:
84201bac:	d1 a8       	rMAC = M[r0 + 76];
84201bae:	2a 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_13;

84201bb0 <Lc_aec_reference_update_mic_channel_status_3>:
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201bb0:	01 00       	rMAC = Null + Null;
84201bb2:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_5;

84201bb4 <Lc_aec_reference_update_mic_channel_status_4>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201bb4:	08 25       	Null = rMAC - 4;
84201bb6:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_6;

84201bba <Lc_aec_reference_update_mic_channel_status_5>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201bba:	8d 20       	r3 = rMAC + 2;
        {
            inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201bbc:	6d 54       	r3 = r3 LSHIFT 2;
84201bbe:	55 e9       	r3 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201bc0:	ce 20       	r4 = rMAC + 3;
84201bc2:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_7;

84201bc4 <Lc_aec_reference_update_mic_channel_status_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201bc4:	0d 22       	r3 = rMAC + 8;
84201bc6:	6d 54       	r3 = r3 LSHIFT 2;
84201bc8:	55 e9       	r3 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201bca:	4e 22       	r4 = rMAC + 9;

84201bcc <Lc_aec_reference_update_mic_channel_status_7>:
            outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201bcc:	27 f0 40 20 	r5 = r0 + 64;
84201bd0:	76 54       	r4 = r4 LSHIFT 2;
84201bd2:	be e9       	r4 = M[r5 + r4];

            if(inputBuf && outputBuf)
84201bd4:	28 04       	Null = r3 - Null;
84201bd6:	26 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_16;

84201bd8 <Lc_aec_reference_update_mic_channel_status_8>:
84201bd8:	30 04       	Null = r4 - Null;
84201bda:	26 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201bdc <Lc_aec_reference_update_mic_channel_status_9>:
            {
                number_mics++;
84201bdc:	64 20       	r2 = r2 + 1;

                if(i<4)
84201bde:	08 25       	Null = rMAC - 4;
84201be0:	02 f0 b5 e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_15;

84201be4 <Lc_aec_reference_update_mic_channel_status_10>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
84201be4:	0d 00       	r3 = rMAC + Null;
84201be6:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201bea:	5b 13       	r1 = r1 OR r3;

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201bec:	cd 20       	r3 = rMAC + 3;

84201bee <Lc_aec_reference_update_mic_channel_status_11>:
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
84201bee:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201bf2:	26 f0 7b 88 	r4 = M[r0 + 492];
84201bf6:	ad 13       	r3 = r3 OR r4;
84201bf8:	25 f0 7b 8e 	M[r0 + 492] = r3;

84201bfc <Lc_aec_reference_update_mic_channel_status_12>:
    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201bfc:	49 20       	rMAC = rMAC + 1;
84201bfe:	08 26       	Null = rMAC - 8;
84201c00:	da 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_4;

84201c02 <Lc_aec_reference_update_mic_channel_status_13>:
            mic_channel_status = 0;
            op_extra_data->source_kicks = 0;
        }
    }

    if((GetMicChannelStatus(op_extra_data)) == mic_channel_status)
84201c02:	21 f0 76 88 	rMAC = M[r0 + 472];
84201c06:	07 f0 15 f8 	r3 = rMAC AND 0xf000f;
84201c0a:	0f 00 
84201c0c:	e8 04       	Null = r3 - r1;
84201c0e:	11 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_18;

84201c10 <Lc_aec_reference_update_mic_channel_status_14>:
    {
        /* No change in the mic path */
        return FALSE;
84201c10:	02 00       	r0 = Null + Null;
84201c12:	18 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_19;

84201c14 <Lc_aec_reference_update_mic_channel_status_15>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
84201c14:	0d 00       	r3 = rMAC + Null;
84201c16:	10 f0 00 f5 	r3 = 0x1000 LSHIFT r3;
84201c1a:	95 ce 
84201c1c:	5b 13       	r1 = r1 OR r3;
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201c1e:	4d 22       	r3 = rMAC + 9;
84201c20:	e7 6f       	jump (m) Lc_aec_reference_update_mic_channel_status_11;

84201c22 <Lc_aec_reference_update_mic_channel_status_16>:
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
            }
            else if(inputBuf || outputBuf)
84201c22:	30 04       	Null = r4 - Null;
84201c24:	ec 61       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_12;

84201c26 <Lc_aec_reference_update_mic_channel_status_17>:
                break;
            }
        }
        if(!all_mic_channels)
        {
            number_mics=0;
84201c26:	04 00       	r2 = Null + Null;
            mic_channel_status = 0;
84201c28:	03 00       	r1 = Null + Null;
            op_extra_data->source_kicks = 0;
84201c2a:	20 f0 7b 8e 	M[r0 + 492] = Null;
84201c2e:	ea 6f       	jump (m) Lc_aec_reference_update_mic_channel_status_13;

84201c30 <Lc_aec_reference_update_mic_channel_status_18>:
        /* No change in the mic path */
        return FALSE;
    }

    /* update number of mics */
    op_extra_data->num_mic_channels = number_mics;
84201c30:	24 f0 78 8e 	M[r0 + 480] = r2;

    /* update mic channel status */
    SetMicChannelStatus(op_extra_data, mic_channel_status);
84201c34:	f8 ff 11 f7 	rMAC = rMAC AND 0xfff0fff0;
84201c38:	f0 1f 
84201c3a:	c9 12       	rMAC = rMAC OR r1;
84201c3c:	21 f0 76 8e 	M[r0 + 472] = rMAC;

    return TRUE;
84201c40:	42 20       	r0 = Null + 1;

84201c42 <Lc_aec_reference_update_mic_channel_status_19>:
}
84201c42:	72 48       	popm <FP, r4, r5>;
84201c44:	d8 4c       	rts;

84201c46 <$_aec_reference_update_spkr_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_spkr_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201c46:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
    unsigned i;
    unsigned spkr_channel_status=0;
84201c48:	03 00       	r1 = Null + Null;
    unsigned number_spkrs=0;
84201c4a:	01 00       	rMAC = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Speakers are connected */
    op_extra_data->sink_kicks   = 0;
84201c4c:	20 f0 7c 8e 	M[r0 + 496] = Null;
    if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1] && op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84201c50:	14 e8       	r2 = M[r0 + Null];
84201c52:	39 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201c54 <Lc_aec_reference_update_spkr_channel_status_2>:
84201c54:	54 a8       	r2 = M[r0 + 68];
84201c56:	37 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201c58 <Lc_aec_reference_update_spkr_channel_status_3>:
    {
        int in_count=1;
84201c58:	45 20       	r3 = Null + 1;
        int out_count=1;
84201c5a:	2e 00       	r4 = r3 + Null;

        /* Master Channel is connected */
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;
84201c5c:	03 28       	r1 = Null + 16;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);
84201c5e:	29 00       	rMAC = r3 + Null;
84201c60:	21 f0 7c 8e 	M[r0 + 496] = rMAC;

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201c64:	04 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_5;

84201c66 <Lc_aec_reference_update_spkr_channel_status_4>:
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201c66:	88 24       	Null = rMAC - 2;
84201c68:	02 f0 8b e0 	if C jump (m) Lc_aec_reference_update_spkr_channel_status_6;

84201c6c <Lc_aec_reference_update_spkr_channel_status_5>:
84201c6c:	47 20       	r5 = Null + 1;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201c6e:	84 20       	r2 = Null + 2;
84201c70:	03 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_7;

84201c72 <Lc_aec_reference_update_spkr_channel_status_6>:
        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201c72:	0f 21       	r5 = rMAC + 4;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201c74:	4c 21       	r2 = rMAC + 5;

84201c76 <Lc_aec_reference_update_spkr_channel_status_7>:
84201c76:	28 f0 40 20 	r6 = r0 + 64;
84201c7a:	64 54       	r2 = r2 LSHIFT 2;
84201c7c:	84 f0 04 e8 	r2 = M[r6 + r2];
            inputBuf  = op_extra_data->input_stream[sink_idx];
84201c80:	01 f7 d8 c8 	r6 = r5 LSHIFT 2;

            if(inputBuf || outputBuf)
84201c84:	28 f0 08 e8 	r6 = M[r0 + r6];
84201c88:	03 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_9;

84201c8a <Lc_aec_reference_update_spkr_channel_status_8>:
84201c8a:	20 04       	Null = r2 - Null;
84201c8c:	15 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201c8e <Lc_aec_reference_update_spkr_channel_status_9>:
            {
                spkr_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_SPKR_1<<i);
84201c8e:	09 09       	r7 = rMAC + Null;
84201c90:	08 f9 99 ce 	r7 = 0x10 LSHIFT r7;
84201c94:	00 f9 73 c8 	r1 = r1 OR r7;

                if(inputBuf)
84201c98:	0f f8 00 c2 	Null = r6 - Null;
84201c9c:	23 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_18;

84201c9e <Lc_aec_reference_update_spkr_channel_status_10>:
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
84201c9e:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
84201ca2:	28 f0 7c 88 	r6 = M[r0 + 496];
84201ca6:	00 f8 77 c8 	r5 = r5 OR r6;
84201caa:	27 f0 7c 8e 	M[r0 + 496] = r5;
                    in_count++;
84201cae:	6d 20       	r3 = r3 + 1;

84201cb0 <Lc_aec_reference_update_spkr_channel_status_11>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
                }

                if(outputBuf)
84201cb0:	20 04       	Null = r2 - Null;
84201cb2:	1c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_20;

84201cb4 <Lc_aec_reference_update_spkr_channel_status_12>:
                {
                    out_count++;
84201cb4:	76 20       	r4 = r4 + 1;

84201cb6 <Lc_aec_reference_update_spkr_channel_status_13>:
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201cb6:	49 20       	rMAC = rMAC + 1;
84201cb8:	08 26       	Null = rMAC - 8;
84201cba:	d6 65       	if NC jump (m) Lc_aec_reference_update_spkr_channel_status_4;

84201cbc <Lc_aec_reference_update_spkr_channel_status_14>:
                    return(FALSE);
                }
            }
        }
        /* Verify complete channel setup */
        number_spkrs = out_count;
84201cbc:	31 00       	rMAC = r4 + Null;
        if(in_count==out_count)
84201cbe:	a8 05       	Null = r3 - r4;
84201cc0:	18 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_21;

84201cc2 <Lc_aec_reference_update_spkr_channel_status_15>:
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
84201cc2:	db cd       	r1 = r1 OR 0x1000;

84201cc4 <Lc_aec_reference_update_spkr_channel_status_16>:
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
        }
    }

    if((GetSpkrChannelStatus(op_extra_data)) == spkr_channel_status)
84201cc4:	24 f0 76 88 	r2 = M[r0 + 472];
84201cc8:	45 f1 f0 1f 	r3 = r2 AND 0x3ff0;
84201ccc:	e8 04       	Null = r3 - r1;
84201cce:	0c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201cd0 <Lc_aec_reference_update_spkr_channel_status_17>:
        /* No change in the speaker channel status */
        return FALSE;
    }

    /* update number of speaker channels */
    op_extra_data->num_spkr_channels = number_spkrs;
84201cd0:	21 f0 77 8e 	M[r0 + 476] = rMAC;

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
84201cd4:	41 fe 0f 00 	rMAC = r2 AND 0xffffc00f;
84201cd8:	c9 12       	rMAC = rMAC OR r1;
84201cda:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201cde:	42 20       	r0 = Null + 1;
84201ce0:	18 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201ce2 <Lc_aec_reference_update_spkr_channel_status_18>:
                if(inputBuf)
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
                    in_count++;
                }
                else if(in_count>1)
84201ce2:	68 24       	Null = r3 - 1;
84201ce4:	e6 6d       	if LE jump (m) Lc_aec_reference_update_spkr_channel_status_11;

84201ce6 <Lc_aec_reference_update_spkr_channel_status_19>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
84201ce6:	02 00       	r0 = Null + Null;
84201ce8:	14 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201cea <Lc_aec_reference_update_spkr_channel_status_20>:

                if(outputBuf)
                {
                    out_count++;
                }
                else if(out_count>1)
84201cea:	70 24       	Null = r4 - 1;
84201cec:	fd 6b       	if GT jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201cee <Lc_22>:
84201cee:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201cf0 <Lc_aec_reference_update_spkr_channel_status_21>:
        if(in_count==out_count)
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
        }
        else if(out_count==1)
84201cf0:	70 24       	Null = r4 - 1;
84201cf2:	06 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_23;

84201cf4 <Lc_aec_reference_update_spkr_channel_status_22>:
        {
            /* Mono Output.  Mix inputs */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX;
84201cf4:	20 f0 00 f3 	r1 = r1 OR 0x2000;
84201cf8:	53 d8 
            number_spkrs = in_count;
84201cfa:	29 00       	rMAC = r3 + Null;
84201cfc:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201cfe <Lc_aec_reference_update_spkr_channel_status_23>:
        }
        else
        {
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
84201cfe:	68 24       	Null = r3 - 1;
84201d00:	e2 61       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201d02 <Lc_aec_reference_update_spkr_channel_status_24>:
84201d02:	03 f0 05 4a 	r1 = Null + 1541;
84201d06:	02 f0 13 60 	r0 = Null + 4115;
84201d0a:	ff fd 91 f0 	call (m) 0x13f12;
84201d0e:	29 e0 

84201d10 <Lc_aec_reference_update_spkr_channel_status_25>:

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
    return TRUE;

}
84201d10:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201d12:	d8 4c       	rts;

84201d14 <$_aec_reference_update_ref_channel_status>:
 *         insertion/deletion of the reference sub-path into/from speaker graph.
 */
bool aec_reference_update_ref_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{

    unsigned ref_channel_status = 0;
84201d14:	01 00       	rMAC = Null + Null;
    patch_fn_shared(aec_reference);

    /* Check AEC reference */
    if(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL] && (op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1))
84201d16:	13 a8       	r1 = M[r0 + 64];
84201d18:	0c 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201d1a <Lc_aec_reference_update_ref_channel_status_2>:
84201d1a:	23 f0 76 88 	r1 = M[r0 + 472];
84201d1e:	1b c0       	r1 = r1 AND 0x1;
84201d20:	08 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201d22 <Lc_aec_reference_update_ref_channel_status_3>:
    {
        op_extra_data->source_kicks |= 1<<AEC_REF_REFERENCE_TERMINAL;
84201d22:	21 f0 7b 88 	rMAC = M[r0 + 492];
84201d26:	09 c8       	rMAC = rMAC OR 0x1;
84201d28:	21 f0 7b 8e 	M[r0 + 492] = rMAC;
        ref_channel_status = AEC_REFERENCE_CONSTANT_CONN_TYPE_REF;
84201d2c:	21 f0 00 40 	rMAC = Null + 16384;

84201d30 <Lc_aec_reference_update_ref_channel_status_4>:
    }

    if(ref_channel_status == (GetRefChannelStatus(op_extra_data)))
84201d30:	23 f0 76 88 	r1 = M[r0 + 472];
84201d34:	34 f2 00 00 	r2 = r1 AND 0x4000;
84201d38:	08 05       	Null = rMAC - r2;
84201d3a:	03 62       	if NE jump (m) Lc_aec_reference_update_ref_channel_status_6;

84201d3c <Lc_aec_reference_update_ref_channel_status_5>:
    {
        /* No change in reference path */
        return FALSE;
84201d3c:	02 00       	r0 = Null + Null;
84201d3e:	07 6e       	jump (m) Lc_aec_reference_update_ref_channel_status_7;

84201d40 <Lc_aec_reference_update_ref_channel_status_6>:
    }

    /* reference path has changed, update
     * channel status.
     */
    SetRefChannelStatus(op_extra_data, ref_channel_status);
84201d40:	33 fd ff 1f 	r1 = r1 AND 0xffffbfff;
84201d44:	c9 12       	rMAC = rMAC OR r1;
84201d46:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201d4a:	42 20       	r0 = Null + 1;

84201d4c <Lc_aec_reference_update_ref_channel_status_7>:
84201d4c:	d8 4c       	rts;

84201d4e <$_aec_reference_update_sidetone_method>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in sidetone mixing method
 */
void aec_reference_update_sidetone_method(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201d4e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201d50:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_SIDETONE_METHOD sidetone_method = AEC_SIDETONE_NOT_REQUIRED;
84201d52:	07 00       	r5 = Null + Null;
    patch_fn_shared(aec_reference);

    /* reset state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84201d54:	f9 ff 37 e3 	call (m) $_aec_reference_update_sidetone_status;

    /* If the config needs sidetone, decide which method it should use */
    if(op_extra_data->using_sidetone == USE_SIDETONE_FLAG)
84201d58:	61 f0 7a 88 	rMAC = M[r4 + 488];
84201d5c:	c8 24       	Null = rMAC - 3;
84201d5e:	0c 62       	if NE jump (m) Lc_aec_reference_update_sidetone_method_5;

84201d60 <Lc_aec_reference_update_sidetone_method_2>:
    {
        if(op_extra_data->hw_sidetone_available)
84201d60:	60 f0 9b 88 	Null = M[r4 + 620];
84201d64:	03 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_method_4;

84201d66 <Lc_aec_reference_update_sidetone_method_3>:
        {
            /* if the config can have sidetone mixing in Hw then use that method */
            sidetone_method = AEC_SIDETONE_IN_HW;
84201d66:	47 20       	r5 = Null + 1;
84201d68:	07 6e       	jump (m) Lc_aec_reference_update_sidetone_method_5;

84201d6a <Lc_aec_reference_update_sidetone_method_4>:
        {
            /* HW side tone isn't supported, and speaker and mic are
             * running at high task period, use separate graph for sidetone
             * mixing which will run at decimated task period.
             */
            sidetone_method = AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH;
84201d6a:	61 f0 97 88 	rMAC = M[r4 + 604];
84201d6e:	c7 20       	r5 = Null + 3;
84201d70:	48 24       	Null = rMAC - 1;
84201d72:	a9 f0 47 ce 	if LS r5 = Null + 2;

84201d76 <Lc_aec_reference_update_sidetone_method_5>:
            sidetone_method = AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH;
        }
    }

    /* update sidetone mixing method */
    op_extra_data->sidetone_method = sidetone_method;
84201d76:	67 f0 70 9a 	MB[r4 + 624] = r5;

84201d7a <Lc_aec_reference_update_sidetone_method_6>:

}
84201d7a:	f2 48       	popm <FP, r4, r5, rLink>;
84201d7c:	d8 4c       	rts;

84201d7e <$_aec_reference_build_graphs>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_build_graphs(AEC_REFERENCE_OP_DATA *op_extra_data, bool spkr_changed, bool mic_changed)
{
84201d7e:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201d80:	16 00       	r4 = r0 + Null;
84201d82:	44 de       	M[FP + 32] = r2;
84201d84:	1b 09       	r9 = r1 + Null;
    unsigned max_sample_rate;

    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
84201d86:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_3;

84201d88 <Lc_aec_reference_build_graphs_2>:
84201d88:	41 d8       	rMAC = M[FP + 32];
84201d8a:	70 60       	if EQ jump (m) Lc_aec_reference_build_graphs_21;

84201d8c <Lc_aec_reference_build_graphs_3>:
    {
        return TRUE;
    }

    max_sample_rate = op_extra_data->mic_rate;
84201d8c:	62 f0 66 88 	r0 = M[r4 + 408];
    max_sample_rate = MAX(max_sample_rate, op_extra_data->spkr_rate);
84201d90:	61 f0 6e 88 	rMAC = M[r4 + 440];
84201d94:	50 04       	Null = r0 - rMAC;
84201d96:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_5;

84201d9a <Lc_aec_reference_build_graphs_4>:
84201d9a:	0a 00       	r0 = rMAC + Null;

84201d9c <Lc_aec_reference_build_graphs_5>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->input_rate);
84201d9c:	61 f0 64 88 	rMAC = M[r4 + 400];
84201da0:	50 04       	Null = r0 - rMAC;
84201da2:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_7;

84201da6 <Lc_aec_reference_build_graphs_6>:
84201da6:	0a 00       	r0 = rMAC + Null;

84201da8 <Lc_aec_reference_build_graphs_7>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->output_rate);
84201da8:	61 f0 65 88 	rMAC = M[r4 + 404];
84201dac:	50 04       	Null = r0 - rMAC;
84201dae:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_9;

84201db2 <Lc_aec_reference_build_graphs_8>:
84201db2:	0a 00       	r0 = rMAC + Null;

84201db4 <Lc_aec_reference_build_graphs_9>:
    op_extra_data->max_io_rate = max_sample_rate;
84201db4:	62 f0 95 8e 	M[r4 + 596] = r0;

    /* 1ms more than a task period for max sample rate in all corners,
     * few samples more for considering resampling extra outputs.
     */
    size = frac_mult(max_sample_rate, op_extra_data->task_period_frac) + 4;
84201db8:	63 f0 93 88 	r1 = M[r4 + 588];
84201dbc:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201dc0:	29 f0 04 20 	r7 = r0 + 4;

    /* Min size, was constant size of 100 words before introducing,
     * configurable task period, don't go below that tested value.
     */
    size = MAX(size, 100);
84201dc4:	90 f0 64 24 	Null = r7 - 100;
84201dc8:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_build_graphs_11;

84201dcc <Lc_aec_reference_build_graphs_10>:
84201dcc:	09 f0 64 40 	r7 = Null + 100;

84201dd0 <Lc_aec_reference_build_graphs_11>:

    /* allocate buffer needed for resampler */
    if(op_extra_data->resampler_temp_buffer == NULL)
84201dd0:	61 f0 32 88 	rMAC = M[r4 + 200];
84201dd4:	57 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201dd6 <Lc_aec_reference_build_graphs_12>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);
84201dd6:	62 f0 91 88 	r0 = M[r4 + 580];
84201dda:	4a 62       	if NE jump (m) Lc_aec_reference_build_graphs_22;

84201ddc <Lc_aec_reference_build_graphs_13>:
84201ddc:	03 f0 98 50 	r1 = Null + 2200;
84201de0:	02 f0 13 60 	r0 = Null + 4115;
84201de4:	ff fd 90 f0 	call (m) 0x13f12;
84201de8:	2f e9 
84201dea:	6e 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201dec <Lc_aec_reference_build_graphs_14>:
        }
    }

    /** Setup Latency Control */
    {
    	unsigned jitter = frac_mult(op_extra_data->output_rate,op_extra_data->task_period_frac);
84201dec:	62 f0 65 88 	r0 = M[r4 + 404];
84201df0:	63 f0 93 88 	r1 = M[r4 + 588];
84201df4:	00 f3 72 c9 	r0 = r0 * r1 (frac);

	    op_extra_data->sync_block.jitter     = 	jitter + (jitter>>1);				/* 1.5 times task period */
84201df8:	13 50       	r1 = r0 LSHIFT -1;
84201dfa:	99 00       	rMAC = r1 + r0;
84201dfc:	61 f0 85 8e 	M[r4 + 532] = rMAC;
	    op_extra_data->sync_block.ref_delay  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.001)); 	 /* 1.0 msec */
84201e00:	62 f0 65 88 	r0 = M[r4 + 404];
84201e04:	02 f0 63 f0 	r1 = Null + 2147483;
84201e08:	9b 48 
84201e0a:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201e0e:	62 f0 8a 8e 	M[r4 + 552] = r0;
	    op_extra_data->sync_block.block_sync = 0;
84201e12:	60 f0 87 8e 	M[r4 + 540] = Null;
	    op_extra_data->sync_block.rm_adjustment = 0;
84201e16:	60 f0 8c 8e 	M[r4 + 560] = Null;
        op_extra_data->sync_block.frm_count = 0;
84201e1a:	60 f0 8b 8e 	M[r4 + 556] = Null;
    }

    if(spkr_changed)
84201e1e:	0f fb 00 c2 	Null = r9 - Null;
84201e22:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_16;

84201e24 <Lc_aec_reference_build_graphs_15>:
    {
        /* any change in main speaker path will cause full
         * rebuild of every thing from scratch
         */
        aec_reference_cleanup_spkr_graph(op_extra_data);
84201e24:	32 00       	r0 = r4 + Null;
84201e26:	01 f0 21 e0 	call (m) $_aec_reference_cleanup_spkr_graph;
        /* rebuild speaker graph */
        if(!build_spkr_graph(op_extra_data))
84201e2a:	32 00       	r0 = r4 + Null;
84201e2c:	fc ff 2f e1 	call (m) $_build_spkr_graph;
84201e30:	10 04       	Null = r0 - Null;
84201e32:	26 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201e34 <Lc_aec_reference_build_graphs_16>:
        {
            return FALSE;
        }
    }

    if(mic_changed)
84201e34:	41 d8       	rMAC = M[FP + 32];
84201e36:	12 60       	if EQ jump (m) Lc_aec_reference_build_graphs_19;

84201e38 <Lc_aec_reference_build_graphs_17>:
    {
        /* if only mic has changed, then only mic graph will be rebuilt */
        aec_reference_cleanup_mic_graph(op_extra_data);
84201e38:	32 00       	r0 = r4 + Null;
84201e3a:	9a 4e       	call (m) $_aec_reference_cleanup_mic_graph;

        /* mic graph is rebuilt if there is a change
         * in either mic path or speaker path */
        if(!build_mic_graph(op_extra_data))
84201e3c:	32 00       	r0 = r4 + Null;
84201e3e:	fa ff 29 e1 	call (m) $_build_mic_graph;
84201e42:	10 04       	Null = r0 - Null;
84201e44:	1d 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201e46 <Lc_aec_reference_build_graphs_18>:
            return FALSE;
        }

        /* update speaker graph to include sidetone mix if required */
        if(!aec_reference_spkr_include_sidetone(
               op_extra_data, op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH))
84201e46:	61 f0 70 90 	rMAC = MBS[r4 + 624];
84201e4a:	03 00       	r1 = Null + Null;
84201e4c:	88 24       	Null = rMAC - 2;
84201e4e:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201e52:	32 00       	r0 = r4 + Null;
84201e54:	3b 4e       	call (m) $_aec_reference_spkr_include_sidetone;
84201e56:	10 04       	Null = r0 - Null;
84201e58:	13 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201e5a <Lc_aec_reference_build_graphs_19>:
        }
    }

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* build separate sidetone graph if required */
    if(!build_sidetone_graph(op_extra_data))
84201e5a:	32 00       	r0 = r4 + Null;
84201e5c:	02 f0 39 e8 	call (m) $_build_sidetone_graph;
84201e60:	10 04       	Null = r0 - Null;
84201e62:	0e 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201e64 <Lc_aec_reference_build_graphs_20>:
        return FALSE;
    }
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;
84201e64:	41 20       	rMAC = Null + 1;
84201e66:	61 f0 5c 8e 	M[r4 + 368] = rMAC;

84201e6a <Lc_aec_reference_build_graphs_21>:
    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
    {
        return TRUE;
84201e6a:	42 20       	r0 = Null + 1;
84201e6c:	2d 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201e6e <Lc_aec_reference_build_graphs_22>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);

        op_extra_data->resampler_temp_buffer =
            (unsigned*)xzpmalloc(op_extra_data->resampler_temp_buffer_size*sizeof(unsigned));
84201e6e:	c3 20       	r1 = Null + 3;
84201e70:	52 54       	r0 = r0 LSHIFT 2;
84201e72:	ff fd 18 f0 	call (m) 0x4f2a;
84201e76:	39 e5 
        if(op_extra_data->resampler_temp_buffer == NULL)
84201e78:	62 f0 32 8e 	M[r4 + 200] = r0;
84201e7c:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201e7e <Lc_aec_reference_build_graphs_23>:
        {
            return FALSE;
84201e7e:	02 00       	r0 = Null + Null;
84201e80:	23 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201e82 <Lc_aec_reference_build_graphs_24>:

    /* get the number of required scratch buffers based
     * on the number of speakers and mics that we have.
     */
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;
84201e82:	61 f0 77 88 	rMAC = M[r4 + 476];
84201e86:	62 f0 78 88 	r0 = M[r4 + 480];
84201e8a:	88 04       	Null = rMAC - r0;
84201e8c:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_26;

84201e90 <Lc_aec_reference_build_graphs_25>:
84201e90:	02 6e       	jump (m) Lc_aec_reference_build_graphs_27;

84201e92 <Lc_aec_reference_build_graphs_26>:
84201e92:	0a 00       	r0 = rMAC + Null;

84201e94 <Lc_aec_reference_build_graphs_27>:
84201e94:	00 f2 da d8 	r8 = r0 LSHIFT 1;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201e98:	07 00       	r5 = Null + Null;
84201e9a:	68 f0 84 20 	r6 = r4 + 132;

84201e9e <Lc_aec_reference_build_graphs_28>:
84201e9e:	af f7 00 c2 	Null = r5 - r8;
84201ea2:	f2 ff cb ee 	if C jump (m) Lc_aec_reference_build_graphs_14;

84201ea6 <Lc_aec_reference_build_graphs_29>:
    {
        if(NULL == op_extra_data->scratch_bufs[i])
84201ea6:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201eaa:	0b 62       	if NE jump (m) Lc_aec_reference_build_graphs_31;

84201eac <Lc_aec_reference_build_graphs_30>:
        {
            op_extra_data->scratch_bufs[i] = cbuffer_create_with_malloc_fast(size, BUF_DESC_SW_BUFFER);
84201eac:	03 00       	r1 = Null + Null;
84201eae:	4a 08       	r0 = r7 + Null;
84201eb0:	ff fd 84 f0 	call (m) 0x1279c;
84201eb4:	2d e7 
84201eb6:	82 f0 00 ee 	M[r6 + Null] = r0;
            if(!op_extra_data->scratch_bufs[i])
84201eba:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201ebe:	e0 61       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201ec0 <Lc_aec_reference_build_graphs_31>:
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201ec0:	7f 20       	r5 = r5 + 1;
84201ec2:	20 75       	r6 = r6 + 4;
84201ec4:	ed 6f       	jump (m) Lc_aec_reference_build_graphs_28;

84201ec6 <Lc_aec_reference_build_graphs_32>:

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;

    return TRUE;
}
84201ec6:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201ec8:	d8 4c       	rts;

84201eca <$_aec_reference_spkr_include_sidetone>:
 * \brief updates speaker graph to include/exclude side tone mixing
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_spkr_include_sidetone(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_sidetone)
{
84201eca:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201ecc:	16 00       	r4 = r0 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
    cbops_op    *op_ptr;

    /* we need to have a speaker graph */
    if(NULL == op_extra_data->spkr_graph)
84201ece:	67 f0 72 88 	r5 = M[r4 + 456];
84201ed2:	19 62       	if NE jump (m) Lc_aec_reference_spkr_include_sidetone_6;

84201ed4 <Lc_aec_reference_spkr_include_sidetone_2>:
    {
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
84201ed4:	60 f0 9f 88 	Null = M[r4 + 636];
84201ed8:	14 60       	if EQ jump (m) Lc_aec_reference_spkr_include_sidetone_5;

84201eda <Lc_aec_reference_spkr_include_sidetone_3>:
84201eda:	03 f0 e8 4a 	r1 = Null + 1768;
84201ede:	02 f0 13 60 	r0 = Null + 4115;
84201ee2:	ff fd 90 f0 	call (m) 0x13f12;
84201ee6:	31 e1 
84201ee8:	41 6e       	jump (m) Lc_aec_reference_spkr_include_sidetone_11;

84201eea <Lc_aec_reference_spkr_include_sidetone_4>:
        {
            return FALSE;
        }

        /* insert sidetone mix operator into speaker graph */
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, op_extra_data->spkr_st_point_op);
84201eea:	64 f0 a9 88 	r2 = M[r4 + 676];
84201eee:	43 08       	r1 = r6 + Null;
84201ef0:	3a 00       	r0 = r5 + Null;
84201ef2:	05 f0 27 ef 	call (m) $_cbops_insert_operator_into_graph;

        /* save the sidetone mix operator */
        op_extra_data->spkr_stmix_op = op_ptr;
84201ef6:	68 f0 ab 8e 	M[r4 + 684] = r6;

        /* now speaker graph has sidetone mix operator */
        op_extra_data->spkr_sidetone_active = TRUE;
84201efa:	41 20       	rMAC = Null + 1;
84201efc:	61 f0 9f 8e 	M[r4 + 636] = rMAC;

84201f00 <Lc_aec_reference_spkr_include_sidetone_5>:
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
        return TRUE;
84201f00:	42 20       	r0 = Null + 1;
84201f02:	34 6e       	jump (m) Lc_aec_reference_spkr_include_sidetone_11;

84201f04 <Lc_aec_reference_spkr_include_sidetone_6>:
    }

    if(!include_sidetone == !op_extra_data->spkr_sidetone_active)
84201f04:	01 00       	rMAC = Null + Null;
84201f06:	18 04       	Null = r1 - Null;
84201f08:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84201f0c:	02 00       	r0 = Null + Null;
84201f0e:	60 f0 9f 88 	Null = M[r4 + 636];
84201f12:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201f16:	88 04       	Null = rMAC - r0;
84201f18:	f4 61       	if EQ jump (m) Lc_aec_reference_spkr_include_sidetone_5;

84201f1a <Lc_aec_reference_spkr_include_sidetone_7>:
         * as current state.
         */
        return TRUE;
    }

    if(include_sidetone)
84201f1a:	18 04       	Null = r1 - Null;
84201f1c:	18 60       	if EQ jump (m) Lc_aec_reference_spkr_include_sidetone_10;

84201f1e <Lc_aec_reference_spkr_include_sidetone_8>:
    {
        /* Add sidetone mixer to resampler section,  Master channel only */
        cbops_set_input_io_buffer(spkr_graph,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->sidetone_buf);
84201f1e:	63 f0 a5 88 	r1 = M[r4 + 660];
84201f22:	65 f0 31 88 	r3 = M[r4 + 196];
84201f26:	1c 00       	r2 = r1 + Null;
84201f28:	3a 00       	r0 = r5 + Null;
84201f2a:	ff fd a7 f0 	call (m) 0x16e02;
84201f2e:	39 e6 
         * it is as per multi-channel model, but only ever works on one single channel
         */
        op_ptr = create_sidetone_mix_op(op_extra_data->spkr_stmix_in_idx,
                                        op_extra_data->spkr_stmix_in_idx,
                                        op_extra_data->spkr_st_in_idx,
                                        op_extra_data->spkr_out_threshold);
84201f30:	62 f0 a3 88 	r0 = M[r4 + 652];
84201f34:	65 f0 b0 88 	r3 = M[r4 + 704];
84201f38:	64 f0 a5 88 	r2 = M[r4 + 660];
84201f3c:	13 00       	r1 = r0 + Null;
84201f3e:	ff fd 4f f1 	call (m) 0x2bd4a;
84201f42:	2d e0 
84201f44:	10 09       	r6 = r0 + Null;
        if(op_ptr == NULL)
84201f46:	d2 63       	if NE jump (m) Lc_aec_reference_spkr_include_sidetone_4;

84201f48 <Lc_aec_reference_spkr_include_sidetone_9>:
        {
            return FALSE;
84201f48:	02 00       	r0 = Null + Null;
84201f4a:	10 6e       	jump (m) Lc_aec_reference_spkr_include_sidetone_11;

84201f4c <Lc_aec_reference_spkr_include_sidetone_10>:
        DEBUG_GRAPHS("AEC REFERENCE: Side tone path added!" );
    }
    else
    {
        /* remove the sidetone mix operator from speaker graph */
        cbops_remove_operator_from_graph(spkr_graph, op_extra_data->spkr_stmix_op);
84201f4c:	63 f0 ab 88 	r1 = M[r4 + 684];
84201f50:	3a 00       	r0 = r5 + Null;
84201f52:	05 f0 39 ea 	call (m) $_cbops_remove_operator_from_graph;
        op_extra_data->spkr_stmix_op = NULL;
84201f56:	60 f0 ab 8e 	M[r4 + 684] = Null;

        /* also tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(spkr_graph, op_extra_data->spkr_st_in_idx);
84201f5a:	63 f0 a5 88 	r1 = M[r4 + 660];
84201f5e:	3a 00       	r0 = r5 + Null;
84201f60:	05 f0 37 ec 	call (m) $_cbops_unset_buffer;

        /* speaker graph no longer has sidetone mix operator*/
        op_extra_data->spkr_sidetone_active = FALSE;
84201f64:	60 f0 9f 8e 	M[r4 + 636] = Null;
84201f68:	cc 6f       	jump (m) Lc_aec_reference_spkr_include_sidetone_5;

84201f6a <Lc_aec_reference_spkr_include_sidetone_11>:

        DEBUG_GRAPHS("AEC REFERENCE: Side tone path removed!" );
    }

    return TRUE;
}
84201f6a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201f6c:	d8 4c       	rts;

84201f6e <$_aec_reference_cleanup_mic_graph>:
 * \brief clean up mic graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201f6e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201f70:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* Clear links to graphs */
    op_extra_data->mic_rate_monitor_op = NULL;
84201f72:	60 f0 6b 8e 	M[r4 + 428] = Null;
    op_extra_data->mic_sidetone_op = NULL;
84201f76:	60 f0 6c 8e 	M[r4 + 432] = Null;
    op_extra_data->mic_sw_rateadj_op = NULL;
84201f7a:	60 f0 7d 8e 	M[r4 + 500] = Null;
    op_extra_data->mic_mute_op = NULL;
84201f7e:	60 f0 9d 8e 	M[r4 + 628] = Null;

    /* Free cbops mic graph */
    if(op_extra_data->mic_graph != NULL)
84201f82:	62 f0 6a 88 	r0 = M[r4 + 424];
84201f86:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_3;

84201f88 <Lc_aec_reference_cleanup_mic_graph_2>:
    {
        destroy_graph(op_extra_data->mic_graph);
84201f88:	ff fd a7 f0 	call (m) 0x16daa;
84201f8c:	23 e1 
        op_extra_data->mic_graph = NULL;
84201f8e:	60 f0 6a 8e 	M[r4 + 424] = Null;

84201f92 <Lc_aec_reference_cleanup_mic_graph_3>:
    }

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84201f92:	60 f0 9f 88 	Null = M[r4 + 636];
84201f96:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_5;

84201f98 <Lc_aec_reference_cleanup_mic_graph_4>:
    {
        aec_reference_spkr_include_sidetone(op_extra_data, FALSE);
84201f98:	03 00       	r1 = Null + Null;
84201f9a:	32 00       	r0 = r4 + Null;
84201f9c:	97 4f       	call (m) $_aec_reference_spkr_include_sidetone;

84201f9e <Lc_aec_reference_cleanup_mic_graph_5>:

    /* Free Sidetone buffers, this must be
     * done after removing sidetone mix from
     * speaker graph.
     */
    if(op_extra_data->sidetone_buf != NULL)
84201f9e:	62 f0 31 88 	r0 = M[r4 + 196];
84201fa2:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_7;

84201fa4 <Lc_aec_reference_cleanup_mic_graph_6>:
    {
        cbuffer_destroy(op_extra_data->sidetone_buf);
84201fa4:	ff fd 84 f0 	call (m) 0x12802;
84201fa8:	3f e2 
        op_extra_data->sidetone_buf = NULL;
84201faa:	60 f0 31 8e 	M[r4 + 196] = Null;

84201fae <Lc_aec_reference_cleanup_mic_graph_7>:
    }

    /* update the state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84201fae:	32 00       	r0 = r4 + Null;
84201fb0:	f8 ff 3b e0 	call (m) $_aec_reference_update_sidetone_status;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    op_extra_data->mic_metadata_tag_left_words = 0;
84201fb4:	60 f0 cb 8e 	M[r4 + 812] = Null;

84201fb8 <Lc_aec_reference_cleanup_mic_graph_8>:
#endif

    DEBUG_GRAPHS("AEC REFERENCE: MIC graph's cleanup done!" );
}
84201fb8:	f1 48       	popm <FP, r4, rLink>;
84201fba:	d8 4c       	rts;

84201fbc <$_aec_reference_cleanup_graphs>:
 * \brief clean up all the cbops graphs
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_graphs(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201fbc:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201fbe:	16 00       	r4 = r0 + Null;

    patch_fn_shared(aec_reference);

    /* Kill timer Task */
    /* This needs to be atomic, to make sure the right timer gets cancelled */
    LOCK_INTERRUPTS;
84201fc0:	ff fd 56 f1 	call (m) 0x2cc9c;
84201fc4:	3d e6 
    if(op_extra_data->kick_id!=TIMER_ID_INVALID)
84201fc6:	62 f0 5d 88 	r0 = M[r4 + 372];
84201fca:	08 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_3;

84201fcc <Lc_aec_reference_cleanup_graphs_2>:
    {
        timer_cancel_event(op_extra_data->kick_id);
84201fcc:	04 00       	r2 = Null + Null;
84201fce:	03 00       	r1 = Null + Null;
84201fd0:	ff fd 90 f0 	call (m) 0x141bc;
84201fd4:	2d ef 
        op_extra_data->kick_id=TIMER_ID_INVALID;
84201fd6:	60 f0 5d 8e 	M[r4 + 372] = Null;

84201fda <Lc_aec_reference_cleanup_graphs_3>:
    }
    UNLOCK_INTERRUPTS;
84201fda:	ff fd 56 f1 	call (m) 0x2ccb8;
84201fde:	3f e6 

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* cleanup sidetone graph if we have one */
    if(NULL != op_extra_data->sidetone_graph)
84201fe0:	61 f0 99 88 	rMAC = M[r4 + 612];
84201fe4:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_5;

84201fe6 <Lc_aec_reference_cleanup_graphs_4>:
    {
        /* clean sidetone graph */
        aec_reference_cleanup_sidetone_graph(op_extra_data);
84201fe6:	32 00       	r0 = r4 + Null;
84201fe8:	02 f0 2f ed 	call (m) $_aec_reference_cleanup_sidetone_graph;

84201fec <Lc_aec_reference_cleanup_graphs_5>:
    }
#endif
    /* clean mic graph */
    aec_reference_cleanup_mic_graph(op_extra_data);
84201fec:	32 00       	r0 = r4 + Null;
84201fee:	c0 4f       	call (m) $_aec_reference_cleanup_mic_graph;

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);
84201ff0:	32 00       	r0 = r4 + Null;
84201ff2:	1a 4e       	call (m) $_aec_reference_cleanup_spkr_graph;

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
84201ff4:	07 00       	r5 = Null + Null;
84201ff6:	68 f0 84 20 	r6 = r4 + 132;

84201ffa <Lc_aec_reference_cleanup_graphs_6>:
    {
        if(op_extra_data->scratch_bufs[i] != NULL)
84201ffa:	82 f0 00 e8 	r0 = M[r6 + Null];
84201ffe:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_8;

84202000 <Lc_aec_reference_cleanup_graphs_7>:
        {
            cbuffer_destroy(op_extra_data->scratch_bufs[i]);
84202000:	ff fd 84 f0 	call (m) 0x12802;
84202004:	23 e0 
            op_extra_data->scratch_bufs[i] = NULL;
84202006:	80 f0 00 ee 	M[r6 + Null] = Null;

8420200a <Lc_aec_reference_cleanup_graphs_8>:

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
8420200a:	7f 20       	r5 = r5 + 1;
8420200c:	20 75       	r6 = r6 + 4;
8420200e:	38 2c       	Null = r5 - 16;
84202010:	f5 65       	if NC jump (m) Lc_aec_reference_cleanup_graphs_6;

84202012 <Lc_aec_reference_cleanup_graphs_9>:
            op_extra_data->scratch_bufs[i] = NULL;
        }
    }

    /* clear scratch buffer used by resampler operator */
    if(op_extra_data->resampler_temp_buffer != NULL)
84202012:	62 f0 32 88 	r0 = M[r4 + 200];
84202016:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_11;

84202018 <Lc_aec_reference_cleanup_graphs_10>:
    {
        pfree(op_extra_data->resampler_temp_buffer);
84202018:	ff fd 17 f0 	call (m) 0x4f62;
8420201c:	2b ea 
        op_extra_data->resampler_temp_buffer = NULL;
8420201e:	60 f0 32 8e 	M[r4 + 200] = Null;

84202022 <Lc_aec_reference_cleanup_graphs_11>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: Full graphs cleanup done!" );
}
84202022:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202024:	d8 4c       	rts;

84202026 <$_aec_reference_cleanup_spkr_graph>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202026:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202028:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

#if defined(IO_DEBUG)
    insert_op  = NULL;
8420202a:	e0 f0 00 f0 	M[Null + $_insert_op] = Null;
8420202e:	59 8e 
    st_disgard_op = NULL;
84202030:	e0 f0 00 f0 	M[Null + $_st_disgard_op] = Null;
84202034:	5a 8e 
#endif

    /* Clear links to graphs */
    op_extra_data->spkr_rate_monitor_op = NULL;
84202036:	60 f0 73 8e 	M[r4 + 460] = Null;
    op_extra_data->spkr_sw_rateadj_op = NULL;
8420203a:	60 f0 7e 8e 	M[r4 + 504] = Null;
    op_extra_data->spkr_ref_point_op = NULL;
8420203e:	60 f0 a8 8e 	M[r4 + 672] = Null;
    op_extra_data->spkr_st_point_op = NULL;
84202042:	60 f0 a9 8e 	M[r4 + 676] = Null;
    op_extra_data->spkr_ref_last_op = NULL;
84202046:	60 f0 aa 8e 	M[r4 + 680] = Null;
    op_extra_data->spkr_stmix_op =  NULL;
8420204a:	60 f0 ab 8e 	M[r4 + 684] = Null;
    op_extra_data->spkr_ref_rs_op = NULL;
8420204e:	60 f0 ac 8e 	M[r4 + 688] = Null;
    op_extra_data->ref_sw_rateadj_op = NULL;
84202052:	60 f0 90 8e 	M[r4 + 576] = Null;

    /* destroy speaker graph */
    if(op_extra_data->spkr_graph != NULL)
84202056:	62 f0 72 88 	r0 = M[r4 + 456];
8420205a:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_3;

8420205c <Lc_aec_reference_cleanup_spkr_graph_2>:
    {
        destroy_graph(op_extra_data->spkr_graph);
8420205c:	ff fd a6 f0 	call (m) 0x16daa;
84202060:	2f ea 
        op_extra_data->spkr_graph = NULL;
84202062:	60 f0 72 8e 	M[r4 + 456] = Null;

84202066 <Lc_aec_reference_cleanup_spkr_graph_3>:
    }

    /* clear flag for reference path */
    op_extra_data->spkr_ref_active = FALSE;
84202066:	60 f0 a0 8e 	M[r4 + 640] = Null;

    /* clear flag for sidetone path */
    op_extra_data->spkr_sidetone_active = FALSE;
8420206a:	60 f0 9f 8e 	M[r4 + 636] = Null;

#ifdef AEC_REFERENCE_SPKR_TTP
    /* destroy any structure allocated for ttp playback */
    aec_reference_spkr_ttp_terminate(op_extra_data);
8420206e:	32 00       	r0 = r4 + Null;
84202070:	03 f0 35 e7 	call (m) $_aec_reference_spkr_ttp_terminate;
#endif /* AEC_REFERENCE_SPKR_TTP */

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
84202074:	60 f0 d3 8e 	M[r4 + 844] = Null;

84202078 <Lc_aec_reference_cleanup_spkr_graph_4>:
#endif

    /* TODO - Fill speakers with silence */

    DEBUG_GRAPHS("AEC REFERENCE: Speaker graph's cleanup done!" );
}
84202078:	f1 48       	popm <FP, r4, rLink>;
8420207a:	d8 4c       	rts;

8420207c <$_aec_reference_spkr_include_ref_path>:
 * \brief updates speaker graph to include/exclude path for reference output
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_spkr_include_ref_path(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_ref_path)
{
8420207c:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
8420207e:	16 00       	r4 = r0 + Null;
84202080:	19 00       	rMAC = r1 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
84202082:	68 f0 72 88 	r6 = M[r4 + 456];
    cbops_op    *op_ptr;
    unsigned ref_idx = op_extra_data->spkr_ref_idx;
84202086:	63 f0 a4 88 	r1 = M[r4 + 656];
8420208a:	3b de       	M[FP + 28] = r1;

    /* No action if no speaker graph */
    if(NULL == spkr_graph)
8420208c:	0f f8 00 c2 	Null = r6 - Null;
84202090:	56 62       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_11;

84202092 <Lc_aec_reference_spkr_include_ref_path_2>:
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
84202092:	60 f0 a0 88 	Null = M[r4 + 640];
84202096:	51 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202098 <Lc_aec_reference_spkr_include_ref_path_3>:
84202098:	03 f0 35 4b 	r1 = Null + 1845;
8420209c:	02 f0 13 60 	r0 = Null + 4115;
842020a0:	ff fd 8f f0 	call (m) 0x13f12;
842020a4:	33 e3 
842020a6:	bd 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842020a8 <Lc_aec_reference_spkr_include_ref_path_4>:
            {
                return FALSE;
            }

            /* save the resampler op and it's scratch buffer index */
            op_extra_data->spkr_ref_rs_op = op_ptr;
842020a8:	67 f0 ac 8e 	M[r4 + 688] = r5;
            op_extra_data->spkr_ref_rs_idx = ref_rm_in_idx;
842020ac:	49 d8       	rMAC = M[FP + 36];
842020ae:	61 f0 a7 8e 	M[r4 + 668] = rMAC;

            /* insert resamler op into speaker cbops graph */
            cbops_insert_operator_into_graph(spkr_graph,op_ptr, after);
842020b2:	4c 08       	r2 = r7 + Null;
842020b4:	3b 00       	r1 = r5 + Null;
842020b6:	42 08       	r0 = r6 + Null;
842020b8:	05 f0 21 e1 	call (m) $_cbops_insert_operator_into_graph;
            after = op_ptr;
842020bc:	39 09       	r7 = r5 + Null;
            spkr_num_ref_ops++;
842020be:	0a 71       	r8 = Null + 1;

842020c0 <Lc_aec_reference_spkr_include_ref_path_5>:
        }

        /*  SW rate adjustment for reference */
        op_ptr = create_sw_rate_adj_op(1, &ref_rm_in_idx, &ref_idx,
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->sync_block.rm_adjustment, 0);
842020c0:	00 f0 30 cf 	push Null;
842020c4:	85 2a       	r3 = Null + 26;
842020c6:	c4 11       	r2 = FP + 28;
842020c8:	43 12       	r1 = FP + 36;
842020ca:	02 f0 30 ff 	push r4 + 560;
842020ce:	16 cf 
842020d0:	42 20       	r0 = Null + 1;
842020d2:	ff fd a5 f0 	call (m) 0x16bea;
842020d6:	39 e8 
842020d8:	7e 4c       	SP = SP + -8;
842020da:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
842020dc:	79 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

842020de <Lc_aec_reference_spkr_include_ref_path_6>:
        {
            return FALSE;
        }

		/* store reference rate adjust operator */
        op_extra_data->ref_sw_rateadj_op = op_ptr;
842020de:	67 f0 90 8e 	M[r4 + 576] = r5;
        if(op_extra_data->mic_sync_enable)
842020e2:	60 f0 d4 88 	Null = M[r4 + 848];
842020e6:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_8;

842020e8 <Lc_aec_reference_spkr_include_ref_path_7>:
        {
            /* if input and output are in the same clock, then mic output
             * can get sychronised to ref, and ref won't need rate adjustment.
             * The operator will be doing simple copy here.
             */
            cbops_rateadjust_passthrough_mode(op_ptr, TRUE);
842020e8:	43 20       	r1 = Null + 1;
842020ea:	ff fd a5 f0 	call (m) 0x16c96;
842020ee:	2d ed 

842020f0 <Lc_aec_reference_spkr_include_ref_path_8>:
        }

        /* insert rate adjust op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
842020f0:	4c 08       	r2 = r7 + Null;
842020f2:	3b 00       	r1 = r5 + Null;
842020f4:	42 08       	r0 = r6 + Null;
842020f6:	04 f0 23 ef 	call (m) $_cbops_insert_operator_into_graph;
        after = op_ptr;
        spkr_num_ref_ops++;
842020fa:	0a 75       	r8 = r8 + 1;

        /* speaker latency cbops operator */
        op_ptr = create_speaker_latency_op(ref_idx, &op_extra_data->sync_block);
842020fc:	63 f0 14 22 	r1 = r4 + 532;
84202100:	3a d8       	r0 = M[FP + 28];
84202102:	ff fd 30 f1 	call (m) 0x28250;
84202106:	2f ea 
84202108:	11 09       	r7 = r0 + Null;
        if(op_ptr == NULL)
8420210a:	62 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

8420210c <Lc_aec_reference_spkr_include_ref_path_9>:
        {
            return FALSE;
        }
        /* insert speaker latency op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
8420210c:	3c 00       	r2 = r5 + Null;
8420210e:	4b 08       	r1 = r7 + Null;
84202110:	42 08       	r0 = r6 + Null;
84202112:	04 f0 27 ee 	call (m) $_cbops_insert_operator_into_graph;
        spkr_num_ref_ops++;
84202116:	0a 75       	r8 = r8 + 1;
        /* save last operator in the reference sub-path and
         * also the number of operator in the sub-path,
         * these will be required when removing the
         * reference path
         */
        op_extra_data->spkr_ref_last_op = op_ptr;
84202118:	69 f0 aa 8e 	M[r4 + 680] = r7;
        op_extra_data->spkr_num_ref_ops = spkr_num_ref_ops;
8420211c:	6a f0 a6 8e 	M[r4 + 664] = r8;

        /* Now speaker graph includes reference sub path */
        op_extra_data->spkr_ref_active = TRUE;
84202120:	47 20       	r5 = Null + 1;
84202122:	67 f0 a0 8e 	M[r4 + 640] = r5;

        /* have reasonable distance between MIC and REF at the beginning,
		 * assumes MIC buffer is empty now.
		 */
        cbuffer_move_write_to_read_point(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL],
                                         op_extra_data->sync_block.jitter/2);
84202126:	62 f0 85 88 	r0 = M[r4 + 532];
8420212a:	13 50       	r1 = r0 LSHIFT -1;
8420212c:	32 a8       	r0 = M[r4 + 64];
8420212e:	ff fd 52 f1 	call (m) 0x2c57a;
84202132:	2d e2 
 *
 * \param op pointer to cbop
 */
static inline void cbops_reshresh_buffers(cbops_graph *graph)
{
   graph->refresh_buffers = TRUE;
84202134:	87 f0 07 8e 	M[r6 + 28] = r5;

84202138 <Lc_aec_reference_spkr_include_ref_path_10>:
    /* No action if no speaker graph */
    if(NULL == spkr_graph)
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
        return TRUE;
84202138:	42 20       	r0 = Null + 1;
8420213a:	73 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

8420213c <Lc_aec_reference_spkr_include_ref_path_11>:
    }

    if(!include_ref_path == !op_extra_data->spkr_ref_active)
8420213c:	02 00       	r0 = Null + Null;
8420213e:	08 04       	Null = rMAC - Null;
84202140:	20 f0 42 ce 	if EQ r0 = Null + 1;
84202144:	04 00       	r2 = Null + Null;
84202146:	60 f0 a0 88 	Null = M[r4 + 640];
8420214a:	20 f0 44 ce 	if EQ r2 = Null + 1;
8420214e:	10 05       	Null = r0 - r2;
84202150:	f4 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202152 <Lc_aec_reference_spkr_include_ref_path_12>:
         * as current state.
         */
        return TRUE;
    }

    if(include_ref_path)
84202152:	08 04       	Null = rMAC - Null;
84202154:	3f 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_16;

84202156 <Lc_aec_reference_spkr_include_ref_path_13>:
    {
        /* Adding Reference path to speaker graph */

        unsigned ref_input_idx = op_extra_data->spkr_ref_input_idx;
84202156:	61 f0 a1 88 	rMAC = M[r4 + 644];
8420215a:	41 de       	M[FP + 32] = rMAC;
        unsigned ref_rm_in_idx = ref_input_idx;
8420215c:	49 de       	M[FP + 36] = rMAC;
        cbops_op *after = op_extra_data->spkr_ref_point_op;
8420215e:	69 f0 a8 88 	r7 = M[r4 + 672];
        unsigned spkr_num_ref_ops = 0;
84202162:	02 09       	r8 = Null + Null;

        /* set buffer index for reference output in cbops graph */
        cbops_set_output_io_buffer(spkr_graph,
                                   ref_idx,
                                   ref_idx,
                                   op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]);
84202164:	35 a8       	r3 = M[r4 + 64];
84202166:	1c 00       	r2 = r1 + Null;
84202168:	42 08       	r0 = r6 + Null;
8420216a:	ff fd a6 f0 	call (m) 0x16e34;
8420216e:	2b e6 

        /* see if resampler is needed in reference path */
        if(op_extra_data->input_rate != op_extra_data->output_rate)
84202170:	61 f0 64 88 	rMAC = M[r4 + 400];
84202174:	62 f0 65 88 	r0 = M[r4 + 404];
84202178:	88 04       	Null = rMAC - r0;
8420217a:	a3 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_5;

8420217c <Lc_aec_reference_spkr_include_ref_path_14>:
        {
            /* resampler outputs into internal buffer */
            ref_rm_in_idx = ref_idx+1;
8420217c:	39 d8       	rMAC = M[FP + 28];
8420217e:	4b 20       	r1 = rMAC + 1;
84202180:	4b de       	M[FP + 36] = r1;
            /* NOTE: left scratch input is input to resampler */

            cbops_set_internal_io_buffer(spkr_graph,
                                         ref_rm_in_idx,
                                         ref_rm_in_idx,
                                         op_extra_data->scratch_bufs[op_extra_data->spkr_ref_scratch_idx]);
84202182:	62 f0 a2 88 	r0 = M[r4 + 648];
84202186:	31 00       	rMAC = r4 + Null;
84202188:	1c 00       	r2 = r1 + Null;
8420218a:	52 54       	r0 = r0 LSHIFT 2;
8420218c:	51 00       	rMAC = r0 + rMAC;
8420218e:	15 f0 21 88 	r3 = M[rMAC + 132];
84202192:	42 08       	r0 = r6 + Null;
84202194:	ff fd a6 f0 	call (m) 0x16e66;
84202198:	33 e6 

            /* Add reference sample rate conversion (input_rate --> output_rate) - for 1 channel only */
            op_ptr = create_iir_resamplerv2_op(1, &ref_input_idx, &ref_rm_in_idx,
                                               op_extra_data->input_rate, op_extra_data->output_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
8420219a:	00 f0 30 cf 	push Null;
8420219e:	00 f0 30 cf 	push Null;
842021a2:	00 f0 30 cf 	push Null;
842021a6:	61 f0 32 88 	rMAC = M[r4 + 200];
842021aa:	09 1c       	pushm <rMAC>;
842021ac:	61 f0 91 88 	rMAC = M[r4 + 580];
842021b0:	09 1c       	pushm <rMAC>;
842021b2:	61 f0 65 88 	rMAC = M[r4 + 404];
842021b6:	09 1c       	pushm <rMAC>;
842021b8:	65 f0 64 88 	r3 = M[r4 + 400];
842021bc:	44 12       	r2 = FP + 36;
842021be:	03 12       	r1 = FP + 32;
842021c0:	42 20       	r0 = Null + 1;
842021c2:	ff fd a6 f0 	call (m) 0x16fb2;
842021c6:	31 ef 
842021c8:	7a 4c       	SP = SP + -24;
842021ca:	17 00       	r5 = r0 + Null;

            if(op_ptr == NULL)
842021cc:	6e 63       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_4;

842021ce <Lc_aec_reference_spkr_include_ref_path_15>:
            {
                return FALSE;
842021ce:	02 00       	r0 = Null + Null;
842021d0:	28 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842021d2 <Lc_aec_reference_spkr_include_ref_path_16>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path added!" );
    }
    else
    {
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
842021d2:	63 f0 aa 88 	r1 = M[r4 + 680];
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842021d6:	07 00       	r5 = Null + Null;

842021d8 <Lc_aec_reference_spkr_include_ref_path_17>:
842021d8:	61 f0 a6 88 	rMAC = M[r4 + 664];
842021dc:	78 04       	Null = r5 - rMAC;
842021de:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_spkr_include_ref_path_19;

842021e2 <Lc_aec_reference_spkr_include_ref_path_18>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
842021e2:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(spkr_graph, op);
842021e6:	42 08       	r0 = r6 + Null;
842021e8:	04 f0 23 e6 	call (m) $_cbops_remove_operator_from_graph;
            op = prev_op;
842021ec:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842021ee:	7f 20       	r5 = r5 + 1;
842021f0:	f4 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_17;

842021f2 <Lc_aec_reference_spkr_include_ref_path_19>:
            cbops_remove_operator_from_graph(spkr_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about reference buffer any more */
        cbops_unset_buffer(spkr_graph, ref_idx);
842021f2:	3b d8       	r1 = M[FP + 28];
842021f4:	42 08       	r0 = r6 + Null;
842021f6:	04 f0 21 e8 	call (m) $_cbops_unset_buffer;

        if(op_extra_data->spkr_ref_rs_op != NULL)
842021fa:	61 f0 ac 88 	rMAC = M[r4 + 688];
842021fe:	08 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_21;

84202200 <Lc_aec_reference_spkr_include_ref_path_20>:
        {
            /* if we have resampler in the reference path
             * then also the reserved index buffer should
             * get unset.
             */
            cbops_unset_buffer(spkr_graph, op_extra_data->spkr_ref_rs_idx);
84202200:	63 f0 a7 88 	r1 = M[r4 + 668];
84202204:	42 08       	r0 = r6 + Null;
84202206:	04 f0 31 e7 	call (m) $_cbops_unset_buffer;
            op_extra_data->spkr_ref_rs_op = NULL;
8420220a:	60 f0 ac 8e 	M[r4 + 688] = Null;

8420220e <Lc_aec_reference_spkr_include_ref_path_21>:
        }

        op_extra_data->spkr_num_ref_ops = 0;
8420220e:	60 f0 a6 8e 	M[r4 + 664] = Null;
        op_extra_data->spkr_ref_last_op = NULL;
84202212:	60 f0 aa 8e 	M[r4 + 680] = Null;
        op_extra_data->ref_sw_rateadj_op = NULL;
84202216:	60 f0 90 8e 	M[r4 + 576] = Null;

        /* speaker graph no longer has reference sub-path */
        op_extra_data->spkr_ref_active = FALSE;
8420221a:	60 f0 a0 8e 	M[r4 + 640] = Null;
8420221e:	8d 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202220 <Lc_aec_reference_spkr_include_ref_path_22>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path removed!" );
    }
    return TRUE;
}
84202220:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202222:	d8 4c       	rts;

84202224 <$_aec_reference_stop_reset>:
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}

bool aec_reference_stop_reset(OPERATOR_DATA *op_data,void **response_data)
{
84202224:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202226:	16 00       	r4 = r0 + Null;
84202228:	1f 00       	r5 = r1 + Null;
    patch_fn_shared(aec_reference);

    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420222a:	73 88       	r1 = M[r4 + 4];
8420222c:	02 f0 00 60 	r0 = Null + 4096;
84202230:	3c 00       	r2 = r5 + Null;
84202232:	ef fd ef ff 	call (m) 0x204;
84202236:	33 ee 
84202238:	10 04       	Null = r0 - Null;
8420223a:	03 62       	if NE jump (m) Lc_aec_reference_stop_reset_3;

8420223c <Lc_aec_reference_stop_reset_2>:
    {
        return(FALSE);
8420223c:	02 00       	r0 = Null + Null;
8420223e:	0b 6e       	jump (m) Lc_aec_reference_stop_reset_6;

84202240 <Lc_aec_reference_stop_reset_3>:
    }
    /* do something only if the current state is "running" */
    if(op_data->state == OP_RUNNING)
84202240:	31 b0       	rMAC = MBS[r4 + 24];
84202242:	04 62       	if NE jump (m) Lc_aec_reference_stop_reset_5;

84202244 <Lc_aec_reference_stop_reset_4>:
    {
        aec_reference_cleanup(op_data);
84202244:	32 00       	r0 = r4 + Null;
84202246:	f8 ff 2f e0 	call (m) $_aec_reference_cleanup;

8420224a <Lc_aec_reference_stop_reset_5>:
    }

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
8420224a:	41 20       	rMAC = Null + 1;
8420224c:	31 ba       	MB[r4 + 24] = rMAC;
8420224e:	39 e8       	rMAC = M[r5 + Null];
84202250:	48 8e       	M[rMAC + 4] = Null;
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
84202252:	42 20       	r0 = Null + 1;

84202254 <Lc_aec_reference_stop_reset_6>:
}
84202254:	f2 48       	popm <FP, r4, r5, rLink>;
84202256:	d8 4c       	rts;

84202258 <$_aec_reference_update_mic_reference_sync>:
 * aec_reference_update_mic_reference_sync
 * \brief keeps mic and ref syncronised by updatin mic or reference path warp value
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_update_mic_reference_sync( AEC_REFERENCE_OP_DATA * op_extra_data)
{
84202258:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
8420225a:	16 00       	r4 = r0 + Null;
    int mic_ra = 0;
8420225c:	02 09       	r8 = Null + Null;
    int spkr_ra = 0;
8420225e:	01 09       	r7 = Null + Null;
    uint32 val;

    /* This is run in main loop, decimate update as it won't be
     * needed to get updated that often
     */
    op_extra_data->ref_update_counter++;
84202260:	61 f0 d0 88 	rMAC = M[r4 + 832];
84202264:	49 20       	rMAC = rMAC + 1;
84202266:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
    if(op_extra_data->ref_update_counter >= AEC_REFERENCE_REF_RATE_UPDATE_PERIOD)
8420226a:	48 26       	Null = rMAC - 9;
8420226c:	82 64       	if NC jump (m) Lc_aec_reference_update_mic_reference_sync_24;

8420226e <Lc_aec_reference_update_mic_reference_sync_2>:
    {
        op_extra_data->ref_update_counter = 0;
8420226e:	60 f0 d0 8e 	M[r4 + 832] = Null;
        if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202272:	61 f0 71 88 	rMAC = M[r4 + 452];
84202276:	88 24       	Null = rMAC - 2;
84202278:	0e 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_6;

8420227a <Lc_aec_reference_update_mic_reference_sync_3>:
            /* speaker is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and speaker rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1kHz-like speaker rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->spkr_endpoint, &val))
8420227a:	c3 11       	r1 = FP + 28;
8420227c:	62 f0 80 88 	r0 = M[r4 + 512];
84202280:	04 f0 21 ec 	call (m) $_get_override_ep_current_hw_warp;
84202284:	10 04       	Null = r0 - Null;
84202286:	03 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_5;

84202288 <Lc_aec_reference_update_mic_reference_sync_4>:
            {
                spkr_ra = (int)val;
84202288:	e9 f0 07 88 	r7 = M[FP + 28];

8420228c <Lc_aec_reference_update_mic_reference_sync_5>:
            }
            spkr_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
8420228c:	04 f0 08 f0 	r6 = Null + 4194304;
84202290:	00 40 
84202292:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_9;

84202294 <Lc_aec_reference_update_mic_reference_sync_6>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            spkr_rt = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84202294:	62 f0 73 88 	r0 = M[r4 + 460];
84202298:	03 00       	r1 = Null + Null;
8420229a:	ff fd 4c f3 	call 0x6bbf0;
8420229e:	36 ea 
842022a0:	10 09       	r6 = r0 + Null;
            if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
               )
842022a2:	61 f0 71 88 	rMAC = M[r4 + 452];
842022a6:	48 24       	Null = rMAC - 1;
842022a8:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

842022aa <Lc_aec_reference_update_mic_reference_sync_7>:
842022aa:	60 f0 ae 88 	Null = M[r4 + 696];
842022ae:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

842022b0 <Lc_aec_reference_update_mic_reference_sync_8>:
            {
                /* if SW rate adjustment is used, get the current value */
                spkr_ra = cbops_sra_get_current_rate_adjust(op_extra_data->spkr_sw_rateadj_op);
842022b0:	62 f0 7e 88 	r0 = M[r4 + 504];
842022b4:	ff fd a5 f0 	call (m) 0x16cba;
842022b8:	27 e0 
842022ba:	11 09       	r7 = r0 + Null;

842022bc <Lc_aec_reference_update_mic_reference_sync_9>:
            }
        }
        if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
842022bc:	61 f0 68 88 	rMAC = M[r4 + 416];
842022c0:	88 24       	Null = rMAC - 2;
842022c2:	0f 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_13;

842022c4 <Lc_aec_reference_update_mic_reference_sync_10>:
            /* MIC is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and mic rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1khz-like mic rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->mic_endpoint, &val))
842022c4:	c3 11       	r1 = FP + 28;
842022c6:	62 f0 7f 88 	r0 = M[r4 + 508];
842022ca:	04 f0 37 e9 	call (m) $_get_override_ep_current_hw_warp;
842022ce:	10 04       	Null = r0 - Null;
842022d0:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_12;

842022d2 <Lc_aec_reference_update_mic_reference_sync_11>:
            {
                mic_ra = -(int)val;
842022d2:	39 d8       	rMAC = M[FP + 28];
842022d4:	1f f0 0a c2 	r8 = Null - rMAC;

842022d8 <Lc_aec_reference_update_mic_reference_sync_12>:
            }
            mic_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
842022d8:	04 f0 07 f0 	r5 = Null + 4194304;
842022dc:	00 40 
842022de:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_16;

842022e0 <Lc_aec_reference_update_mic_reference_sync_13>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            mic_rt = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
842022e0:	62 f0 6b 88 	r0 = M[r4 + 428];
842022e4:	03 00       	r1 = Null + Null;
842022e6:	ff fd 4c f3 	call 0x6bbf0;
842022ea:	2a e8 
842022ec:	17 00       	r5 = r0 + Null;
            if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
               )
842022ee:	61 f0 68 88 	rMAC = M[r4 + 416];
842022f2:	48 24       	Null = rMAC - 1;
842022f4:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

842022f6 <Lc_aec_reference_update_mic_reference_sync_14>:
842022f6:	60 f0 ad 88 	Null = M[r4 + 692];
842022fa:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

842022fc <Lc_aec_reference_update_mic_reference_sync_15>:
            {
                mic_ra = cbops_sra_get_current_rate_adjust(op_extra_data->mic_sw_rateadj_op);
842022fc:	62 f0 7d 88 	r0 = M[r4 + 500];
84202300:	ff fd a4 f0 	call (m) 0x16cba;
84202304:	3b ed 
84202306:	12 09       	r8 = r0 + Null;

84202308 <Lc_aec_reference_update_mic_reference_sync_16>:
            }
        }

        if(op_extra_data->mic_sync_enable)
84202308:	60 f0 d4 88 	Null = M[r4 + 848];
8420230c:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_22;

8420230e <Lc_aec_reference_update_mic_reference_sync_17>:
        {
            /* if we are syncronising MIC to REF then calculate the rate needs
             * to be applied to the mic path, so it will be syncronised to
             * REFERENCE output(i.e. speaker input)*/
            int new_mic_ra = aecref_calc_sync_mic_rate(spkr_ra,spkr_rt,mic_rt);
8420230e:	3c 00       	r2 = r5 + Null;
84202310:	43 08       	r1 = r6 + Null;
84202312:	4a 08       	r0 = r7 + Null;
84202314:	05 f0 37 e7 	call (m) $_aecref_calc_sync_mic_rate;
84202318:	17 00       	r5 = r0 + Null;
            int diff = new_mic_ra - mic_ra;
8420231a:	af f7 03 c2 	r1 = r5 - r8;
            if(diff != 0)
8420231e:	18 04       	Null = r1 - Null;
84202320:	13 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_21;

84202322 <Lc_aec_reference_update_mic_reference_sync_18>:
            {
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202322:	61 f0 68 88 	rMAC = M[r4 + 416];
84202326:	88 24       	Null = rMAC - 2;
84202328:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_20;

8420232a <Lc_aec_reference_update_mic_reference_sync_19>:
                {
                    /* HW rate adjustment, apply the change only */
                    set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint, diff);
8420232a:	62 f0 7f 88 	r0 = M[r4 + 508];
8420232e:	ff fd 13 f0 	call (m) 0x4aa0;
84202332:	33 eb 
84202334:	09 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_21;

84202336 <Lc_aec_reference_update_mic_reference_sync_20>:
                else
                {
                    /* apply new SW rate adjustment */
                    cbops_sra_set_rate_adjust(op_extra_data->mic_sw_rateadj_op,
                                              op_extra_data->num_mic_channels,
                                              new_mic_ra);
84202336:	63 f0 78 88 	r1 = M[r4 + 480];
8420233a:	62 f0 7d 88 	r0 = M[r4 + 500];
8420233e:	3c 00       	r2 = r5 + Null;
84202340:	ff fd a4 f0 	call (m) 0x16c9c;
84202344:	3d ea 

84202346 <Lc_aec_reference_update_mic_reference_sync_21>:
                }
            }
            op_extra_data->mic_rate_adjustment = new_mic_ra;
84202346:	67 f0 69 8e 	M[r4 + 420] = r5;
8420234a:	11 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_23;

8420234c <Lc_aec_reference_update_mic_reference_sync_22>:
        {

            /* We are synchronising REFERENCE to MIC output,
             * Update reference SW rate adjustment.
             */
            op_extra_data->sync_block.rm_adjustment = aecref_calc_ref_rate(mic_rt,mic_ra,spkr_rt,spkr_ra);
8420234c:	4d 08       	r3 = r7 + Null;
8420234e:	44 08       	r2 = r6 + Null;
84202350:	53 08       	r1 = r8 + Null;
84202352:	3a 00       	r0 = r5 + Null;
84202354:	ff fd 6f f1 	call (m) 0x3015e;
84202358:	2b e0 
8420235a:	14 00       	r2 = r0 + Null;
8420235c:	64 f0 8c 8e 	M[r4 + 560] = r2;

            /* update rate adjust for reference path */
            cbops_sra_set_rate_adjust(op_extra_data->ref_sw_rateadj_op,
                                      1,
                                      op_extra_data->sync_block.rm_adjustment);
84202360:	43 20       	r1 = Null + 1;
84202362:	62 f0 90 88 	r0 = M[r4 + 576];
84202366:	ff fd a4 f0 	call (m) 0x16c9c;
8420236a:	37 e9 

8420236c <Lc_aec_reference_update_mic_reference_sync_23>:

        }
        /* Clear frm_count to disable backup rate adjustment
         *  when rate adjustment is enacted
         */
        op_extra_data->sync_block.frm_count = 0;
8420236c:	60 f0 8b 8e 	M[r4 + 556] = Null;

84202370 <Lc_aec_reference_update_mic_reference_sync_24>:
    }
}
84202370:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202372:	d8 4c       	rts;

84202374 <$_build_sidetone_graph>:
 * \brief updates speaker graph to include/exclude side tone mixing
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_sidetone_graph(AEC_REFERENCE_OP_DATA* op_extra_data)
{
84202374:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84202376:	16 00       	r4 = r0 + Null;
    tCbuffer *mic_buf = op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1];
84202378:	b7 88       	r5 = M[r4 + 8];
    unsigned* idxs;
    unsigned num_io = 2;
8420237a:	10 71       	r6 = Null + 2;
    cbops_graph *sidetone_graph;
    cbops_op *op_ptr;
    cbops_op *override_op_ptr;
    unsigned st_mic_idx = 0;          /* buffer index for mic input */
    unsigned st_filter_out_idx = 1;   /* buffer index for sidetone filter output */
    unsigned resampler_out_idx = 0;   /* buffer index for output of possible resampler */
8420237c:	40 de       	M[FP + 32] = Null;
    unsigned sidetone_idx = st_filter_out_idx; /* buffer index for sidetone buffer */
8420237e:	0a 71       	r8 = Null + 1;
    unsigned sidetone_buf_size;
    unsigned spkr_threshold = frac_mult(op_extra_data->spkr_rate, op_extra_data->kick_period_frac)+1;
84202380:	62 f0 6e 88 	r0 = M[r4 + 440];
84202384:	63 f0 96 88 	r1 = M[r4 + 600];
84202388:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420238c:	51 20       	rMAC = r0 + 1;
8420238e:	49 de       	M[FP + 36] = rMAC;
    unsigned safety_threshold;
    unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
84202390:	61 f0 76 88 	rMAC = M[r4 + 472];
84202394:	19 f1 f0 1f 	r7 = rMAC AND 0x3ff0;
    unsigned num_sidetone_spkrs = 1;
84202398:	53 09       	r9 = r8 + Null;
     * --------------------------------------------------------------------------------------------------*/

    patch_fn_shared(aec_reference);

    /* destroy cbops graph if already running */
    if(NULL != op_extra_data->sidetone_graph)
8420239a:	61 f0 99 88 	rMAC = M[r4 + 612];
8420239e:	03 60       	if EQ jump (m) Lc_build_sidetone_graph_3;

842023a0 <Lc_build_sidetone_graph_2>:
    {
        aec_reference_cleanup_sidetone_graph(op_extra_data);
842023a0:	32 00       	r0 = r4 + Null;
842023a2:	fa 4e       	call (m) $_aec_reference_cleanup_sidetone_graph;

842023a4 <Lc_build_sidetone_graph_3>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
842023a4:	61 f0 70 90 	rMAC = MBS[r4 + 624];
842023a8:	c8 24       	Null = rMAC - 3;
842023aa:	e2 62       	if NE jump (m) Lc_build_sidetone_graph_25;

842023ac <Lc_build_sidetone_graph_4>:
    }

    DEBUG_GRAPHS("AEC_REFERENCE: Building sidetone graph ...");

    /* Determine number of speakers to have sidetone */
    if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
842023ac:	91 f0 00 10 	rMAC = r7 AND 0x1000;
842023b0:	05 62       	if NE jump (m) Lc_build_sidetone_graph_7;

842023b2 <Lc_build_sidetone_graph_5>:
    {
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX) == 0)
842023b2:	91 f1 00 00 	rMAC = r7 AND 0x2000;
842023b6:	02 62       	if NE jump (m) Lc_build_sidetone_graph_7;

842023b8 <Lc_build_sidetone_graph_6>:
        {
            /* mono to stereo, mix to both */
            num_sidetone_spkrs = 2;
842023b8:	43 09       	r9 = r6 + Null;

842023ba <Lc_build_sidetone_graph_7>:
        }
    }

    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);
842023ba:	61 f0 77 88 	rMAC = M[r4 + 476];
842023be:	1f fb 00 c2 	Null = r9 - rMAC;
842023c2:	02 64       	if NC jump (m) Lc_build_sidetone_graph_9;

842023c4 <Lc_build_sidetone_graph_8>:
842023c4:	0b 09       	r9 = rMAC + Null;

842023c6 <Lc_build_sidetone_graph_9>:

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
842023c6:	61 f0 31 88 	rMAC = M[r4 + 196];
842023ca:	d4 60       	if EQ jump (m) Lc_build_sidetone_graph_26;

842023cc <Lc_build_sidetone_graph_10>:
842023cc:	03 f0 bb 41 	r1 = Null + 443;
842023d0:	02 f0 13 60 	r0 = Null + 4115;
842023d4:	ff fd 8d f0 	call (m) 0x13f12;
842023d8:	3f e9 
842023da:	dc 6e       	jump (m) Lc_build_sidetone_graph_30;

842023dc <Lc_build_sidetone_graph_11>:
    /* Allocate Buffer for sidetone samples,
     * size = sidetone_task_period + 1ms for latency control
     */
    sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                  op_extra_data->kick_period_frac +
                                  FRACTIONAL(0.001));
842023dc:	62 f0 6e 88 	r0 = M[r4 + 440];
842023e0:	61 f0 96 88 	rMAC = M[r4 + 600];
842023e4:	83 f0 13 f0 	r1 = rMAC + 2147483;
842023e8:	9b 28 
842023ea:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
842023ee:	03 00       	r1 = Null + Null;
842023f0:	ff fd 81 f0 	call (m) 0x1279c;
842023f4:	2d ed 
842023f6:	62 f0 31 8e 	M[r4 + 196] = r0;
    if(!op_extra_data->sidetone_buf)
842023fa:	61 f0 31 88 	rMAC = M[r4 + 196];
842023fe:	c9 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

84202400 <Lc_build_sidetone_graph_12>:
    }

    /* create clone cbuffers for mic buffer */
    op_extra_data->sidetone_mic_buf = cbuffer_create(mic_buf->base_addr,
                                                     cbuffer_get_size_in_words(mic_buf),
                                                     BUF_DESC_SW_BUFFER);
84202400:	3a 00       	r0 = r5 + Null;
84202402:	ff fd 82 f0 	call (m) 0x12858;
84202406:	37 e2 
84202408:	13 00       	r1 = r0 + Null;
8420240a:	fa 88       	r0 = M[r5 + 12];
8420240c:	04 00       	r2 = Null + Null;
8420240e:	ff fd 81 f0 	call (m) 0x12762;
84202412:	35 ea 
84202414:	62 f0 9a 8e 	M[r4 + 616] = r0;
    if(op_extra_data->sidetone_mic_buf == NULL)
84202418:	61 f0 9a 88 	rMAC = M[r4 + 616];
8420241c:	ba 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

8420241e <Lc_build_sidetone_graph_13>:
        return FALSE;
    }


    /* do we need resampler for side tone generation */
    if(op_extra_data->spkr_rate != op_extra_data->mic_rate)
8420241e:	61 f0 6e 88 	rMAC = M[r4 + 440];
84202422:	62 f0 66 88 	r0 = M[r4 + 408];
84202426:	88 04       	Null = rMAC - r0;
84202428:	05 60       	if EQ jump (m) Lc_build_sidetone_graph_15;

8420242a <Lc_build_sidetone_graph_14>:
    {
        /* Extra buffer needed between sidetone filter and resampler,
         * as resampler can't work in-place
         */
        num_io++;
8420242a:	18 71       	r6 = Null + 3;
        resampler_out_idx = st_filter_out_idx + 1;
8420242c:	81 20       	rMAC = Null + 2;
8420242e:	41 de       	M[FP + 32] = rMAC;
        sidetone_idx++;
84202430:	0a 09       	r8 = rMAC + Null;

84202432 <Lc_build_sidetone_graph_15>:

    /* create indexes for cbops buffers,
     * this needs to be deleted before leaving
     * this function.
     */
    idxs = create_default_indexes(num_io);
84202432:	42 08       	r0 = r6 + Null;
84202434:	ff fd a5 f0 	call (m) 0x16f08;
84202438:	35 e6 
8420243a:	11 09       	r7 = r0 + Null;
    if(idxs == NULL)
8420243c:	aa 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

8420243e <Lc_build_sidetone_graph_16>:
    {
        return(FALSE);
    }

    /* Allocate sidetone graph */
    sidetone_graph = cbops_alloc_graph(num_io);
8420243e:	42 08       	r0 = r6 + Null;
84202440:	ff fd a4 f0 	call (m) 0x16d76;
84202444:	37 e9 
84202446:	10 09       	r6 = r0 + Null;
    if(!sidetone_graph)
84202448:	a0 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420244a <Lc_build_sidetone_graph_17>:
    {
        goto aFailed;
    }
    op_extra_data->sidetone_graph = sidetone_graph;
8420244a:	68 f0 99 8e 	M[r4 + 612] = r6;

    /* set mic input buffer */
    cbops_set_input_io_buffer(sidetone_graph,
                              st_mic_idx,
                              st_mic_idx,
                              op_extra_data->sidetone_mic_buf);
8420244e:	65 f0 9a 88 	r3 = M[r4 + 616];
84202452:	04 00       	r2 = Null + Null;
84202454:	03 00       	r1 = Null + Null;
84202456:	ff fd a4 f0 	call (m) 0x16e02;
8420245a:	2d ed 
     * into speakers by override operator)
     */
    cbops_set_output_io_buffer(sidetone_graph,
                               sidetone_idx,
                               sidetone_idx,
                               op_extra_data->sidetone_buf);
8420245c:	65 f0 31 88 	r3 = M[r4 + 196];
84202460:	54 08       	r2 = r8 + Null;
84202462:	53 08       	r1 = r8 + Null;
84202464:	42 08       	r0 = r6 + Null;
84202466:	ff fd a4 f0 	call (m) 0x16e34;
8420246a:	2f ee 
      Note:  Sidetone is before resampler.
      Better solution is to place it at lowest sample rate
    */
    op_ptr = create_sidetone_filter_op(st_mic_idx, st_filter_out_idx, 3,
                                       (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                       (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
8420246c:	01 f0 0c ff 	push r4 + 268;
84202470:	16 cf 
84202472:	65 f0 f0 20 	r3 = r4 + 240;
84202476:	c4 20       	r2 = Null + 3;
84202478:	43 20       	r1 = Null + 1;
8420247a:	02 00       	r0 = Null + Null;
8420247c:	03 f0 3b e7 	call (m) $_create_sidetone_filter_op;
84202480:	7f 4c       	SP = SP + -4;
    op_extra_data->mic_sidetone_op = op_ptr;
    if(!op_ptr)
84202482:	62 f0 6c 8e 	M[r4 + 432] = r0;
84202486:	81 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202488 <Lc_build_sidetone_graph_18>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202488:	13 00       	r1 = r0 + Null;
8420248a:	42 08       	r0 = r6 + Null;
8420248c:	ff fd a5 f0 	call (m) 0x16e96;
84202490:	2b e0 

    /* DC remove on sidetone */
    op_ptr = create_dc_remove_op(1, &idxs[st_filter_out_idx], &idxs[st_filter_out_idx]);
84202492:	94 f0 04 20 	r2 = r7 + 4;
84202496:	93 f0 04 20 	r1 = r7 + 4;
8420249a:	42 20       	r0 = Null + 1;
8420249c:	ff fd 1c f1 	call (m) 0x25e40;
842024a0:	25 ed 
    if(!op_ptr)
842024a2:	10 04       	Null = r0 - Null;
842024a4:	72 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842024a6 <Lc_build_sidetone_graph_19>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph, op_ptr);
842024a6:	13 00       	r1 = r0 + Null;
842024a8:	42 08       	r0 = r6 + Null;
842024aa:	ff fd a4 f0 	call (m) 0x16e96;
842024ae:	2d ef 

    /* see if we need resampler in sidetone path */
    if(resampler_out_idx != 0)
842024b0:	41 d8       	rMAC = M[FP + 32];
842024b2:	2a 60       	if EQ jump (m) Lc_build_sidetone_graph_22;

842024b4 <Lc_build_sidetone_graph_20>:
    {
        /* sidetone filter will write into scratch buff */
        cbops_set_internal_io_buffer(sidetone_graph,
                                     st_filter_out_idx,
                                     st_filter_out_idx,
                                     op_extra_data->scratch_bufs[0]);
842024b4:	65 f0 21 88 	r3 = M[r4 + 132];
842024b8:	44 20       	r2 = Null + 1;
842024ba:	23 00       	r1 = r2 + Null;
842024bc:	42 08       	r0 = r6 + Null;
842024be:	ff fd a4 f0 	call (m) 0x16e66;
842024c2:	29 ed 
                                           &idxs[st_filter_out_idx],
                                           &idxs[resampler_out_idx],
                                           op_extra_data->mic_rate,
                                           op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, 0, 0, 0);
842024c4:	00 f0 30 cf 	push Null;
842024c8:	00 f0 30 cf 	push Null;
842024cc:	00 f0 30 cf 	push Null;
842024d0:	61 f0 32 88 	rMAC = M[r4 + 200];
842024d4:	09 1c       	pushm <rMAC>;
842024d6:	61 f0 91 88 	rMAC = M[r4 + 580];
842024da:	09 1c       	pushm <rMAC>;
842024dc:	61 f0 6e 88 	rMAC = M[r4 + 440];
842024e0:	09 1c       	pushm <rMAC>;
842024e2:	65 f0 66 88 	r3 = M[r4 + 408];
842024e6:	94 f0 08 20 	r2 = r7 + 8;
842024ea:	93 f0 04 20 	r1 = r7 + 4;
842024ee:	42 20       	r0 = Null + 1;
842024f0:	ff fd a5 f0 	call (m) 0x16fb2;
842024f4:	23 e6 
842024f6:	7a 4c       	SP = SP + -24;
        if(!op_ptr)
842024f8:	10 04       	Null = r0 - Null;
842024fa:	47 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842024fc <Lc_build_sidetone_graph_21>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(sidetone_graph,op_ptr);
842024fc:	13 00       	r1 = r0 + Null;
842024fe:	42 08       	r0 = r6 + Null;
84202500:	ff fd a4 f0 	call (m) 0x16e96;
84202504:	37 ec 

84202506 <Lc_build_sidetone_graph_22>:
    op_ptr = create_sink_overflow_disgard_op(1,                   /* number of channels */
                                             &idxs[sidetone_idx], /* buffer indexes */
                                             /* Minimum space needed in buffer at the beginning of
                                              * process, if not enough space this op will discard some
                                              * samples to free space for new incoming mic sapmples */
                                             spkr_threshold);
84202506:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
8420250a:	49 08       	rMAC = r7 + Null;
8420250c:	51 00       	rMAC = r0 + rMAC;
8420250e:	0f 00       	r5 = rMAC + Null;
84202510:	42 20       	r0 = Null + 1;
84202512:	3b 00       	r1 = r5 + Null;
84202514:	4c d8       	r2 = M[FP + 36];
84202516:	ff fd 4c f1 	call (m) 0x2bdc4;
8420251a:	2f e5 
#if defined(IO_DEBUG)
    st_disgard_op = op_ptr;
8420251c:	e0 f0 02 f0 	M[Null + $_st_disgard_op] = r0;
84202520:	5a 8e 
#endif

    if(!op_ptr)
84202522:	10 04       	Null = r0 - Null;
84202524:	32 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202526 <Lc_build_sidetone_graph_23>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202526:	13 00       	r1 = r0 + Null;
84202528:	42 08       	r0 = r6 + Null;
8420252a:	ff fd a4 f0 	call (m) 0x16e96;
8420252e:	2d eb 
     */

    /* safety_threshold, this is a small safety zone to make sure
     * sidetone mixing is ahead of reading by HW, (1/4 of a ms)
     */
    safety_threshold = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.00025))+1;
84202530:	62 f0 6e 88 	r0 = M[r4 + 440];
84202534:	00 f0 13 f4 	r1 = Null + 536870;
84202538:	26 61 
8420253a:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420253e:	51 20       	rMAC = r0 + 1;
        &op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1], /* spkr mmu buffer(s) */
        num_sidetone_spkrs,                                 /* number of speaker(s) */
        &idxs[sidetone_idx],                                /* indexes for sidetone buffer */
        spkr_threshold,                                     /* speaker threshold */
        safety_threshold                                    /* safety threshold */
                                                );
84202540:	09 1c       	pushm <rMAC>;
84202542:	49 d8       	rMAC = M[FP + 36];
84202544:	08 f0 42 e0 	pushm <rMAC, r5>;
84202548:	64 f0 44 20 	r2 = r4 + 68;
8420254c:	b2 88       	r0 = M[r4 + 8];
8420254e:	03 00       	r1 = Null + Null;
84202550:	5d 08       	r3 = r9 + Null;
84202552:	02 f0 2f e6 	call (m) $_create_aec_ref_sidetone_op;
84202556:	7d 4c       	SP = SP + -12;
    if(!override_op_ptr)
84202558:	10 04       	Null = r0 - Null;
8420255a:	17 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420255c <Lc_build_sidetone_graph_24>:
    {
        goto aFailed;
    }
    cbops_set_override_operator(sidetone_graph, override_op_ptr);
8420255c:	13 00       	r1 = r0 + Null;
8420255e:	42 08       	r0 = r6 + Null;
84202560:	ff fd a4 f0 	call (m) 0x16ec2;
84202564:	23 eb 

    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Done!");
    pfree(idxs);
84202566:	4a 08       	r0 = r7 + Null;
84202568:	ff fd 14 f0 	call (m) 0x4f62;
8420256c:	3b ef 

8420256e <Lc_build_sidetone_graph_25>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
    {
        return TRUE;
8420256e:	42 20       	r0 = Null + 1;
84202570:	11 6e       	jump (m) Lc_build_sidetone_graph_30;

84202572 <Lc_build_sidetone_graph_26>:
    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
    PL_ASSERT(op_extra_data->sidetone_mic_buf == NULL);
84202572:	61 f0 9a 88 	rMAC = M[r4 + 616];
84202576:	33 61       	if EQ jump (m) Lc_build_sidetone_graph_11;

84202578 <Lc_build_sidetone_graph_27>:
84202578:	03 f0 bc 41 	r1 = Null + 444;
8420257c:	02 f0 13 60 	r0 = Null + 4115;
84202580:	ff fd 8c f0 	call (m) 0x13f12;
84202584:	33 ec 
84202586:	06 6e       	jump (m) Lc_build_sidetone_graph_30;

84202588 <Lc_build_sidetone_graph_28>:
    pfree(idxs);

    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
84202588:	4a 08       	r0 = r7 + Null;
8420258a:	ff fd 14 f0 	call (m) 0x4f62;
8420258e:	39 ee 

84202590 <Lc_build_sidetone_graph_29>:
    if(!op_extra_data->sidetone_buf)
    {
        /* Not going ahead with creating sidetone graph if we
         * cannot create shared buffer for sidetone path.
         */
        return FALSE;
84202590:	02 00       	r0 = Null + Null;

84202592 <Lc_build_sidetone_graph_30>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
    return(FALSE);
}
84202592:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202594:	d8 4c       	rts;

84202596 <$_aec_reference_cleanup_sidetone_graph>:
 * \brief clean up sidetone graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_sidetone_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202596:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202598:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* mic_sidetone_op, no longer is valid` */
    op_extra_data->mic_sidetone_op = NULL;
8420259a:	60 f0 6c 8e 	M[r4 + 432] = Null;

    /* Free cbops sidetone graph */
    if(op_extra_data->sidetone_graph != NULL)
8420259e:	62 f0 99 88 	r0 = M[r4 + 612];
842025a2:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_3;

842025a4 <Lc_aec_reference_cleanup_sidetone_graph_2>:
    {
        destroy_graph(op_extra_data->sidetone_graph);
842025a4:	ff fd a4 f0 	call (m) 0x16daa;
842025a8:	27 e0 
        op_extra_data->sidetone_graph = NULL;
842025aa:	60 f0 99 8e 	M[r4 + 612] = Null;

842025ae <Lc_aec_reference_cleanup_sidetone_graph_3>:
    }

    /* Free Sidetone buffers */
    if(op_extra_data->sidetone_buf != NULL)
842025ae:	62 f0 31 88 	r0 = M[r4 + 196];
842025b2:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_5;

842025b4 <Lc_aec_reference_cleanup_sidetone_graph_4>:
    {
        cbuffer_destroy(op_extra_data->sidetone_buf);
842025b4:	ff fd 81 f0 	call (m) 0x12802;
842025b8:	2f e2 
        op_extra_data->sidetone_buf = NULL;
842025ba:	60 f0 31 8e 	M[r4 + 196] = Null;

842025be <Lc_aec_reference_cleanup_sidetone_graph_5>:
    }

    /* free cbuffer structure for clone mic buff */
    if(op_extra_data->sidetone_mic_buf != NULL)
842025be:	62 f0 9a 88 	r0 = M[r4 + 616];
842025c2:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_7;

842025c4 <Lc_aec_reference_cleanup_sidetone_graph_6>:
    {
        cbuffer_destroy_struct(op_extra_data->sidetone_mic_buf);
842025c4:	ff fd 81 f0 	call (m) 0x12834;
842025c8:	31 e3 
        op_extra_data->sidetone_mic_buf = NULL;
842025ca:	60 f0 9a 8e 	M[r4 + 616] = Null;

842025ce <Lc_aec_reference_cleanup_sidetone_graph_7>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: SIDETONE graph's cleanup done!" );
}
842025ce:	f1 48       	popm <FP, r4, rLink>;
842025d0:	d8 4c       	rts;

842025d2 <$_create_aec_ref_spkr_op>:

/*
 * create_insert_op
 */
cbops_op* create_aec_ref_spkr_op(unsigned nr_inputs,unsigned* input_idx,unsigned in_threshold,unsigned nr_outputs,unsigned* output_idx,unsigned out_threshold, unsigned max_jitter)
{
842025d2:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842025d4:	10 09       	r6 = r0 + Null;
842025d6:	19 09       	r7 = r1 + Null;
842025d8:	22 09       	r8 = r2 + Null;
842025da:	2e 00       	r4 = r3 + Null;
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_op, nr_inputs, nr_outputs));
842025dc:	c3 20       	r1 = Null + 3;
842025de:	8f f6 02 c0 	r0 = r4 + r6;
842025e2:	52 54       	r0 = r0 LSHIFT 2;
842025e4:	12 39       	r0 = r0 + 52;
842025e6:	ff fd 14 f0 	call (m) 0x4f2a;
842025ea:	25 ea 
842025ec:	17 00       	r5 = r0 + Null;

    if(op)
842025ee:	16 60       	if EQ jump (m) Lc_create_aec_ref_spkr_op_3;

842025f0 <Lc_create_aec_ref_spkr_op_2>:
    {
        cbops_aec_ref_op *params;
        
        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_spkr_table;
842025f0:	07 f0 01 f0 	rMAC = Null + 7340356;
842025f4:	44 41 
842025f6:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_op*)cbops_populate_param_hdr(op, nr_inputs, nr_outputs, input_idx, output_idx);
842025f8:	f9 d9       	rMAC = M[FP + -4];
842025fa:	09 1c       	pushm <rMAC>;
842025fc:	4d 08       	r3 = r7 + Null;
842025fe:	34 00       	r2 = r4 + Null;
84202600:	43 08       	r1 = r6 + Null;
84202602:	ff fd a4 f0 	call (m) 0x16f30;
84202606:	2f e9 
84202608:	7f 4c       	SP = SP + -4;

        /* Setup cbop-specific parameters - well, just one in this case. Just exemplifies using the
         * generic macro, but in this cbop's case we could get to the param location "directly"
         */
        params->in_threshold  = in_threshold;
8420260a:	2a f0 00 ee 	M[r0 + Null] = r8;
        params->max_advance   = out_threshold;
8420260e:	f1 d9       	rMAC = M[FP + -8];
84202610:	51 8e       	M[r0 + 4] = rMAC;
        params->max_jitter   = max_jitter;        
84202612:	e9 d9       	rMAC = M[FP + -12];
84202614:	91 8f       	M[r0 + 24] = rMAC;
        
        params->buffer_adj = 3;
84202616:	c1 20       	rMAC = Null + 3;
84202618:	91 8e       	M[r0 + 8] = rMAC;

8420261a <Lc_create_aec_ref_spkr_op_3>:
    }

    return(op);
8420261a:	3a 00       	r0 = r5 + Null;

8420261c <Lc_create_aec_ref_spkr_op_4>:
}
8420261c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420261e:	d8 4c       	rts;

84202620 <$_aec_reference_spkr_ttp_run>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param error current TTP error in speaker path
 * \param max_to_process Pointer max amount of data available to process by speaker cbops
 */
void aec_reference_spkr_ttp_run(AEC_REFERENCE_OP_DATA  *op_extra_data, unsigned *max_to_process)
{
84202620:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202622:	16 00       	r4 = r0 + Null;
84202624:	1a 09       	r8 = r1 + Null;
    TIME_INTERVAL error = 0;
84202626:	38 de       	M[FP + 28] = Null;
    bool error_valid;
    unsigned amount_can_process = *max_to_process;
84202628:	a8 f0 00 e8 	r6 = M[r8 + Null];
    /* only used for debug log */
    TIME current_time = hal_get_time();
8420262c:	ff fd 78 f1 	call (m) 0x317e8;
84202630:	3d ed 
84202632:	11 09       	r7 = r0 + Null;

    patch_fn_shared(aec_reference_run);

    /* calculate current TTP error */
    error_valid = aec_reference_spkr_ttp_get_error(op_extra_data, &error);
84202634:	c3 11       	r1 = FP + 28;
84202636:	32 00       	r0 = r4 + Null;
84202638:	9d 4e       	call (m) Lc_aec_reference_spkr_ttp_get_error_1;

    /* see if we have received void tags while in TTP mode */
    if(op_extra_data->spkr_void_tag_observed)
8420263a:	60 f0 b5 88 	Null = M[r4 + 724];
8420263e:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_4;

84202640 <Lc_aec_reference_spkr_ttp_run_2>:
    {
        /* increment a counter, so this shows the time that we have
         * continuously seen void tag
         */
        op_extra_data->spkr_void_tag_counter++;
84202640:	61 f0 b6 88 	rMAC = M[r4 + 728];
84202644:	49 20       	rMAC = rMAC + 1;
84202646:	61 f0 b6 8e 	M[r4 + 728] = rMAC;

        if(op_extra_data->spkr_void_tag_counter == SPKR_TTP_VOID_TAG_COOL_OFF_TIME_MS)
8420264a:	88 3c       	Null = rMAC - 50;
8420264c:	06 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_5;

8420264e <Lc_aec_reference_spkr_ttp_run_3>:
             */

            /* error isn't valid anymore, only seeing a timestamp tag will
             * make it valid again
             */
            op_extra_data->spkr_last_timestamp_valid = FALSE;
8420264e:	60 f0 b4 8e 	M[r4 + 720] = Null;
84202652:	74 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_23;

84202654 <Lc_aec_reference_spkr_ttp_run_4>:
            error_valid = FALSE;
        }
    }
    else
    {
        op_extra_data->spkr_void_tag_counter = 0;
84202654:	60 f0 b6 8e 	M[r4 + 728] = Null;

84202658 <Lc_aec_reference_spkr_ttp_run_5>:
    }

    if(!error_valid)
84202658:	10 04       	Null = r0 - Null;
8420265a:	70 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_23;

8420265c <Lc_aec_reference_spkr_ttp_run_6>:
    L2_DBG_MSG2("AEC REFERENCE SPEAKER: time=%d, ttp error=%d", current_time, error);
#endif

    /* See if the input is too late */
    if(error < -op_extra_data->spkr_error_threshold &&
       amount_can_process > 0)
8420265c:	39 d8       	rMAC = M[FP + 28];
8420265e:	62 f0 b7 88 	r0 = M[r4 + 732];
84202662:	82 04       	r0 = Null - r0;
84202664:	88 04       	Null = rMAC - r0;
84202666:	30 66       	if GE jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202668 <Lc_aec_reference_spkr_ttp_run_7>:
84202668:	0f f8 00 c2 	Null = r6 - Null;
8420266c:	2d 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_13;

8420266e <Lc_aec_reference_spkr_ttp_run_8>:
    {
        /* Calculate how many samples we are late,
         * we discard late samples, as much as available
         */
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);
8420266e:	63 f0 64 88 	r1 = M[r4 + 400];
84202672:	42 04       	r0 = Null - rMAC;
84202674:	ff fd 99 f0 	call (m) 0x15932;
84202678:	3f e5 
8420267a:	13 00       	r1 = r0 + Null;

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);
8420267c:	2f f8 00 c2 	Null = r6 - r0;
84202680:	02 f0 e9 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_15;

84202684 <Lc_aec_reference_spkr_ttp_run_9>:
84202684:	43 08       	r1 = r6 + Null;

84202686 <Lc_aec_reference_spkr_ttp_run_10>:

        if(samples_to_trash > 0)
        {
            /* We have something to trash */
            unsigned samples_trashed = aec_reference_spkr_ttp_discard_samples(op_extra_data,samples_to_trash);
84202686:	32 00       	r0 = r4 + Null;
84202688:	ff fd 2f f1 	call (m) 0x284f4;
8420268c:	2d e3 
8420268e:	17 00       	r5 = r0 + Null;
            L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP - discard samples=%d, time =%d , error=%d",
                        samples_trashed, current_time, error);
84202690:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84202694:	c8 24       	Null = rMAC - 3;
84202696:	0a 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_12;

84202698 <Lc_aec_reference_spkr_ttp_run_11>:
84202698:	3d d8       	r3 = M[FP + 28];
8420269a:	55 f1 02 f0 	r0 = Null + 357564977;
8420269e:	31 42 
842026a0:	4c 08       	r2 = r7 + Null;
842026a2:	3b 00       	r1 = r5 + Null;
842026a4:	ef fd f1 ff 	call (m) 0x9de;
842026a8:	3b e9 

842026aa <Lc_aec_reference_spkr_ttp_run_12>:

            /* some samples discarded, update error */
            error += convert_samples_to_time(samples_trashed, op_extra_data->input_rate);
842026aa:	63 f0 64 88 	r1 = M[r4 + 400];
842026ae:	3a 00       	r0 = r5 + Null;
842026b0:	ff fd 99 f0 	call (m) 0x15914;
842026b4:	25 e3 
842026b6:	39 d8       	rMAC = M[FP + 28];
842026b8:	51 00       	rMAC = r0 + rMAC;
842026ba:	39 de       	M[FP + 28] = rMAC;

            /* update amount left to process */
            amount_can_process -= samples_trashed;
842026bc:	00 f7 38 c2 	r6 = r6 - r5;

            /* ttp play back needs resetting */
            aec_reference_spkr_ttp_reset(op_extra_data);
842026c0:	32 00       	r0 = r4 + Null;
842026c2:	01 f0 2d e4 	call (m) Lc_aec_reference_spkr_ttp_reset_1;

842026c6 <Lc_aec_reference_spkr_ttp_run_13>:
        }
    }

    if (pl_abs_i32(error) < op_extra_data->spkr_error_threshold)
842026c6:	3a d8       	r0 = M[FP + 28];
842026c8:	61 f0 b7 88 	rMAC = M[r4 + 732];
842026cc:	4f f2 42 ce 	r0 = ABS r0;
842026d0:	50 04       	Null = r0 - rMAC;
842026d2:	02 f0 9d e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_16;

842026d6 <Lc_aec_reference_spkr_ttp_run_14>:
    {
        /* This is normal situation, we have on-time input
         * and we can control ttp error
         */
        aec_reference_spkr_ttp_error_control(op_extra_data, error);
842026d6:	3b d8       	r1 = M[FP + 28];
842026d8:	32 00       	r0 = r4 + Null;
842026da:	01 f0 39 e4 	call (m) Lc_aec_reference_spkr_ttp_error_control_1;

        /* real audio is played, go to higher threshold */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_HIGH_THRESHOLD_US;
842026de:	01 f0 d0 4b 	rMAC = Null + 2000;
842026e2:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
842026e6:	28 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_22;

842026e8 <Lc_aec_reference_spkr_ttp_run_15>:
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);

        if(samples_to_trash > 0)
842026e8:	10 04       	Null = r0 - Null;
842026ea:	ce 63       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_10;

842026ec <Lc_4>:
842026ec:	ed 6f       	jump (m) Lc_aec_reference_spkr_ttp_run_13;

842026ee <Lc_aec_reference_spkr_ttp_run_16>:
    {
        /* Input is early, so we cannot allow samples from input buffers to be played now
         * instead we need to insert silence until time to play has reached. Silence insertion
         * is managed by cbops, we only tell cbops not to use samples from input buffer.
         */
        unsigned samples_early = convert_time_to_samples((unsigned)(error), op_extra_data->input_rate);
842026ee:	63 f0 64 88 	r1 = M[r4 + 400];
842026f2:	3a d8       	r0 = M[FP + 28];
842026f4:	ff fd 99 f0 	call (m) 0x15932;
842026f8:	3f e1 
        if(samples_early >= op_extra_data->spkr_in_threshold)
842026fa:	63 f0 af 88 	r1 = M[r4 + 700];
842026fe:	d0 04       	Null = r0 - r1;
84202700:	03 64       	if NC jump (m) Lc_aec_reference_spkr_ttp_run_18;

84202702 <Lc_aec_reference_spkr_ttp_run_17>:
        {
            /* It's early more than the amount cbops is expected to copy,
             * so allow nothing to copy.
             */
            amount_can_process = 0;
84202702:	00 09       	r6 = Null + Null;
84202704:	07 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202706 <Lc_aec_reference_spkr_ttp_run_18>:
        {
            /* It's still early but less than the expected amount, we allow cbops to consume
             * expected amount less the amount early, silence insertion will be used for the amount early.
             * next time we expect to switch to normal TTP playback.
             */
            amount_can_process = MIN(op_extra_data->spkr_in_threshold - samples_early, amount_can_process);
84202706:	99 04       	rMAC = r1 - r0;
84202708:	8f f1 00 c2 	Null = rMAC - r6;
8420270c:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202710 <Lc_aec_reference_spkr_ttp_run_19>:
84202710:	08 09       	r6 = rMAC + Null;

84202712 <Lc_aec_reference_spkr_ttp_run_20>:
        }

        /* We are not playing real audio, so keep the threshold low */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202712:	01 f0 fa 40 	rMAC = Null + 250;
84202716:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

        L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP: possible silence insertion: time=%d, samples=%d, max_proc=%d",
                    current_time, op_extra_data->spkr_in_threshold-amount_can_process, amount_can_process);
8420271a:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
8420271e:	c8 24       	Null = rMAC - 3;
84202720:	0b 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202722 <Lc_aec_reference_spkr_ttp_run_21>:
84202722:	8f f3 04 c2 	r2 = r1 - r6;
84202726:	55 f1 02 f0 	r0 = Null + 357565045;
8420272a:	75 42 
8420272c:	45 08       	r3 = r6 + Null;
8420272e:	4b 08       	r1 = r7 + Null;
84202730:	ef fd f1 ff 	call (m) 0x9de;
84202734:	2f e5 

84202736 <Lc_aec_reference_spkr_ttp_run_22>:

    }

    /* update amount to process */
    *max_to_process = amount_can_process;
84202736:	a8 f0 00 ee 	M[r8 + Null] = r6;

8420273a <Lc_aec_reference_spkr_ttp_run_23>:
    return;
}
8420273a:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
8420273c:	d8 4c       	rts;

8420273e <$_aec_reference_spkr_ttp_init>:
8420273e:	d8 4c       	rts;

84202740 <$_aec_reference_spkr_ttp_update_last_timestamp>:
 *        stamp associated with last consumed sample.
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param amount_read amount read from input buffer
 */
void aec_reference_spkr_ttp_update_last_timestamp(AEC_REFERENCE_OP_DATA   *op_extra_data, unsigned amount_read)
{
84202740:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202742:	16 00       	r4 = r0 + Null;
84202744:	1a 00       	r0 = r1 + Null;
    if(op_extra_data->spkr_last_timestamp_valid)
84202746:	60 f0 b4 88 	Null = M[r4 + 720];
8420274a:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_update_last_timestamp_3;

8420274c <Lc_aec_reference_spkr_ttp_update_last_timestamp_2>:
    {
        /* work out time stamp for next input block for the just read block,
         * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
        TIME_INTERVAL time_passed = convert_samples_to_time(amount_read, op_extra_data->input_rate);
8420274c:	63 f0 64 88 	r1 = M[r4 + 400];
84202750:	ff fd 98 f0 	call (m) 0x15914;
84202754:	25 ee 
        op_extra_data->spkr_last_timestamp = time_add(op_extra_data->spkr_last_timestamp, time_passed);
84202756:	61 f0 b3 88 	rMAC = M[r4 + 716];
8420275a:	51 00       	rMAC = r0 + rMAC;
8420275c:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

84202760 <Lc_aec_reference_spkr_ttp_update_last_timestamp_3>:
    }
}
84202760:	f1 48       	popm <FP, r4, rLink>;
84202762:	d8 4c       	rts;

84202764 <$_aec_reference_spkr_ttp_terminate>:
 */
void aec_reference_spkr_ttp_terminate(AEC_REFERENCE_OP_DATA  *op_extra_data)
{
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_timed_playback_mode = FALSE;
84202764:	20 f0 b2 8e 	M[r0 + 712] = Null;
    op_extra_data->spkr_last_timestamp_valid = 0;
84202768:	20 f0 b4 8e 	M[r0 + 720] = Null;
    op_extra_data->spkr_void_tag_counter = 0;
8420276c:	20 f0 b6 8e 	M[r0 + 728] = Null;

84202770 <Lc_aec_reference_spkr_ttp_terminate_2>:
84202770:	d8 4c       	rts;

84202772 <Lc_aec_reference_spkr_ttp_get_error_1>:
 *        and (estimated) actual playback time. So the error will be
 *        positive if ttp is later than actual playback time.
 * return whether the error is valid
 */
static bool aec_reference_spkr_ttp_get_error(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL *error)
{
84202772:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84202774:	16 00       	r4 = r0 + Null;
84202776:	18 09       	r6 = r1 + Null;
    /* see if we have valid metadata buffer */
    tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
    patch_fn_shared(aec_reference_run);

    if (met_buf!= NULL && buff_has_metadata(met_buf))
84202778:	62 f0 c9 88 	r0 = M[r4 + 804];
8420277c:	90 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_22;

8420277e <Lc_aec_reference_spkr_ttp_get_error_2>:
8420277e:	51 89       	rMAC = M[r0 + 20];
84202780:	49 c6       	rMAC = rMAC AND 0x8000;
84202782:	8d 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_22;

84202784 <Lc_aec_reference_spkr_ttp_get_error_3>:
    {
        /* see if input has a timestamped tag */
        unsigned b4idx = 0;
84202784:	30 de       	M[FP + 24] = Null;
        metadata_tag *mtag = buff_metadata_peek_ex(met_buf, &b4idx);
84202786:	83 11       	r1 = FP + 24;
84202788:	ff fd 7a f0 	call (m) 0x11cd8;
8420278c:	31 ea 
8420278e:	17 00       	r5 = r0 + Null;

        if(mtag != NULL)
84202790:	58 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_17;

84202792 <Lc_aec_reference_spkr_ttp_get_error_4>:
        {
            if(IS_TIMESTAMPED_TAG(mtag))
84202792:	79 88       	rMAC = M[r5 + 4];
84202794:	12 f0 30 00 	r0 = rMAC AND 0x30;
84202798:	47 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_13;

8420279a <Lc_aec_reference_spkr_ttp_get_error_5>:
8420279a:	ca c2       	r0 = rMAC AND 0x40;
8420279c:	45 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_13;

8420279e <Lc_aec_reference_spkr_ttp_get_error_6>:
            {
                unsigned *err_offset_id;
                unsigned out_length;

                /* go back to first input sample */
                TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE, op_extra_data->input_rate);
8420279e:	63 f0 64 88 	r1 = M[r4 + 400];
842027a2:	32 d8       	r0 = M[FP + 24];
842027a4:	52 50       	r0 = r0 LSHIFT -2;
842027a6:	ff fd 98 f0 	call (m) 0x15914;
842027aa:	2f eb 

                /* set the time stamp,
                 * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
                op_extra_data->spkr_last_timestamp = time_sub(mtag->timestamp, time_back);
842027ac:	39 89       	rMAC = M[r5 + 16];
842027ae:	89 04       	rMAC = rMAC - r0;
842027b0:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

                /* See if tag's timestamp has an offset*/
                if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                    (void **)&err_offset_id))
842027b4:	c5 11       	r3 = FP + 28;
842027b6:	04 12       	r2 = FP + 32;
842027b8:	43 20       	r1 = Null + 1;
842027ba:	3a 00       	r0 = r5 + Null;
842027bc:	ff fd 79 f0 	call (m) 0x11a84;
842027c0:	29 e6 
842027c2:	10 04       	Null = r0 - Null;
842027c4:	0e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

842027c6 <Lc_aec_reference_spkr_ttp_get_error_7>:
                {
                    int *err_offset_ptr = ttp_info_get(*err_offset_id);
842027c6:	39 d8       	rMAC = M[FP + 28];
842027c8:	0a e8       	r0 = M[rMAC + Null];
842027ca:	ff fd a1 f0 	call (m) 0x16bb8;
842027ce:	2f ef 
                    if (err_offset_ptr != NULL)
842027d0:	10 04       	Null = r0 - Null;
842027d2:	07 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

842027d4 <Lc_aec_reference_spkr_ttp_get_error_8>:
                    {
                        /* subtract the offset */
                        op_extra_data->spkr_last_timestamp =
                            time_sub(op_extra_data->spkr_last_timestamp, *err_offset_ptr);
842027d4:	61 f0 b3 88 	rMAC = M[r4 + 716];
842027d8:	12 e8       	r0 = M[r0 + Null];
842027da:	89 04       	rMAC = rMAC - r0;
842027dc:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

842027e0 <Lc_aec_reference_spkr_ttp_get_error_9>:
                    }
                }

                /* this will stay valid */
                op_extra_data->spkr_last_timestamp_valid = TRUE;
842027e0:	41 20       	rMAC = Null + 1;
842027e2:	61 f0 b4 8e 	M[r4 + 720] = rMAC;

                /* switch to timed playback mode if not already,
                 * this is irreversible
                 */
                if(!op_extra_data->spkr_timed_playback_mode)
842027e6:	60 f0 b2 88 	Null = M[r4 + 712];
842027ea:	1b 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

842027ec <Lc_aec_reference_spkr_ttp_get_error_10>:
                    /* For the first time we have seen a timestamp,
                     * This means the metadata buffer will supply timestamp tags
                     * that are required for timed playback. Now is the time to
                     * switch to timed playback mode for speaker graph.
                     */
                    op_extra_data->spkr_timed_playback_mode = aec_reference_spkr_ttp_setup_timed_playback(op_extra_data);
842027ec:	32 00       	r0 = r4 + Null;
842027ee:	5a 4e       	call (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_1;
842027f0:	62 f0 b2 8e 	M[r4 + 712] = r0;
                    if(op_extra_data->spkr_timed_playback_mode)
842027f4:	60 f0 b2 88 	Null = M[r4 + 712];
842027f8:	14 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

842027fa <Lc_aec_reference_spkr_ttp_get_error_11>:
                        /* tell the endpoint that speaker is performing rate adjustment, normally
                         * this is done when enacting config is received from framework, however
                         * in case we haven't received (can happen if input is coming from a2dp
                         * source) we do it here.
                         */
                        set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint, TRUE);
842027fa:	43 20       	r1 = Null + 1;
842027fc:	62 f0 80 88 	r0 = M[r4 + 512];
84202800:	ff fd 11 f0 	call (m) 0x4a3e;
84202804:	3f e1 

                        /* tell the overridden endpoint that we are in timed playback mode,
                         * this is to prevent extra accumulation of HW warps in endpoint so it
                         * won't mess with PID controller. (only nedded for hw rate adjust)
                         */
                        set_override_ep_set_hw_warp_apply_mode(op_extra_data->spkr_endpoint, TRUE);
84202806:	43 20       	r1 = Null + 1;
84202808:	62 f0 80 88 	r0 = M[r4 + 512];
8420280c:	01 f0 23 ef 	call (m) $_set_override_ep_set_hw_warp_apply_mode;

                        L2_DBG_MSG1("AEC REFERENCE: Speaker graph switched to timed play back mode: %d",
                                    op_extra_data->spkr_timed_playback_mode);
84202810:	63 f0 b2 88 	r1 = M[r4 + 712];
84202814:	55 f1 02 f0 	r0 = Null + 357565133;
84202818:	cd 42 
8420281a:	ef fd f0 ff 	call (m) 0x9b4;
8420281e:	3b ec 

84202820 <Lc_aec_reference_spkr_ttp_get_error_12>:
                    L2_DBG_MSG2("AEC REFERENCE, stopped seeing VOID tags, time=%d, %d",
                                hal_get_time(), op_extra_data->spkr_void_tag_counter);
                }
#endif
                /* void tag not seen */
                op_extra_data->spkr_void_tag_observed = FALSE;
84202820:	60 f0 b5 8e 	M[r4 + 724] = Null;
84202824:	0e 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_17;

84202826 <Lc_aec_reference_spkr_ttp_get_error_13>:

            } /* IS_TIMESTAMPED_TAG(mtag) */
            else if(IS_VOID_TTP_TAG(mtag) && op_extra_data->spkr_timed_playback_mode)
84202826:	11 f0 70 00 	rMAC = rMAC AND 0x70;
8420282a:	10 f0 50 24 	Null = rMAC - 80;
8420282e:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_17;

84202830 <Lc_aec_reference_spkr_ttp_get_error_14>:
84202830:	38 89       	Null = M[r5 + 16];
84202832:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_17;

84202834 <Lc_aec_reference_spkr_ttp_get_error_15>:
84202834:	60 f0 b2 88 	Null = M[r4 + 712];
84202838:	04 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_17;

8420283a <Lc_aec_reference_spkr_ttp_get_error_16>:
                if(!op_extra_data->spkr_void_tag_observed)
                {
                    L2_DBG_MSG1("AEC REFERENCE, started seeing VOID tags, time=%d", hal_get_time());
                }
#endif
                op_extra_data->spkr_void_tag_observed = TRUE;
8420283a:	41 20       	rMAC = Null + 1;
8420283c:	61 f0 b5 8e 	M[r4 + 724] = rMAC;

84202840 <Lc_aec_reference_spkr_ttp_get_error_17>:
            }
        } /* if(mtag != NULL) */

        if(op_extra_data->spkr_last_timestamp_valid)
84202840:	60 f0 b4 88 	Null = M[r4 + 720];
84202844:	29 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_21;

84202846 <Lc_aec_reference_spkr_ttp_get_error_18>:
             *
             * TODO_AEC_REFERENCE_TTP: since the task for speaker graph is timer based, the time
             * of sampling isn't aligned with the output consuming time, so it
             * could have up to one sample period random jitter.
             */
            TIME cur_time = hal_get_time();
84202846:	ff fd 77 f1 	call (m) 0x317e8;
8420284a:	23 ed 
8420284c:	17 00       	r5 = r0 + Null;
            unsigned amount_in_output = cbuffer_calc_amount_data_in_words(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
8420284e:	72 a8       	r0 = M[r4 + 68];
84202850:	ff fd 4c f1 	call (m) 0x2c208;
84202854:	39 ed 
            TIME_INTERVAL offset = convert_samples_to_time(amount_in_output, op_extra_data->spkr_rate);
84202856:	63 f0 6e 88 	r1 = M[r4 + 440];
8420285a:	ff fd 98 f0 	call (m) 0x15914;
8420285e:	3b e5 
84202860:	11 09       	r7 = r0 + Null;
84202862:	49 08       	rMAC = r7 + Null;

            /* if we have SW rate adjustment in the graph */
            if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202864:	62 f0 7e 88 	r0 = M[r4 + 504];
84202868:	0f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_20;

8420286a <Lc_aec_reference_spkr_ttp_get_error_19>:
            {
                /* adjust for the phase difference between first input and first output sample */
                offset -= (int)frac_mult(SECOND, (int)cbops_sra_get_phase(op_extra_data->spkr_sw_rateadj_op)) / (int) op_extra_data->spkr_rate;
8420286a:	ff fd a2 f0 	call (m) 0x16d48;
8420286e:	3f e6 
84202870:	00 f0 a3 f7 	r1 = Null + 1000000;
84202874:	40 42 
84202876:	61 f0 6e 88 	rMAC = M[r4 + 440];
8420287a:	2f f3 42 c9 	r0 = r1 * r0 (frac);
8420287e:	8a 4c       	Div = r0 / rMAC;
84202880:	c1 4c       	rMAC = DivResult;
84202882:	1f f9 01 c2 	rMAC = r7 - rMAC;

84202886 <Lc_aec_reference_spkr_ttp_get_error_20>:
            /* Add extra delay that might occur in the path
             * (adjustment for any resampler, HW rate matching,
             *  cbops algorithmic delays and any external delay)
             * TODO_AEC_REFERENCE_TTP: spkr_extra_delay isn't set yet
             */
            offset += op_extra_data->spkr_extra_delay;
84202886:	62 f0 bb 88 	r0 = M[r4 + 748];
8420288a:	51 00       	rMAC = r0 + rMAC;

            /* compute error */
            *error = time_sub(op_extra_data->spkr_last_timestamp, cur_time) - offset;
8420288c:	62 f0 b3 88 	r0 = M[r4 + 716];
84202890:	d2 05       	r0 = r0 - r5;
84202892:	1f f2 88 c3 	M[r6] = r0 - rMAC;

84202896 <Lc_aec_reference_spkr_ttp_get_error_21>:
        }

        return op_extra_data->spkr_last_timestamp_valid;
84202896:	62 f0 b4 88 	r0 = M[r4 + 720];
8420289a:	02 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_23;

8420289c <Lc_aec_reference_spkr_ttp_get_error_22>:
    } /* buff_has_metadata  */

    /* always return invalid error if we don't have metadata buffer */
    return FALSE;
8420289c:	02 00       	r0 = Null + Null;

8420289e <Lc_aec_reference_spkr_ttp_get_error_23>:
}
8420289e:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
842028a0:	d8 4c       	rts;

842028a2 <Lc_aec_reference_spkr_ttp_setup_timed_playback_1>:
 *
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * return TRUE if setting up was successful else FALSE.
 */
static bool aec_reference_spkr_ttp_setup_timed_playback(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842028a2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842028a4:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* initialise pid controller parameters */
    timed_set_pid_controller_default_settings(&op_extra_data->spkr_pid_params);
842028a6:	62 f0 f4 22 	r0 = r4 + 756;
842028aa:	ff fd 96 f0 	call (m) 0x1557c;
842028ae:	33 e6 



    /* reset speaker ttp control */
    aec_reference_spkr_ttp_reset(op_extra_data);
842028b0:	32 00       	r0 = r4 + Null;
842028b2:	4e 4e       	call (m) Lc_aec_reference_spkr_ttp_reset_1;

    /* use ttp SW rate adjust if speaker is capable */
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
842028b4:	61 f0 6f 88 	rMAC = M[r4 + 444];
842028b8:	88 24       	Null = rMAC - 2;
842028ba:	17 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_6;

842028bc <Lc_aec_reference_spkr_ttp_setup_timed_playback_2>:
    {
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_HW;
842028bc:	81 20       	rMAC = Null + 2;
842028be:	61 f0 bc 8e 	M[r4 + 752] = rMAC;

        /* we want to do HW rate matching in timed playback mode */
        if(op_extra_data->spkr_sw_rateadj_op != NULL)
842028c2:	62 f0 7e 88 	r0 = M[r4 + 504];
842028c6:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_4;

842028c8 <Lc_aec_reference_spkr_ttp_setup_timed_playback_3>:
        {
            /* if we have SW rate adjust, then set it to pass-through mode */
            cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, TRUE);
842028c8:	43 20       	r1 = Null + 1;
842028ca:	ff fd a1 f0 	call (m) 0x16c96;
842028ce:	2d ee 

842028d0 <Lc_aec_reference_spkr_ttp_setup_timed_playback_4>:
        }

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
842028d0:	62 f0 80 88 	r0 = M[r4 + 512];
842028d4:	03 00       	r1 = Null + Null;
842028d6:	ff fd 10 f0 	call (m) 0x4aa0;
842028da:	2b ee 

842028dc <Lc_aec_reference_spkr_ttp_setup_timed_playback_5>:
         */
        return FALSE;
    }

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
842028dc:	61 f0 6f 88 	rMAC = M[r4 + 444];
842028e0:	61 f0 71 8e 	M[r4 + 452] = rMAC;

    return TRUE;
842028e4:	42 20       	r0 = Null + 1;
842028e6:	32 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

842028e8 <Lc_aec_reference_spkr_ttp_setup_timed_playback_6>:

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
    }
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
    else if(0 != op_extra_data->spkr_ext_rate_adjust_op)
842028e8:	62 f0 ae 88 	r0 = M[r4 + 696];
842028ec:	19 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_9;

842028ee <Lc_aec_reference_spkr_ttp_setup_timed_playback_7>:
    {
        /* we will do software TTP using a standalone rate adjust operator */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
842028ee:	41 20       	rMAC = Null + 1;
842028f0:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment = 0;
842028f4:	60 f0 70 8e 	M[r4 + 448] = Null;

        /* reset the current rate */
        stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, 0);
842028f8:	03 00       	r1 = Null + Null;
842028fa:	01 f0 39 eb 	call (m) $_stream_delegate_rate_adjust_set_current_rate;

        /* not in passthrough mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
842028fe:	62 f0 ae 88 	r0 = M[r4 + 696];
84202902:	03 00       	r1 = Null + Null;
84202904:	01 f0 27 ea 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        /* we shouldn't have created built-in rate adjust operator */
        PL_ASSERT(op_extra_data->spkr_sw_rateadj_op == NULL);
84202908:	61 f0 7e 88 	rMAC = M[r4 + 504];
8420290c:	e8 61       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

8420290e <Lc_aec_reference_spkr_ttp_setup_timed_playback_8>:
8420290e:	03 f0 f5 41 	r1 = Null + 501;
84202912:	02 f0 13 60 	r0 = Null + 4115;
84202916:	ff fd 8a f0 	call (m) 0x13f12;
8420291a:	3d ef 
8420291c:	17 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

8420291e <Lc_aec_reference_spkr_ttp_setup_timed_playback_9>:
    }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
    else if(op_extra_data->spkr_sw_rateadj_op != NULL)
8420291e:	62 f0 7e 88 	r0 = M[r4 + 504];
84202922:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_11;

84202924 <Lc_aec_reference_spkr_ttp_setup_timed_playback_10>:
    {
        /* We have a rate adjust operator, so we can do software TTP */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84202924:	41 20       	rMAC = Null + 1;
84202926:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment=0;
8420292a:	60 f0 70 8e 	M[r4 + 448] = Null;
        cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, 0);
8420292e:	63 f0 77 88 	r1 = M[r4 + 476];
84202932:	04 00       	r2 = Null + Null;
84202934:	ff fd a1 f0 	call (m) 0x16c9c;
84202938:	29 eb 
		/* force coming out of pass-through mode */
        cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, FALSE);
8420293a:	62 f0 7e 88 	r0 = M[r4 + 504];
8420293e:	03 00       	r1 = Null + Null;
84202940:	ff fd a1 f0 	call (m) 0x16c96;
84202944:	37 ea 
84202946:	cb 6f       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

84202948 <Lc_aec_reference_spkr_ttp_setup_timed_playback_11>:
    else
    {
        /* For doing TTP playback either it should support HW rate adjustment
         * or have a SW rate adjust operator in the graph.
         */
        return FALSE;
84202948:	02 00       	r0 = Null + Null;

8420294a <Lc_aec_reference_spkr_ttp_setup_timed_playback_12>:

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;

    return TRUE;
}
8420294a:	f1 48       	popm <FP, r4, rLink>;
8420294c:	d8 4c       	rts;

8420294e <Lc_aec_reference_spkr_ttp_reset_1>:
 * \brief reset timed playback mode internal state
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected ttp and now
 */
static void aec_reference_spkr_ttp_reset(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420294e:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_ttp_error_acc = 0;
84202950:	20 f0 b9 8e 	M[r0 + 740] = Null;
    op_extra_data->spkr_ttp_error_acc_cnt = 0;
84202954:	20 f0 ba 8e 	M[r0 + 744] = Null;
    op_extra_data->spkr_last_ttp_error = 0;
84202958:	20 f0 b8 8e 	M[r0 + 736] = Null;
    op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
8420295c:	01 f0 fa 40 	rMAC = Null + 250;
84202960:	21 f0 b7 8e 	M[r0 + 732] = rMAC;

    /* pid controller will be started */
    timed_reset_pid_controller(&op_extra_data->spkr_pid_state);
84202964:	02 f0 08 47 	r0 = r0 + 776;
84202968:	ff fd 95 f0 	call (m) 0x15562;
8420296c:	3b ef 

8420296e <Lc_aec_reference_spkr_ttp_reset_2>:
}
8420296e:	c8 48       	popm <FP, rLink>;
84202970:	d8 4c       	rts;

84202972 <Lc_aec_reference_spkr_ttp_error_control_1>:
 * \brief running PID controller to minimise the ttp error
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected and estimated time to play
 */
static void aec_reference_spkr_ttp_error_control(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL error)
{
84202972:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202974:	16 00       	r4 = r0 + Null;
    int error_diff;
    patch_fn_shared(aec_reference);

    /* ignore the error if we have a big jump in error */
    error_diff = error - op_extra_data->spkr_last_ttp_error;
84202976:	61 f0 b8 88 	rMAC = M[r4 + 736];
8420297a:	5a 04       	r0 = r1 - rMAC;
    op_extra_data->spkr_last_ttp_error = error;
8420297c:	63 f0 b8 8e 	M[r4 + 736] = r1;
    if (pl_abs_i32(error_diff) > SPKR_TTP_MAX_ERROR_JUMP_US)
84202980:	4f f2 42 ce 	r0 = ABS r0;
84202984:	90 3c       	Null = r0 - 50;
84202986:	08 f0 c5 e0 	if HI jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

8420298a <Lc_aec_reference_spkr_ttp_error_control_2>:
    {
        return;
    }

    /* accumulate error for averaging */
    op_extra_data->spkr_ttp_error_acc_cnt++;
8420298a:	61 f0 ba 88 	rMAC = M[r4 + 744];
8420298e:	49 20       	rMAC = rMAC + 1;
84202990:	61 f0 ba 8e 	M[r4 + 744] = rMAC;
    op_extra_data->spkr_ttp_error_acc += error;
84202994:	62 f0 b9 88 	r0 = M[r4 + 740];
84202998:	9a 00       	r0 = r1 + r0;
8420299a:	62 f0 b9 8e 	M[r4 + 740] = r0;
    if(op_extra_data->spkr_ttp_error_acc_cnt == SPKR_TTP_ERROR_AVERAGING_PERIOD_MS)
8420299e:	88 26       	Null = rMAC - 10;
842029a0:	15 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

842029a2 <Lc_aec_reference_spkr_ttp_error_control_3>:
    {
        /* calculate average error */
        int error_avg = frac_mult(op_extra_data->spkr_ttp_error_acc,
                                  FRACTIONAL(1.0/SPKR_TTP_ERROR_AVERAGING_PERIOD_MS));
842029a2:	cc f0 63 f6 	r1 = Null + 214748364;
842029a6:	cc 58 
842029a8:	3f f2 44 c9 	r2 = r0 * r1 (frac);

        /* run controller to minimise the error */
        timed_run_pid_controller(&op_extra_data->spkr_pid_state, &op_extra_data->spkr_pid_params, error_avg);
842029ac:	63 f0 f4 22 	r1 = r4 + 756;
842029b0:	62 f0 08 23 	r0 = r4 + 776;
842029b4:	ff fd 95 f0 	call (m) 0x15484;
842029b8:	31 e6 
                    hal_get_time(),
                    error_avg,
                    op_extra_data->spkr_pid_state.warp);
#endif
        /* apply the last calculated warp rate */
        aec_reference_spkr_ttp_adjust_rate(op_extra_data, op_extra_data->spkr_pid_state.warp);         /* reset the averaging accumulator */
842029ba:	63 f0 c2 88 	r1 = M[r4 + 776];
842029be:	32 00       	r0 = r4 + Null;
842029c0:	07 4e       	call (m) Lc_aec_reference_spkr_ttp_adjust_rate_1;

        op_extra_data->spkr_ttp_error_acc_cnt = 0;
842029c2:	60 f0 ba 8e 	M[r4 + 744] = Null;
        op_extra_data->spkr_ttp_error_acc = 0;
842029c6:	60 f0 b9 8e 	M[r4 + 740] = Null;

842029ca <Lc_aec_reference_spkr_ttp_error_control_4>:
    }
}
842029ca:	f1 48       	popm <FP, r4, rLink>;
842029cc:	d8 4c       	rts;

842029ce <Lc_aec_reference_spkr_ttp_adjust_rate_1>:
 * \brief applies warp rate to enacting sra
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param warp warp value
 */
static void aec_reference_spkr_ttp_adjust_rate(AEC_REFERENCE_OP_DATA *op_extra_data, int warp)
{
842029ce:	c8 1c       	pushm <FP(=SP), rLink>;
842029d0:	1c 00       	r2 = r1 + Null;
    patch_fn_shared(aec_reference);

    /* expect to come here only in timed playback mode */
    PL_ASSERT(op_extra_data->spkr_timed_playback_mode);
842029d2:	20 f0 b2 88 	Null = M[r0 + 712];
842029d6:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_3;

842029d8 <Lc_aec_reference_spkr_ttp_adjust_rate_2>:
842029d8:	03 f0 5a 42 	r1 = Null + 602;
842029dc:	02 f0 13 60 	r0 = Null + 4115;
842029e0:	ff fd 8a f0 	call (m) 0x13f12;
842029e4:	33 e9 
842029e6:	1b 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

842029e8 <Lc_aec_reference_spkr_ttp_adjust_rate_3>:

    if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_HW)
842029e8:	21 f0 bc 88 	rMAC = M[r0 + 752];
842029ec:	88 24       	Null = rMAC - 2;
842029ee:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_5;

842029f0 <Lc_aec_reference_spkr_ttp_adjust_rate_4>:
    {
        /* set the HW warp value by sending that to real audio ep
         * NOTE TODO_AEC_REFERENCE_TTP: HW warp hasn't been tested */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, warp);
842029f0:	22 f0 80 88 	r0 = M[r0 + 512];
842029f4:	ff fd 10 f0 	call (m) 0x4aa0;
842029f8:	2d e5 
842029fa:	11 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

842029fc <Lc_aec_reference_spkr_ttp_adjust_rate_5>:
    }
    else if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_SW)
842029fc:	48 24       	Null = rMAC - 1;
842029fe:	0f 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202a00 <Lc_aec_reference_spkr_ttp_adjust_rate_6>:
    {
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84202a00:	21 f0 ae 88 	rMAC = M[r0 + 696];
84202a04:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_8;

84202a06 <Lc_aec_reference_spkr_ttp_adjust_rate_7>:
        {
            /* rate adjust using external rate adjust operator */
            stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, warp);
84202a06:	0a 00       	r0 = rMAC + Null;
84202a08:	01 f0 2b e3 	call (m) $_stream_delegate_rate_adjust_set_current_rate;
84202a0c:	08 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202a0e <Lc_aec_reference_spkr_ttp_adjust_rate_8>:
        }
        else
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
        {
            /* set the SW rate adjust warp value */
            cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, warp);
84202a0e:	23 f0 77 88 	r1 = M[r0 + 476];
84202a12:	22 f0 7e 88 	r0 = M[r0 + 504];
84202a16:	ff fd a1 f0 	call (m) 0x16c9c;
84202a1a:	27 e4 

84202a1c <Lc_aec_reference_spkr_ttp_adjust_rate_9>:
        }
    }
}
84202a1c:	c8 48       	popm <FP, rLink>;
84202a1e:	d8 4c       	rts;

84202a20 <$_create_aec_ref_sidetone_op>:
                                     unsigned nr_spkrs,
                                     unsigned *sidetone_idx,
                                     unsigned spkr_threshold,
                                     unsigned safety_threshold)

{
84202a20:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84202a22:	13 09       	r9 = r0 + Null;
84202a24:	1a 09       	r8 = r1 + Null;
84202a26:	21 09       	r7 = r2 + Null;
84202a28:	2f 00       	r5 = r3 + Null;
84202a2a:	ee d9       	r4 = M[FP + -12];
    cbops_op *op = NULL;
84202a2c:	02 00       	r0 = Null + Null;

    patch_fn_shared(aec_reference);

    /* sidetone can be mixed to 1 or 2 speakers only */
    if(nr_spkrs > 2)
84202a2e:	b8 24       	Null = r5 - 2;
84202a30:	09 f0 87 e0 	if LS jump (m) Lc_create_aec_ref_sidetone_op_3;

84202a34 <Lc_create_aec_ref_sidetone_op_2>:
    {
        return op;
84202a34:	2c 6e       	jump (m) Lc_create_aec_ref_sidetone_op_6;

84202a36 <Lc_create_aec_ref_sidetone_op_3>:
    }

    // cbop param struct size (header plus cbop-specific parameters)
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_sidetone_op, 1, nr_spkrs));
84202a36:	c3 20       	r1 = Null + 3;
84202a38:	7a 20       	r0 = r5 + 1;
84202a3a:	52 54       	r0 = r0 LSHIFT 2;
84202a3c:	02 f0 58 44 	r0 = r0 + 88;
84202a40:	ff fd 12 f0 	call (m) 0x4f2a;
84202a44:	2b e7 
84202a46:	10 09       	r6 = r0 + Null;
    if(op)
84202a48:	21 60       	if EQ jump (m) Lc_create_aec_ref_sidetone_op_5;

84202a4a <Lc_create_aec_ref_sidetone_op_4>:
    {
        cbops_aec_ref_sidetone_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_sidetone_table;
84202a4a:	07 f0 01 f0 	rMAC = Null + 7340368;
84202a4e:	50 41 
84202a50:	81 f0 02 8e 	M[r6 + 8] = rMAC;
        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_sidetone_op*)cbops_populate_param_hdr(op,
                                                                      1,
                                                                      0,
                                                                      sidetone_idx,
                                                                      NULL);
84202a54:	00 f0 30 cf 	push Null;
84202a58:	fd d9       	r3 = M[FP + -4];
84202a5a:	43 20       	r1 = Null + 1;
84202a5c:	04 00       	r2 = Null + Null;
84202a5e:	ff fd a2 f0 	call (m) 0x16f30;
84202a62:	33 e6 
84202a64:	7f 4c       	SP = SP + -4;

        /* Setup cbop-specific parameters */
        params->spkr_threshold  = spkr_threshold;
84202a66:	f1 d9       	rMAC = M[FP + -8];
84202a68:	51 9e       	M[r0 + 36] = rMAC;
        params->safety_threshold_low = safety_threshold;
84202a6a:	96 8f       	M[r0 + 24] = r4;
        params->safety_threshold_high = safety_threshold*2;
84202a6c:	33 54       	r1 = r4 LSHIFT 1;
84202a6e:	d3 8f       	M[r0 + 28] = r1;
        params->safety_set_threshold = (params->safety_threshold_low + params->safety_threshold_high)/2;
84202a70:	f3 00       	r1 = r4 + r1;
84202a72:	1b 50       	r1 = r1 LSHIFT -1;
84202a74:	13 9e       	M[r0 + 32] = r1;
        params->mic_buf = mic_buf;
84202a76:	2b f0 01 8e 	M[r0 + 4] = r9;
        params->spkr_bufs = spkr_bufs;
84202a7a:	29 f0 00 ee 	M[r0 + Null] = r7;
        params->mic_idx = mic_idx;
84202a7e:	2a f0 05 8e 	M[r0 + 20] = r8;
        params->nr_spkrs = nr_spkrs;
84202a82:	97 8e       	M[r0 + 8] = r5;

        /* initialise the operator */
        aec_ref_sidetone_initialise(op);
84202a84:	42 08       	r0 = r6 + Null;
84202a86:	02 f0 31 ee 	call (m) $_aec_ref_sidetone_initialise;

84202a8a <Lc_create_aec_ref_sidetone_op_5>:
    }

    return(op);
84202a8a:	42 08       	r0 = r6 + Null;

84202a8c <Lc_create_aec_ref_sidetone_op_6>:
}
84202a8c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202a8e:	d8 4c       	rts;

84202a90 <$_AEC_REFERENCE_GetDefaults>:
   0x00000001u,			// ST_PEQ_SCALE2
   0x00000001u			// ST_PEQ_SCALE3
};

unsigned *AEC_REFERENCE_GetDefaults(unsigned capid){
	switch(capid){
84202a90:	20 f0 43 24 	Null = r0 - 67;
84202a94:	05 60       	if EQ jump (m) Lc_AEC_REFERENCE_GetDefaults_3;

84202a96 <Lc_AEC_REFERENCE_GetDefaults_2>:
84202a96:	01 f0 20 f0 	Null = r0 - 16391;
84202a9a:	07 24 
84202a9c:	05 62       	if NE jump (m) Lc_AEC_REFERENCE_GetDefaults_4;

84202a9e <Lc_AEC_REFERENCE_GetDefaults_3>:
		case 0x0043: return defaults_aec_referenceAECREF;
84202a9e:	f8 ff 02 f0 	r0 = Null + -8388604;
84202aa2:	04 40 
84202aa4:	02 6e       	jump (m) Lc_AEC_REFERENCE_GetDefaults_5;

84202aa6 <Lc_AEC_REFERENCE_GetDefaults_4>:
		case 0x4007: return defaults_aec_referenceAECREF;
	}
	return((unsigned *)0);
84202aa6:	02 00       	r0 = Null + Null;

84202aa8 <Lc_AEC_REFERENCE_GetDefaults_5>:
84202aa8:	d8 4c       	rts;

84202aaa <$_cbops_remove_operator_from_graph>:
        pfree(op);
    }
}

void cbops_remove_operator_from_graph(cbops_graph *graph,cbops_op *op)
{
84202aaa:	c8 1c       	pushm <FP(=SP), rLink>;
    cbops_op   *prev_op = op->prev_operator_addr;
84202aac:	19 e8       	rMAC = M[r1 + Null];
    cbops_op   *next_op = op->next_operator_addr;
84202aae:	5c 88       	r2 = M[r1 + 4];

   if(graph->first == op)
84202ab0:	15 e8       	r3 = M[r0 + Null];
84202ab2:	e8 04       	Null = r3 - r1;
84202ab4:	07 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_5;

84202ab6 <Lc_cbops_remove_operator_from_graph_2>:
   {
       /* we are removing the first operator in the graph,
        * next op will become new first
        */
       graph->first = next_op;
       if(next_op == NULL)
84202ab6:	14 ee       	M[r0 + Null] = r2;
84202ab8:	03 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_4;

84202aba <Lc_cbops_remove_operator_from_graph_3>:
       {
           /* this op was the only op in the graph
            * now graph is empty
            */
           graph->last = NULL;
84202aba:	50 8e       	M[r0 + 4] = Null;
84202abc:	0a 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202abe <Lc_cbops_remove_operator_from_graph_4>:
       else
       {
           /* there is still op remaing,
            * just config the new first
            */
           next_op->prev_operator_addr = NULL;
84202abe:	20 ee       	M[r2 + Null] = Null;
84202ac0:	08 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202ac2 <Lc_cbops_remove_operator_from_graph_5>:
       }
   }
   else if(next_op == NULL)
84202ac2:	20 04       	Null = r2 - Null;
84202ac4:	04 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_7;

84202ac6 <Lc_cbops_remove_operator_from_graph_6>:
   {
       /* This isn't the only operator in the graph,
        * but it is the last one in chain
        */
       prev_op->next_operator_addr = NULL;
84202ac6:	48 8e       	M[rMAC + 4] = Null;
       graph->last = prev_op;
84202ac8:	51 8e       	M[r0 + 4] = rMAC;
84202aca:	03 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202acc <Lc_cbops_remove_operator_from_graph_7>:
   else
   {
       /* easy part, the op is neither first
        * nor last
        */
       prev_op->next_operator_addr = next_op;
84202acc:	4c 8e       	M[rMAC + 4] = r2;
       next_op->prev_operator_addr = prev_op;
84202ace:	21 ee       	M[r2 + Null] = rMAC;

84202ad0 <Lc_cbops_remove_operator_from_graph_8>:
   }

   /* op removed from the graph, now
    * destroy the operator
    */
   destroy_operator(op);
84202ad0:	1a 00       	r0 = r1 + Null;
84202ad2:	1c 4e       	call (m) Lc_destroy_operator_1;

84202ad4 <Lc_cbops_remove_operator_from_graph_9>:
}
84202ad4:	c8 48       	popm <FP, rLink>;
84202ad6:	d8 4c       	rts;

84202ad8 <$_cbops_insert_operator_into_graph>:


void cbops_insert_operator_into_graph(cbops_graph *graph,cbops_op *op, cbops_op *after)
{
84202ad8:	c8 1c       	pushm <FP(=SP), rLink>;
    if(after->next_operator_addr == NULL)
84202ada:	61 88       	rMAC = M[r2 + 4];
84202adc:	05 62       	if NE jump (m) Lc_cbops_insert_operator_into_graph_3;

84202ade <Lc_cbops_insert_operator_into_graph_2>:
    {
        /* if this is the last operator in the graph
         * then append it to end of graph
         */
        cbops_append_operator_to_graph(graph, op);
84202ade:	ff fd a1 f0 	call (m) 0x16e96;
84202ae2:	39 ed 
84202ae4:	07 6e       	jump (m) Lc_cbops_insert_operator_into_graph_4;

84202ae6 <Lc_cbops_insert_operator_into_graph_3>:
    }
    else
    {
        /* put the operator between after and after->next */
        op->prev_operator_addr = after;
84202ae6:	1c ee       	M[r1 + Null] = r2;
        op->next_operator_addr = after->next_operator_addr;
84202ae8:	61 88       	rMAC = M[r2 + 4];
84202aea:	59 8e       	M[r1 + 4] = rMAC;
        after->next_operator_addr->prev_operator_addr = op;        
84202aec:	61 88       	rMAC = M[r2 + 4];
84202aee:	0b ee       	M[rMAC + Null] = r1;
        after->next_operator_addr = op;
84202af0:	63 8e       	M[r2 + 4] = r1;

84202af2 <Lc_cbops_insert_operator_into_graph_4>:
    }
}
84202af2:	c8 48       	popm <FP, rLink>;
84202af4:	d8 4c       	rts;

84202af6 <$_cbops_unset_buffer>:

void cbops_unset_buffer(cbops_graph *graph,unsigned index)
{
    cbops_buffer *buffer = &graph->buffers[index];
84202af6:	19 47       	rMAC = r1 * 28 (int);
84202af8:	51 00       	rMAC = r0 + rMAC;
    if(buffer != NULL)
84202afa:	09 31       	rMAC = rMAC + 36;
84202afc:	06 60       	if EQ jump (m) Lc_cbops_unset_buffer_3;

84202afe <Lc_cbops_unset_buffer_2>:
    {
        /* make the buffer index unused */
        buffer->type = 0;
84202afe:	08 ec       	MH[rMAC + Null] = Null;
        buffer->buffer = NULL;
84202b00:	48 8e       	M[rMAC + 4] = Null;
        buffer->transfer_ptr = NULL;
84202b02:	48 8f       	M[rMAC + 20] = Null;
84202b04:	41 20       	rMAC = Null + 1;
84202b06:	d1 8f       	M[r0 + 28] = rMAC;

84202b08 <Lc_cbops_unset_buffer_3>:
84202b08:	d8 4c       	rts;

84202b0a <Lc_destroy_operator_1>:
 */
#include "cbops_c.h"
#include "pmalloc/pl_malloc.h"

static void destroy_operator(cbops_op *op)
{
84202b0a:	c8 1c       	pushm <FP(=SP), rLink>;
    if(op->function_vector == (void*)cbops_rate_adjust_table)
84202b0c:	91 88       	rMAC = M[r0 + 8];
84202b0e:	03 f0 28 42 	r1 = Null + 552;
84202b12:	c8 04       	Null = rMAC - r1;
84202b14:	05 62       	if NE jump (m) Lc_destroy_operator_3;

84202b16 <Lc_destroy_operator_2>:
    {
         destroy_sw_rate_adj_op((cbops_op*)op);
84202b16:	ff fd a0 f0 	call (m) 0x16c7c;
84202b1a:	27 eb 
84202b1c:	0c 6e       	jump (m) Lc_destroy_operator_6;

84202b1e <Lc_destroy_operator_3>:
    }
    else if(op->function_vector == (void*)cbops_iir_resampler_table)
84202b1e:	03 f0 4c 42 	r1 = Null + 588;
84202b22:	c8 04       	Null = rMAC - r1;
84202b24:	05 62       	if NE jump (m) Lc_destroy_operator_5;

84202b26 <Lc_destroy_operator_4>:
    {
         destroy_iir_resamplerv2_op(op);
84202b26:	ff fd a2 f0 	call (m) 0x17064;
84202b2a:	3f e9 
84202b2c:	04 6e       	jump (m) Lc_destroy_operator_6;

84202b2e <Lc_destroy_operator_5>:
    }
    else
    {
        pfree(op);
84202b2e:	ff fd 12 f0 	call (m) 0x4f62;
84202b32:	35 e1 

84202b34 <Lc_destroy_operator_6>:
    }
}
84202b34:	c8 48       	popm <FP, rLink>;
84202b36:	d8 4c       	rts;

84202b38 <$_create_rate_monitor_operator>:
 * create_rate_monitor_operator
 */
#define RATE_MATCH_OP_NUM_INPUTS    1

cbops_op* create_rate_monitor_operator(unsigned clk_per_sec,unsigned idx)
{
84202b38:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84202b3a:	16 00       	r4 = r0 + Null;
84202b3c:	23 de       	M[FP + 16] = r1;
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_rate_monitor_op, RATE_MATCH_OP_NUM_INPUTS, 0));
84202b3e:	c3 20       	r1 = Null + 3;
84202b40:	02 f0 5c 40 	r0 = Null + 92;
84202b44:	ff fd 11 f0 	call (m) 0x4f2a;
84202b48:	27 ef 
84202b4a:	17 00       	r5 = r0 + Null;

    if(op)
84202b4c:	12 60       	if EQ jump (m) Lc_create_rate_monitor_operator_3;

84202b4e <Lc_create_rate_monitor_operator_2>:
    {
        cbops_rate_monitor_op *params;
        
        /* Setup Operator func table */
        op->function_vector    = cbops_rate_monitor_table;
84202b4e:	01 f0 e4 42 	rMAC = Null + 740;
84202b52:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params  = (cbops_rate_monitor_op*)cbops_populate_param_hdr(op, RATE_MATCH_OP_NUM_INPUTS, 0, &idx, NULL);
84202b54:	00 f0 30 cf 	push Null;
84202b58:	05 11       	r3 = FP + 16;
84202b5a:	43 20       	r1 = Null + 1;
84202b5c:	04 00       	r2 = Null + Null;
84202b5e:	ff fd a1 f0 	call (m) 0x16f30;
84202b62:	33 ee 
84202b64:	7f 4c       	SP = SP + -4;

        params->period_per_second = clk_per_sec;
84202b66:	16 ee       	M[r0 + Null] = r4;
        params->average_io_rate = FRACTIONAL(0.5);
84202b68:	ff f3 f1 f7 	rMAC = Null + 1073741823;
84202b6c:	ff 7b 
84202b6e:	11 8f       	M[r0 + 16] = rMAC;

84202b70 <Lc_create_rate_monitor_operator_3>:
    }

    return(op);
84202b70:	3a 00       	r0 = r5 + Null;

84202b72 <Lc_create_rate_monitor_operator_4>:
}
84202b72:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84202b74:	d8 4c       	rts;

84202b76 <$_create_sidetone_filter_op>:
 * It fits into multi-channel model, but it only ever actually uses single in/out channel.
 */
cbops_op* create_sidetone_filter_op(unsigned input_idx, unsigned output_idx,
                                          unsigned max_stages, cbops_sidetone_params *st_params,
                                          unsigned *peq_params)
{
84202b76:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84202b78:	26 00       	r4 = r2 + Null;
84202b7a:	28 09       	r6 = r3 + Null;
84202b7c:	33 de       	M[FP + 24] = r1;
84202b7e:	2a de       	M[FP + 20] = r0;
    cbops_op *op;
    /* extra 2 words compared to ROM, needed as we use standard PEQ for filtering */
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_sidetone_filter_op, 1, 1) +
                              (2*(max_stages+1) + 2)*sizeof(unsigned) );
84202b80:	c3 20       	r1 = Null + 3;
84202b82:	b2 20       	r0 = r4 + 2;
84202b84:	92 54       	r0 = r0 LSHIFT 3;
84202b86:	02 f0 5c 44 	r0 = r0 + 92;
84202b8a:	ff fd 11 f0 	call (m) 0x4f2a;
84202b8e:	21 ed 
84202b90:	17 00       	r5 = r0 + Null;
    if(op)
84202b92:	16 60       	if EQ jump (m) Lc_create_sidetone_filter_op_3;

84202b94 <Lc_create_sidetone_filter_op_2>:
    {
        cbops_sidetone_filter_op  *params;

        op->function_vector    = cbops_sidetone_filter_table;
84202b94:	01 f0 cc 42 	rMAC = Null + 716;
84202b98:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_sidetone_filter_op*)cbops_populate_param_hdr(op, 1, 1, &input_idx, &output_idx);
84202b9a:	81 11       	rMAC = FP + 24;
84202b9c:	09 1c       	pushm <rMAC>;
84202b9e:	45 11       	r3 = FP + 20;
84202ba0:	44 20       	r2 = Null + 1;
84202ba2:	23 00       	r1 = r2 + Null;
84202ba4:	ff fd a1 f0 	call (m) 0x16f30;
84202ba8:	2d ec 
84202baa:	7f 4c       	SP = SP + -4;

        /* Set up the parameters - there are no channel-specific params as such, as it only works on a
         * single channel.
         */

        params->inv_dac_gain = FRACTIONAL(1.0); // TODO - handle gain adjustment for post volume
84202bac:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84202bb0:	ff 7b 
84202bb2:	d1 8e       	M[r0 + 12] = rMAC;

        params->params = st_params;
84202bb4:	28 f0 00 ee 	M[r0 + Null] = r6;
        params->peq.max_stages = max_stages;
84202bb8:	16 9e       	M[r0 + 32] = r4;
        params->peq.params = peq_params;
84202bba:	f9 d9       	rMAC = M[FP + -4];
84202bbc:	51 9e       	M[r0 + 36] = rMAC;

84202bbe <Lc_create_sidetone_filter_op_3>:
    }

    return(op);
84202bbe:	3a 00       	r0 = r5 + Null;

84202bc0 <Lc_create_sidetone_filter_op_4>:
}
84202bc0:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84202bc2:	d8 4c       	rts;

84202bc4 <$_opmgr_op_is_running>:
84202bc4:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
84202bc6:	10 b0       	Null = MBS[r0 + 24];
84202bc8:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84202bcc:	0a 00       	r0 = rMAC + Null;

84202bce <Lc_opmgr_op_is_running_2>:
84202bce:	d8 4c       	rts;

84202bd0 <$_get_override_ep_rate_adjust_op>:
84202bd0:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
#define EP_CURRENT_HW_WARP ((uint32)0x1001A)

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
/* get_override_ep_rate_adjust_op */
bool get_override_ep_rate_adjust_op(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
84202bd2:	1e 00       	r4 = r1 + Null;
/** Set the unreliable flag
 * \param rm Rate measurement context
 */
static void inline rate_measure_set_unreliable(RATE_MEASURE* rm)
{
    rm->unreliable = TRUE;
84202bd4:	c4 10       	r2 = FP + 12;
84202bd6:	58 dc       	MH[FP + 22] = Null;
84202bd8:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
84202bda:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_RATE_ADJUST_OP, &result);
84202bdc:	83 f0 18 40 	r1 = Null + 65560;
84202be0:	ff fd 1a f0 	call (m) 0x6128;
84202be4:	29 ea 
    *value = result.u.value;
84202be6:	19 d8       	rMAC = M[FP + 12];
84202be8:	31 ee       	M[r4 + Null] = rMAC;

84202bea <Lc_get_override_ep_rate_adjust_op_2>:
    return success;
84202bea:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
84202bec:	d8 4c       	rts;

84202bee <$_set_override_ep_set_hw_warp_apply_mode>:
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
/* set_override_ep_set_hw_warp_apply_mode */
bool set_override_ep_set_hw_warp_apply_mode(OVERRIDE_EP_HANDLE ep_hdl, uint32 value)
{
84202bee:	c8 1c       	pushm <FP(=SP), rLink>;
84202bf0:	1c 00       	r2 = r1 + Null;
    return stream_configure_connected_to_endpoint((ENDPOINT*)ep_hdl, EP_HW_WARP_APPLY_MODE, value);
84202bf2:	83 f0 19 40 	r1 = Null + 65561;
84202bf6:	ff fd 1a f0 	call (m) 0x6146;
84202bfa:	31 ea 

84202bfc <Lc_set_override_ep_set_hw_warp_apply_mode_2>:
}
84202bfc:	c8 48       	popm <FP, rLink>;
84202bfe:	d8 4c       	rts;

84202c00 <$_get_override_ep_current_hw_warp>:


/* get_override_ep_current_hw_warp */
bool get_override_ep_current_hw_warp(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
84202c00:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
84202c02:	1e 00       	r4 = r1 + Null;
84202c04:	c4 10       	r2 = FP + 12;
84202c06:	58 dc       	MH[FP + 22] = Null;
84202c08:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
84202c0a:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_CURRENT_HW_WARP, &result);
84202c0c:	83 f0 1a 40 	r1 = Null + 65562;
84202c10:	ff fd 1a f0 	call (m) 0x6128;
84202c14:	39 e8 
    *value = result.u.value;
84202c16:	19 d8       	rMAC = M[FP + 12];
84202c18:	31 ee       	M[r4 + Null] = rMAC;

84202c1a <Lc_get_override_ep_current_hw_warp_2>:
    return success;
84202c1a:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
84202c1c:	d8 4c       	rts;

84202c1e <$_stream_delegate_rate_adjust_set_target_rate>:
84202c1e:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param target_rate_addr target rate
 */
void stream_delegate_rate_adjust_set_target_rate(unsigned opid, unsigned target_rate)
{
84202c20:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_TARGET_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_TARGET_RATE;
84202c22:	12 f0 18 40 	r0 = Null + 8216;
84202c26:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (target_rate >> 16);
84202c28:	9a 52       	r0 = r1 LSHIFT -16;
84202c2a:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (target_rate & 0xFFFF);
84202c2c:	9a c6       	r0 = r1 AND 0xffff;
84202c2e:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84202c30:	42 f0 2c f0 	push Null + 69217439;
84202c34:	5f e9 
84202c36:	85 10       	r3 = FP + 8;
84202c38:	c4 20       	r2 = Null + 3;
84202c3a:	c2 2b       	r0 = Null + 31;
84202c3c:	0b 00       	r1 = rMAC + Null;
84202c3e:	ff fd 05 f0 	call (m) 0x37ca;
84202c42:	2d ec 
84202c44:	7f 4c       	SP = SP + -4;

84202c46 <Lc_stream_delegate_rate_adjust_set_target_rate_2>:
}
84202c46:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84202c48:	d8 4c       	rts;

84202c4a <$_stream_delegate_rate_adjust_set_passthrough_mode>:
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param enable if TRUE enables pass-through mode else disables it
 */
void stream_delegate_rate_adjust_set_passthrough_mode(unsigned opid, bool enable)
{
84202c4a:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
84202c4c:	11 00       	rMAC = r0 + Null;
    unsigned params[2];

    /* send PASSTHROUGH_MODE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_PASSTHROUGH_MODE;
84202c4e:	12 f0 19 40 	r0 = Null + 8217;
84202c52:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) enable;
84202c54:	9a c6       	r0 = r1 AND 0xffff;
84202c56:	1a de       	M[FP + 12] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84202c58:	42 f0 2c f0 	push Null + 69217439;
84202c5c:	5f e9 
84202c5e:	85 10       	r3 = FP + 8;
84202c60:	84 20       	r2 = Null + 2;
84202c62:	c2 2b       	r0 = Null + 31;
84202c64:	0b 00       	r1 = rMAC + Null;
84202c66:	ff fd 05 f0 	call (m) 0x37ca;
84202c6a:	25 eb 
84202c6c:	7f 4c       	SP = SP + -4;

84202c6e <Lc_stream_delegate_rate_adjust_set_passthrough_mode_2>:
}
84202c6e:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84202c70:	d8 4c       	rts;

84202c72 <$_stream_delegate_rate_adjust_set_current_rate>:
 *
 * Note: This message when delivered will directly set the current sra rate,
 *       suitable for TTP-type rate adjustment.
 */
void stream_delegate_rate_adjust_set_current_rate(unsigned opid, unsigned rate)
{
84202c72:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
84202c74:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_CURRENT_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_CURRENT_RATE;
84202c76:	12 f0 17 40 	r0 = Null + 8215;
84202c7a:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (rate >> 16);
84202c7c:	9a 52       	r0 = r1 LSHIFT -16;
84202c7e:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (rate & 0xFFFF);
84202c80:	9a c6       	r0 = r1 AND 0xffff;
84202c82:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84202c84:	42 f0 2c f0 	push Null + 69217439;
84202c88:	5f e9 
84202c8a:	85 10       	r3 = FP + 8;
84202c8c:	c4 20       	r2 = Null + 3;
84202c8e:	c2 2b       	r0 = Null + 31;
84202c90:	0b 00       	r1 = rMAC + Null;
84202c92:	ff fd 05 f0 	call (m) 0x37ca;
84202c96:	39 e9 
84202c98:	7f 4c       	SP = SP + -4;

84202c9a <Lc_stream_delegate_rate_adjust_set_current_rate_2>:
}
84202c9a:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84202c9c:	d8 4c       	rts;

84202c9e <Lc_stream_delegate_rate_adjust_message_callback_1>:
static bool stream_delegate_rate_adjust_message_callback(unsigned con_id,
                                                         unsigned status,
                                                         unsigned op_id,
                                                         unsigned num_resp_params,
                                                         unsigned *resp_params)
{
84202c9e:	c8 1c       	pushm <FP(=SP), rLink>;
84202ca0:	11 00       	rMAC = r0 + Null;
    /* No action, just log the response if message if it failed */
    if(status != STATUS_OK)
84202ca2:	18 04       	Null = r1 - Null;
84202ca4:	11 60       	if EQ jump (m) Lc_stream_delegate_rate_adjust_message_callback_6;

84202ca6 <Lc_stream_delegate_rate_adjust_message_callback_2>:
    {
        L2_DBG_MSG4("Message to standalone rate adjust op failed: conid=%d, opid=%d, status=%d, messageID=%d",
                    con_id,
                    op_id,
                    status,
                    num_resp_params == 0?-1:resp_params[0]);
84202ca6:	28 04       	Null = r3 - Null;
84202ca8:	03 62       	if NE jump (m) Lc_stream_delegate_rate_adjust_message_callback_4;

84202caa <Lc_stream_delegate_rate_adjust_message_callback_3>:
84202caa:	42 24       	r0 = Null - 1;
84202cac:	03 6e       	jump (m) Lc_stream_delegate_rate_adjust_message_callback_5;

84202cae <Lc_stream_delegate_rate_adjust_message_callback_4>:
84202cae:	fa d9       	r0 = M[FP + -4];
84202cb0:	12 e8       	r0 = M[r0 + Null];

84202cb2 <Lc_stream_delegate_rate_adjust_message_callback_5>:
84202cb2:	11 1c       	pushm <r0>;
84202cb4:	55 f1 02 f0 	r0 = Null + 357565199;
84202cb8:	0f 43 
84202cba:	1d 00       	r3 = r1 + Null;
84202cbc:	0b 00       	r1 = rMAC + Null;
84202cbe:	ef fd ee ff 	call (m) 0x9f6;
84202cc2:	39 e9 
84202cc4:	7f 4c       	SP = SP + -4;

84202cc6 <Lc_stream_delegate_rate_adjust_message_callback_6>:
    }

    return TRUE;
84202cc6:	42 20       	r0 = Null + 1;

84202cc8 <Lc_stream_delegate_rate_adjust_message_callback_7>:
}
84202cc8:	c8 48       	popm <FP, rLink>;
84202cca:	d8 4c       	rts;

84202ccc <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aec_reference_cap_data;
84202ccc:	07 f0 02 f0 	r0 = Null + 7340032;
84202cd0:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84202cd2:	20 f0 b0 41 	Null = Null + 16816;

84202cd6 <$cbops.aec_ref_spkr_op.amount_to_use>:
          
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.amount_to_use.PATCH_ID_0, r7)
#endif
          
   push rlink;
84202cd6:	00 f0 3d cf 	push rLink;
   
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84202cda:	a9 f0 00 88 	r7 = M[r8 + 0];
   // Get amount of input
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];    
84202cde:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84202ce2:	ff fd c8 f2 	call 0x5bd9c;
84202ce6:	3a e5 
   r5 = M[r0];
84202ce8:	17 e8       	r5 = M[r0 + Null];
   // Save data at input and make input large, will re-adjust for insertion
   M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.AMOUNT_DATA_FIELD] = r5;
84202cea:	97 f0 03 8e 	M[r7 + 12] = r5;
   r5 = 0x7FFF;
84202cee:	37 f0 ff 7b 	r5 = Null + 32767;
   M[r0] = r5;
84202cf2:	87 ee       	M[Null + r0] = r5;

#ifndef CHIP_BASE_A7DA_KAS
   // Get first output index
   r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84202cf4:	ab f0 01 88 	r9 = M[r8 + 4];
   Words2Addr(r9);
84202cf8:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
   r9 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
84202cfc:	63 75       	r9 = r9 + 12;
   r0 = M[r8 + r9];
84202cfe:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_cbuffer;
84202d02:	ff fd c8 f2 	call 0x5bd8c;
84202d06:	2a e4 
   NULL = r0;
84202d08:	10 00       	Null = r0 + Null;
   if Z jump aec_ref_spkr_op.amount_to_use_done;
84202d0a:	16 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done;

   // First Port (r0);
   r5 = NULL;
84202d0c:	07 00       	r5 = Null + Null;
   r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
84202d0e:	98 f0 01 88 	r6 = M[r7 + 4];
   r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
84202d12:	93 f0 06 88 	r1 = M[r7 + 24];
   r6 = r6 + r1;  
84202d16:	18 0d       	r6 = r1 + r6;

   call calc_dac_amount_of_data;
84202d18:	67 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;
   // r2 is data in port (negative if wrap), r10 is max advance, r0 is adjustment
   // Limit amount of data after transfer to two times maximum advance
   NULL = r2 + r0;
84202d1a:	a0 00       	Null = r2 + r0;
   if POS r1 = r6 - r2;
84202d1c:	45 f8 03 c2 	if POS r1 = r6 - r2;
   if NEG r1 = Null;
84202d20:	04 f0 03 c0 	if NEG r1 = Null + Null;

   // Setup the limited transfer at output
   r0 = M[r8 + r9];
84202d24:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_amount_ptr;
84202d28:	ff fd c8 f2 	call 0x5bd9c;
84202d2c:	34 e3 
   M[r0]=r1;
84202d2e:	83 ee       	M[Null + r0] = r1;
   if Z call $cbops.force_processing;
84202d30:	f0 fd c8 f2 	if EQ call 0x5bdac;
84202d34:	3c e3 

84202d36 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done>:
#endif

aec_ref_spkr_op.amount_to_use_done:
   pop rlink;
84202d36:	00 f4 3d cf 	pop rLink;
   rts;
84202d3a:	d8 4c       	rts;

84202d3c <$_get_aec_ref_cbops_inserts_total>:
   pop rlink;
   rts;
#endif /* #ifndef CBOPS_AEC_REF_SPKR_OP_PRE_MAIN_USE_ROM */
// unsigned get_aec_ref_cbops_inserts_total(cbops_op *op);
$_get_aec_ref_cbops_inserts_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84202d3c:	d2 88       	r0 = M[r0 + 12];
    r1 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
84202d3e:	13 89       	r1 = M[r0 + 16];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
84202d40:	52 89       	r0 = M[r0 + 20];
    r0 = r0 + r1;
84202d42:	9a 00       	r0 = r1 + r0;
    rts;
84202d44:	d8 4c       	rts;

84202d46 <$_get_aec_ref_cbops_insert_op_insert_total>:

// unsigned get_aec_ref_cbops_insert_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_insert_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84202d46:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
84202d48:	52 89       	r0 = M[r0 + 20];
    rts;
84202d4a:	d8 4c       	rts;

84202d4c <$_get_aec_ref_cbops_wrap_op_insert_total>:

// unsigned get_aec_ref_cbops_wrap_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_wrap_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84202d4c:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
84202d4e:	12 89       	r0 = M[r0 + 16];
    rts;
84202d50:	d8 4c       	rts;

84202d52 <$cbops.aec_ref_spkr_op.post_main>:
#ifndef CHIP_BASE_A7DA_KAS
// Called after main processing of graph before buffer update
$cbops.aec_ref_spkr_op.post_main:

   // Check for Buffer Wrapping
    push rLink;
84202d52:	00 f0 3d cf 	push rLink;
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.post_main.PATCH_ID_0, r9)
#endif

    // Get first output index
    r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84202d56:	ab f0 01 88 	r9 = M[r8 + 4];
    Words2Addr(r9);
84202d5a:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
    r9 = r9 + r8;
84202d5e:	53 0d       	r9 = r8 + r9;
    I4 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
84202d60:	b4 f8 0c 20 	I4 = r9 + 12;

    // Get first buffer entry 
    r0 = M[I4,0];
84202d64:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    r3 = r0 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR (int);
84202d68:	15 47       	r3 = r0 * 28 (int);
    r3 = r3 + r4;
84202d6a:	75 01       	r3 = r4 + r3;

    // Get Cbuffer Ptr
    r0 = M[r3 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84202d6c:	6a 88       	r0 = M[r3 + 4];
    if Z jump $pop_rLink_and_rts;
84202d6e:	7c ff 40 f5 	if EQ jump (m) 0x2cf82;
84202d72:	95 e4 

#if !defined(CHIP_BASE_BC7)   
    // Get transfer amount (r5)
    r1 = M[r3 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
84202d74:	6b 89       	r1 = M[r3 + 20];
    r5 = M[r1];
84202d76:	1f e8       	r5 = M[r1 + Null];
#else
    r5 = NULL;
#endif

    // Compute amount of data in source
    r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84202d78:	a9 f0 00 88 	r7 = M[r8 + 0];
    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
84202d7c:	98 f0 06 88 	r6 = M[r7 + 24];
    call calc_dac_amount_of_data;
84202d80:	33 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;

    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
84202d82:	98 f0 01 88 	r6 = M[r7 + 4];

    // r2 is number of samples in port, negative if overflow
    r10 = r6 - r2;
84202d86:	4f f8 0c c2 	r10 = r6 - r2;
    if LE jump $pop_rLink_and_rts;
84202d8a:	7c ff 4d f5 	if LE jump (m) 0x2cf82;
84202d8e:	f9 e3 

    // Increment Wrap count
    r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
84202d90:	93 f0 04 88 	r1 = M[r7 + 16];
    r1 = r1 + r10;    
84202d94:	63 0c       	r1 = r10 + r1;
    M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD]=r1;
84202d96:	93 f0 04 8e 	M[r7 + 16] = r1;
    
    // setup amounts for insertions
    r5 = r5 + r10;
84202d9a:	67 0c       	r5 = r10 + r5;
    r6 = r10;
84202d9c:	60 09       	r6 = r10 + Null;

    // Number of Ports
    r9 = M[r8 + $cbops.param_hdr.NR_OUTPUT_CHANNELS_FIELD];
84202d9e:	ab f0 02 88 	r9 = M[r8 + 8];

84202da2 <$M.cbops.aec_ref_spkr_op.process_channel>:

    // Perform insertion
 process_channel:
    r0 = M[I4,0];
84202da2:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    call $cbops.get_buffer_address_and_length;
84202da6:	ff fd c7 f2 	call 0x5bd20;
84202daa:	3a eb 
    I0 = r0;
84202dac:	10 0a       	I0 = r0 + Null;
    if Z jump process_channel_next;
84202dae:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.process_channel_next;
      // Insert r6 zeros
      r10 = r6;
84202db0:	44 09       	r10 = r6 + Null;
      L0 = r1;
84202db2:	1c 0b       	L0 = r1 + Null;
      push r2;
84202db4:	00 f0 34 cf 	push r2;
      pop B0;
84202db8:	00 f6 3a cf 	pop B0;
      r1  = Null;
84202dbc:	03 00       	r1 = Null + Null;
      do lp_insert_loop;
84202dbe:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.lp_insert_loop;
         M[I0, MK1] = r1;
84202dc0:	b1 f0 30 c0 	Null = Null + Null, M[I0,4] = r1;

84202dc4 <$M.cbops.aec_ref_spkr_op.lp_insert_loop>:
      lp_insert_loop:
      // Update amount (r5)
      r0 = M[I4,MK1];
84202dc4:	21 f0 30 d0 	Null = Null + Null, r0 = M[I4,4];
      call $cbops.get_amount_ptr;
84202dc8:	ff fd c7 f2 	call 0x5bd9c;
84202dcc:	34 ee 
      M[r0]=r5;
84202dce:	87 ee       	M[Null + r0] = r5;

84202dd0 <$M.cbops.aec_ref_spkr_op.process_channel_next>:
    process_channel_next:
    r9 = r9 - 1;
84202dd0:	bb f0 01 24 	r9 = r9 - 1;
    if GT jump process_channel;
84202dd4:	e7 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.process_channel;

    // Clear cicular buffer
    L0=NULL;
84202dd6:	04 0b       	L0 = Null + Null;
    push NULL;
84202dd8:	00 f0 30 cf 	push Null;
    pop B0;
84202ddc:	00 f6 3a cf 	pop B0;

    pop rlink;
84202de0:	00 f4 3d cf 	pop rLink;
    rts;
84202de4:	d8 4c       	rts;

84202de6 <$M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data>:
// TRASHED REGISTERS:
//    r0,r1,r2
//
// *****************************************************************************
calc_dac_amount_of_data:
    push rLink;
84202de6:	00 f0 3d cf 	push rLink;
    call $cbuffer.calc_amount_space_in_words;
84202dea:	ff fd 49 f1 	call (m) 0x2c1b6;
84202dee:	2d ee 

#ifdef CHIP_BASE_HYDRA
    // Hydra: r2 is local buffer size in addr
    Addr2Words(r2);
84202df0:	64 58       	r2 = r2 ASHIFT -2;
    // Adjust space for amount written, buffer not port
    r0 = r0 - r5;
84202df2:	d2 05       	r0 = r0 - r5;
#endif

    // r0 is space in port minus one
    // r2 = amount data in port
    // r6 min required space
    r2  = r2 - r0;    
84202df4:	a4 04       	r2 = r2 - r0;
    // check minimum space, if less than that
    // wrap has happened
    Null = r0 - r6;
84202df6:	8f f2 00 c2 	Null = r0 - r6;
    if NEG r2 = NULL - r0;
84202dfa:	24 f0 04 c2 	if NEG r2 = Null - r0;

    r0 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.BUFFER_ADJ_FIELD];
84202dfe:	92 f0 02 88 	r0 = M[r7 + 8];
    r2 = r2 - r0;
84202e02:	a4 04       	r2 = r2 - r0;
    // r2 is number of samples in port, negative if overflow
    pop rLink;
84202e04:	00 f4 3d cf 	pop rLink;
    rts;
84202e08:	d8 4c       	rts;

84202e0a <$_aecref_calc_sync_mic_rate>:
$_aecref_calc_sync_mic_rate:
    // r0 = spkr_ra
    // r1 = spkr_rt
    // r2 = mic_rt
    // return spkr_rt/(mic_rt*(1+spkr_ra))
    rMAC = -r0;
84202e0a:	81 04       	rMAC = Null - r0;
    r3 = r0 * r0 (frac);
84202e0c:	2f f2 45 c9 	r3 = r0 * r0 (frac);
    rMAC = rMAC + r0 * r0;
84202e10:	2f f2 c1 ca 	rMAC = rMAC + r0 * r0 (SS);
    rMAC = rMAC - r0*r3;   // rMAC = -spkr_ra + spkr_ra^2 - spkr_ra^3
84202e14:	5f f2 c1 cb 	rMAC = rMAC - r0 * r3 (SS);
                           // good enough estimation of 1.0/(1.0+spkr_ra) -1.0
    r0 = rMAC;
84202e18:	0a 00       	r0 = rMAC + Null;
    rMAC = r1 - r2;
84202e1a:	19 05       	rMAC = r1 - r2;
    if Z rts;              // all done if mic_rt==spkr_rt
84202e1c:	00 fd c0 cd 	if EQ rts;
    // calculate (spkr_rt/mic_rt)-1.0
#if DAWTH>24
   // division & rounding
   rMAC0 = r2;
84202e20:	05 f0 00 f4 	rMAC0 = r2 LSHIFT 0;
84202e24:	de c8 
   r2 = r2 + r2;
84202e26:	24 01       	r2 = r2 + r2;
   Div = rMAC / r2;
84202e28:	a1 4c       	Div = rMAC / r2;
   r1 = DivResult;       // r1 = (spkr_rt/mic_rt)-1.0
84202e2a:	c3 4c       	r1 = DivResult;
   r1 = r1 - 0.5;    // r1 = 0.5(spkr_rt/mic_rt-1.0)
   r1 = r1 + r1;     // r1 = (spkr_rt/mic_rt)-1.0
#endif
    // r1 = (spkr_rt/mic_rt)-1.0
    // r0 = 1.0/(1.0+spkr_ra)-1.0
    r2 = r1 * r0 (frac);
84202e2c:	2f f3 44 c9 	r2 = r1 * r0 (frac);
    r0 = r1 + r0;
84202e30:	9a 00       	r0 = r1 + r0;
    r0 = r0 + r2;
84202e32:	a2 00       	r0 = r2 + r0;
    // r0 = spkr_rt/mic_rt/(1+spkr_ra) - 1.0
    rts;
84202e34:	d8 4c       	rts;

84202e36 <$cbops.aec_ref_sidetone_op.amount_to_use>:
// Called before amount_to_use of graph
$cbops.aec_ref_sidetone_op.amount_to_use:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.amount_to_use.PATCH_ID_0, r7)
#endif
   push rlink;
84202e36:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84202e3a:	a9 f0 00 88 	r7 = M[r8 + 0];

   // update sidetone mic buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_BUF_FIELD];
84202e3e:	92 f0 01 88 	r0 = M[r7 + 4];
   call $cbuffer.get_write_address_and_size_and_start_address;
84202e42:	ff fd 4c f1 	call (m) 0x2c6d6;
84202e46:	35 e4 
   r6 = r0;
84202e48:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
84202e4a:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_cbuffer;
84202e4e:	ff fd c7 f2 	call 0x5bd8c;
84202e52:	3e e9 
   r1 = r6;
84202e54:	43 08       	r1 = r6 + Null;
   r6 = r0;
84202e56:	10 09       	r6 = r0 + Null;
   call $cbuffer.set_write_address;
84202e58:	ff fd 4c f1 	call (m) 0x2c73e;
84202e5c:	27 e7 

   // update amount to read from mic
   r0 = r6;
84202e5e:	42 08       	r0 = r6 + Null;
   call $cbuffer.calc_amount_data_in_words;
84202e60:	ff fd 49 f1 	call (m) 0x2c208;
84202e64:	29 ed 
   r6 = r0;
84202e66:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
84202e68:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_amount_ptr;
84202e6c:	ff fd c7 f2 	call 0x5bd9c;
84202e70:	30 e9 
   M[r0] = r6;
84202e72:	08 f0 02 ee 	M[Null + r0] = r6;

   /* See how many samples speakr has moved, we will mix the same
    * number of samples from sidetone buffer.
    */
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84202e76:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
84202e7a:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
84202e7c:	ff fd 4c f1 	call (m) 0x2c6a4;
84202e80:	29 e1 
   r3 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD];
84202e82:	95 f0 0e 88 	r3 = M[r7 + 56];
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84202e86:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r3 = r0 - r3;
84202e8a:	55 05       	r3 = r0 - r3;
   if NEG r3 = r3 + r1;
84202e8c:	34 f5 05 c0 	if NEG r3 = r3 + r1;
   BUFFER_ADDRS_TO_WORDS_ASM(r3);
84202e90:	6d 58       	r3 = r3 ASHIFT -2;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD] = r3;
84202e92:	95 f0 0f 8e 	M[r7 + 60] = r3;
   pop rlink;
84202e96:	00 f4 3d cf 	pop rLink;
   rts;
84202e9a:	d8 4c       	rts;

84202e9c <$cbops.aec_ref_sidetone_op.pre_main>:
// TRASHED REGISTERS:
//    Assume anything except r4 and r8
//
// *****************************************************************************
$cbops.aec_ref_sidetone_op.pre_main:
   push rLink;
84202e9c:	00 f0 3d cf 	push rLink;
   /* Force processing */
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.pre_main.PATCH_ID_0, r6)
#endif
   call $cbops.force_processing;
84202ea0:	ff fd c7 f2 	call 0x5bdac;
84202ea4:	2c e8 
   pop rlink;
84202ea6:	00 f4 3d cf 	pop rLink;
   rts;
84202eaa:	d8 4c       	rts;

84202eac <$cbops.aec_ref_sidetone_op.post_main>:
// *****************************************************************************
$cbops.aec_ref_sidetone_op.post_main:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.post_main.PATCH_ID_0, r7)
#endif
   push rlink;
84202eac:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84202eb0:	a9 f0 00 88 	r7 = M[r8 + 0];

   // get speaker buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84202eb4:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
84202eb8:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
84202eba:	ff fd 4b f1 	call (m) 0x2c6a4;
84202ebe:	2b ef 
   I0 = r0;
84202ec0:	10 0a       	I0 = r0 + Null;
   L0 = r1;
84202ec2:	1c 0b       	L0 = r1 + Null;
   push r2;
84202ec4:	00 f0 34 cf 	push r2;
   pop B0;
84202ec8:	00 f6 3a cf 	pop B0;
   // save read address for later use
   I6 = r0;
84202ecc:	16 0a       	I6 = r0 + Null;
   // I6 = read address of first speaker buffer

   // get threshold
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
84202ece:	92 f0 06 88 	r0 = M[r7 + 24];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84202ed2:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84202ed4:	10 0b       	M0 = r0 + Null;

   // r6 = spkr_rd + threshold_low
   r0 = M[I0, M0];
84202ed6:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r6 = I0;
84202eda:	80 09       	r6 = I0 + Null;

   // r5 = spkr_rd + threshold_high
   I0 = I6;
84202edc:	b0 0a       	I0 = I6 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
84202ede:	92 f0 07 88 	r0 = M[r7 + 28];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84202ee2:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84202ee4:	10 0b       	M0 = r0 + Null;
   r0 = M[I0, M0];
84202ee6:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r5 = I0;
84202eea:	87 08       	r5 = I0 + Null;

   r0 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84202eec:	92 f0 0c 20 	r0 = r7 + 12;
   r0 = M[r0];
84202ef0:	12 e8       	r0 = M[r0 + Null];
   I0 = r0;
84202ef2:	10 0a       	I0 = r0 + Null;
   I7 = r0;
84202ef4:	17 0a       	I7 = r0 + Null;
   //            r0
   // --|----|---^---|-------------------------------------|--
   //   RD   Low     High                                 WR
   //
   // ====================================================================
   Null = r5 - r6;
84202ef6:	8f f7 00 c2 	Null = r5 - r6;
   if NEG jump neg_part;
84202efa:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.neg_part;

84202efe <$M.cbops.aec_ref_sidetone_op.pos_part>:
   pos_part:
      // expect: r6 <= r0 < r5
      Null = r0 - r5;
84202efe:	d0 05       	Null = r0 - r5;
      if POS jump reset_mixing_offset;
84202f00:	05 f0 9d e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      Null = r0 - r6;
84202f04:	8f f2 00 c2 	Null = r0 - r6;
      if NEG jump reset_mixing_offset;
84202f08:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      jump mixing_point_check_done;
84202f0c:	1a 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

84202f0e <$M.cbops.aec_ref_sidetone_op.neg_part>:

   neg_part:
      // expect: r0 < r5 or r0 >= r6
      Null = r0 - r6;
84202f0e:	8f f2 00 c2 	Null = r0 - r6;
      if POS jump mixing_point_check_done;
84202f12:	05 f0 af e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;
      Null = r0 - r5;
84202f16:	d0 05       	Null = r0 - r5;
      if NEG jump mixing_point_check_done;
84202f18:	04 f0 a9 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

84202f1c <$M.cbops.aec_ref_sidetone_op.reset_mixing_offset>:

reset_mixing_offset:
   /* reset mixing offset */
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
84202f1c:	93 f0 08 88 	r1 = M[r7 + 32];
   BUFFER_WORDS_TO_ADDRS_ASM(r1);
84202f20:	5b 5c       	r1 = r1 ASHIFT 2;
   M0 = r1;
84202f22:	18 0b       	M0 = r1 + Null;
   I0 = I6;
84202f24:	b0 0a       	I0 = I6 + Null;
   r1 = M[I0, M0];
84202f26:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

   // update debug counter showing mixing offset has been re-aligned
   r2 = I0 - r0;
84202f2a:	2f f0 84 c6 	r2 = I0 - r0;
   if NEG r2 = r2 + L0;
84202f2e:	c4 f4 44 c4 	if NEG r2 = r2 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r2);
84202f32:	64 58       	r2 = r2 ASHIFT -2;
   r1 = M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD];
84202f34:	93 f0 0d 88 	r1 = M[r7 + 52];
   r1 = r1 + r2;
84202f38:	e3 00       	r1 = r2 + r1;
   M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD] = r1;
84202f3a:	93 f0 0d 8e 	M[r7 + 52] = r1;

   // r0 = mixing offset updated
   r0 = I0;
84202f3e:	82 08       	r0 = I0 + Null;

84202f40 <$M.cbops.aec_ref_sidetone_op.mixing_point_check_done>:
   // L0 = speaker buffer length
   // I6 = speaker buffer read address

   // work out the distance between HW read address and
   // mixing address in samples
   push B0;
84202f40:	00 f2 3a cf 	push B0;
   pop r1;
84202f44:	00 f4 33 cf 	pop r1;
   r1 = r0 - I6;
84202f48:	6f f2 43 c6 	r1 = r0 - I6;
   if NEG r1 = r1 + L0;
84202f4c:	c4 f3 43 c4 	if NEG r1 = r1 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r1);
84202f50:	5b 58       	r1 = r1 ASHIFT -2;

   // get amount to mix
   r5 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD];
84202f52:	97 f0 0f 88 	r5 = M[r7 + 60];
   // r1 = distance before mixing
   // r3 = distance after mixing
   r3 = r5 + r1;
84202f56:	fd 00       	r3 = r5 + r1;

   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_THRESHOLD_FIELD];
84202f58:	92 f0 09 88 	r0 = M[r7 + 36];
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
84202f5c:	93 f0 06 88 	r1 = M[r7 + 24];
   r2 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
84202f60:	94 f0 07 88 	r2 = M[r7 + 28];
   r9 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
84202f64:	9b f0 08 88 	r9 = M[r7 + 32];
   r1 = r0 + r1;   // low threshold after mixing
84202f68:	d3 00       	r1 = r0 + r1;
   r2 = r0 + r2;   // high threshold after mixing
84202f6a:	14 01       	r2 = r0 + r2;
   r9 = r0 + r9;   // good threshold after mixing
84202f6c:	13 0d       	r9 = r0 + r9;

   // r6 = samples to insert
   r6 = 0;
84202f6e:	00 09       	r6 = Null + Null;

   // expect r1 < r3 < r2
   r0 = r1 - r3;
84202f70:	5a 05       	r0 = r1 - r3;
   if GT jump insert_sidetone;
84202f72:	0c 6a       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.insert_sidetone;
   r0 = r3 - r2;
84202f74:	2a 05       	r0 = r3 - r2;
   if LE jump mix_sidetone;
84202f76:	12 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

84202f78 <$M.cbops.aec_ref_sidetone_op.discard_sidetone>:

discard_sidetone:
   // discard here means ignore, we are doing in-place mixing
   // actual discard if needed will be done by sink_overflow_disgard operator
   r1 = r5 - r9;
84202f78:	bf f7 03 c2 	r1 = r5 - r9;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD];
84202f7c:	92 f0 0a 88 	r0 = M[r7 + 40];
   r0 = r0 + r1;
84202f80:	9a 00       	r0 = r1 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD] = r0;
84202f82:	92 f0 0a 8e 	M[r7 + 40] = r0;
   r5 = r9;
84202f86:	5f 08       	r5 = r9 + Null;
   jump mix_sidetone;
84202f88:	09 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

84202f8a <$M.cbops.aec_ref_sidetone_op.insert_sidetone>:

insert_sidetone:
   // we don't have enough samples to mix, we needs to mix
   // the difference, it will be mixing using last mixed sample
   r6 = r9 - r5;
84202f8a:	7f fb 08 c2 	r6 = r9 - r5;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD];
84202f8e:	92 f0 0b 88 	r0 = M[r7 + 44];
   r0 = r0 + r6;
84202f92:	42 0c       	r0 = r6 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD] = r0;
84202f94:	92 f0 0b 8e 	M[r7 + 44] = r0;
   r5 = r9;
84202f98:	5f 08       	r5 = r9 + Null;

84202f9a <$M.cbops.aec_ref_sidetone_op.mix_sidetone>:
mix_sidetone:

   // M0 = amount to adjust
   M0 = I0 - I7;
84202f9a:	7f f0 c8 c7 	M0 = I0 - I7;
   if NEG M0 = M0 + L0;
84202f9e:	c4 f8 c8 c5 	if NEG M0 = M0 + L0;

   // get number of speakers (1 or 2)
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84202fa2:	92 f0 02 88 	r0 = M[r7 + 8];
   M3 = r0;
84202fa6:	13 0b       	M3 = r0 + Null;

   // mixing offset address
   I2 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84202fa8:	92 f8 0c 20 	I2 = r7 + 12;

   // Get sidetone buffer and see how much we need to read
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84202fac:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_cbuffer;
84202fb0:	ff fd c6 f2 	call 0x5bd8c;
84202fb4:	3c ee 
   I5 = r0;
84202fb6:	15 0a       	I5 = r0 + Null;

   // see how much data is in sidetone buffer
   call $cbuffer.calc_amount_data_in_words;
84202fb8:	ff fd 49 f1 	call (m) 0x2c208;
84202fbc:	31 e2 
   r3 = r0;
84202fbe:	15 00       	r3 = r0 + Null;
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84202fc0:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84202fc4:	ff fd c6 f2 	call 0x5bd9c;
84202fc8:	38 ee 
   r0 = M[r0];
84202fca:	12 e8       	r0 = M[r0 + Null];
   r0 = r0 + r3;
84202fcc:	aa 00       	r0 = r3 + r0;
   // r0: amount we have
   // r5: amount we need
   // r6: amount to invent
   r1 = r5 - r0;
84202fce:	bb 04       	r1 = r5 - r0;
   if LE jump enough_data;
84202fd0:	03 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.enough_data;
      // Limit to amount available
      r5 = r5 - r1;
84202fd2:	ff 04       	r5 = r5 - r1;
      r6 = r6 + r1;
84202fd4:	18 0d       	r6 = r1 + r6;

84202fd6 <$M.cbops.aec_ref_sidetone_op.enough_data>:
   enough_data:

   r0 = I5;
84202fd6:	aa 08       	r0 = I5 + Null;
   call $cbuffer.get_read_address_and_size_and_start_address;
84202fd8:	ff fd 4b f1 	call (m) 0x2c6a4;
84202fdc:	2d e6 
   I7 = r0;
84202fde:	17 0a       	I7 = r0 + Null;
   L4 = r1;
84202fe0:	1e 0b       	L4 = r1 + Null;
   push r2;
84202fe2:	00 f0 34 cf 	push r2;
   pop B4;
84202fe6:	00 f6 3c cf 	pop B4;

   // speaker buffers
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84202fea:	92 f0 00 88 	r0 = M[r7 + 0];
   I3 = r0;
84202fee:	13 0a       	I3 = r0 + Null;

84202ff0 <$M.cbops.aec_ref_sidetone_op.channel_mixing_loop>:

channel_mixing_loop:

      // get base address for this speaker channel
      r0 = M[I3, MK1];
84202ff0:	2d f0 30 c0 	Null = Null + Null, r0 = M[I3,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
84202ff4:	d2 88       	r0 = M[r0 + 12];
      push r0;
84202ff6:	00 f0 32 cf 	push r0;
      pop B0;
84202ffa:	00 f6 3a cf 	pop B0;

      // get sidetone buffer
      I4 = I7;
84202ffe:	bc 0a       	I4 = I7 + Null;

      // get speaker mixing point
      r0 = M[I2, 0];
84203000:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      I0 = r0;
84203004:	10 0a       	I0 = r0 + Null;

      // M0 is amount to fix the mixing point (should be 0 in normal condition)
      r0 = M[I0, M0];
84203006:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

      // get last sidetone sample
      r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD];
8420300a:	92 f0 0c 88 	r0 = M[r7 + 48];

      r2 = 1.0;
8420300e:	ff f7 f4 f7 	r2 = Null + 2147483647;
84203012:	ff 7b 

      // r5 = sidetone samples to read and mix
      // r6 = sidetone samples to invent and mix
      r10 = r6;
84203014:	44 09       	r10 = r6 + Null;
      if Z jump insert_done;
84203016:	08 60       	if EQ jump (m) $M.cbops.aec_ref_sidetone_op.insert_done;
      do insert_loop;
84203018:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.insert_done;
         rMAC = M[I0, 0];
8420301a:	10 f0 30 c0 	Null = Null + Null, rMAC = M[I0,0];
         rMAC = rMAC + r0 * r2;
8420301e:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203022:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

84203026 <$M.cbops.aec_ref_sidetone_op.insert_done>:
      insert_loop:

      insert_done:
      r10 = r5;
84203026:	3c 09       	r10 = r5 + Null;
      do mix_loop;
84203028:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.mix_loop;
         rMAC = M[I0, 0], r0 = M[I4,MK1];
8420302a:	21 f0 31 d0 	Null = Null + Null, rMAC = M[I0,0], r0 = M[I4,4];
         rMAC = rMAC + r0 * r2;
8420302e:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203032:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

84203036 <$M.cbops.aec_ref_sidetone_op.mix_loop>:
      mix_loop:
      M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD] = r0;
84203036:	92 f0 0c 8e 	M[r7 + 48] = r0;

      // update mixing point for next time
      r1 = I0;
8420303a:	83 08       	r1 = I0 + Null;
      M[I2, MK1] = r1;
8420303c:	b9 f0 30 c0 	Null = Null + Null, M[I2,4] = r1;
   // next channel
   M3 = M3 - 1;
84203040:	bb fc 01 24 	M3 = M3 - 1;
   if GT jump channel_mixing_loop;
84203044:	d6 6b       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.channel_mixing_loop;

   // update sidetone buffer
   r0 = I5;
84203046:	aa 08       	r0 = I5 + Null;
   r1 = I4;
84203048:	a3 08       	r1 = I4 + Null;
   call $cbuffer.set_read_address;
8420304a:	ff fd 4b f1 	call (m) 0x2c708;
8420304e:	3f e5 

   pop rlink;
84203050:	00 f4 3d cf 	pop rLink;
   rts;
84203054:	d8 4c       	rts;

84203056 <$_aec_ref_sidetone_initialise>:
// TRASHED REGISTERS:
//    r0 (C callable)
//
// *****************************************************************************
$_aec_ref_sidetone_initialise:
   push rLink;
84203056:	00 f0 3d cf 	push rLink;
   pushm <I2,I3>;
8420305a:	00 f0 4c e4 	pushm <I2, I3>;
   pushm <r1,r2,r3,r7>;
8420305e:	23 f0 48 e0 	pushm <r1, r2, r3, r7>;

   // here we got pointer to the cbops structure, so need to get to the
   // parameter struct first.
   r7 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203062:	29 f0 03 88 	r7 = M[r0 + 12];

   // save the read address of first speaker buffer, we use this to see how many
   // samples speaker has read since last run
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203066:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
8420306a:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
8420306c:	ff fd 4b f1 	call (m) 0x2c6a4;
84203070:	39 e1 

   /* initialise mixing points */
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84203072:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r10 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203076:	9c f0 02 88 	r10 = M[r7 + 8];
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
8420307a:	92 f0 00 88 	r0 = M[r7 + 0];
   I2 = r0;
8420307e:	12 0a       	I2 = r0 + Null;
   I3 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84203080:	93 f8 0c 20 	I3 = r7 + 12;
   do init_mixing_points;
84203084:	06 4c       	do (m) $M.cbops.aec_ref_sidetone_op.init_mixing_points;
      r0 = M[I2, MK1];   // get speaker buffer
84203086:	29 f0 30 c0 	Null = Null + Null, r0 = M[I2,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420308a:	d2 88       	r0 = M[r0 + 12];
      M[I3, MK1] = r0;   // mixing point
8420308c:	ad f0 30 c0 	Null = Null + Null, M[I3,4] = r0;

84203090 <$M.cbops.aec_ref_sidetone_op.init_mixing_points>:
   init_mixing_points:

   popm <r1,r2,r3,r7>;
84203090:	23 f0 68 e0 	popm <r1, r2, r3, r7>;
   popm <I2,I3>;
84203094:	00 f0 6c e4 	popm <I2, I3>;
   pop rLink;
84203098:	00 f4 3d cf 	pop rLink;
   rts;
8420309c:	d8 4c       	rts;

8420309e <$_create_mute_op>:
.MODULE $M.download_support_lib.create_mute_op;
.CODESEGMENT PM;
.MINIM;

$_create_mute_op:
    rMAC = M[$_patched_fw_version];
8420309e:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842030a2:	10 f1 38 3f 	Null = rMAC - 7992;
    if EQ jump PATCH_ENTRY_CREATE_MUTE_OP;
842030a6:	fc ff 10 f0 	if EQ jump (m) 0x4003b60;
842030aa:	bb e5 

842030ac <$M.download_support_lib.create_mute_op.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return false; */
    r0 = 0;
842030ac:	02 00       	r0 = Null + Null;
    rts;
842030ae:	d8 4c       	rts;

842030b0 <$_set_aec_reference_not_running_from_rom>:
.CODESEGMENT PM;
.MINIM;
$_set_aec_reference_not_running_from_rom:
#ifndef DISABLE_PATCH_BUILD_ID_CHECK
    // panic if not using the right patch
    r0 = 0;
842030b0:	02 00       	r0 = Null + Null;
    rMAC = M[$_patched_fw_version];
842030b2:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842030b6:	10 f1 38 3f 	Null = rMAC - 7992;
    if NZ call $error;
842030ba:	f1 fd 4d f1 	if NE call (m) 0x2cb9c;
842030be:	23 e7 
    // if we have patch entry for setting the downloadable flag
    // then go to that patch.
    jump PATCH_ENTRY_SET_AEC_REFERENCE_NOT_RUNNING_FROM_ROM;
#else
   // otherwise quietly return
   rts;
842030c0:	d8 4c       	rts;

842030c2 <$M.download_support_lib.setup_cbops_dc_offset_compensation.return_null>:
#endif
return_null:
   /* if not matching then just return NULL,
    * so no dc offset op created/added
    */
    r0 = 0;
842030c2:	02 00       	r0 = Null + Null;
    rts;
842030c4:	d8 4c       	rts;
