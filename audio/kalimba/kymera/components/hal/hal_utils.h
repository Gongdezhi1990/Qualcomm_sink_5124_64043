/****************************************************************************
 * Copyright (c) 2007 - 2017 Qualcomm Technologies International, Ltd.
****************************************************************************/
/**
 * \file hal_utils.h
 *
 * \brief utility macros used by HAL macros
 *
 * Helper macros used by the macros in the autogenerated file
 * hal_macros.h.
 *
 * The use of these is discussed in more detail at
 * http://wiki/BlueCore_firmware_HAL
 *
 * \ingroup HAL
 */

/****************************************************************************
Include Files
*/
#include "hal_registers.h"

/****************************************************************************
FUNCTIONS FOR USE IN MANUALLY WRITTEN CODE

This section contains macros which are intended to be invoked by the
rest of the firmware. These should be used alongside the auto-generated
macros in hal_macros.h.

*/


#ifdef K32
    /* Im keeping REG_32BIT instead of replacing if for easier integration.
     */
    #define REG_32BIT
#endif /* K32 */

/**
 * \brief  Set a single field in a variable as if it were the given register, so
 * that the variable can later be used to set the register itself.
 *
 * \param  var  Variable to be set.
 *
 * \param  register  register which is to be compared
 *
 * \param  field  field to be set.
 *
 * \param  value value to be  written to the field.
 *
 * This macro checks that the given field name exists in the given
 * register, and fails to compile if not.
 *
 * \note
 * If you want to set multiple fields at once in an efficient way, use
 * \ref hal_set_var_for_register_fields
 *
 * \par
 * EXAMPLE
 *       hal_set_var_for_register_field(tardiness, CLKGEN_MINMAX_MMU_RATE,
 *            CLKGEN_MIN_MMU_RATE, min_rate);
 *
 */
#define hal_set_var_for_register_field(var, register, field, value) \
    CHECK_FIELD_TYPE(register, field)               \
    ((void) ((var) = ((var) & ~FIELD_MASK_SHIFTED(field)) | \
     ((value) << FIELD_SHIFT(field))))

/**
 * \brief  Set multiple fields in a variable as if it were the given register,
 * so that the variable can later be used to set the register itself.
 *
 * \param  var  Variable to be set.
 *
 * \param  register  register which is to be compared
 *
 * \param  fields  fields to be set as a (fieldname,value) pair.
 *
 * This macro checks that the given field names exists in the given
 * register, and fails to compile if not.
 *
 * \note
 * The syntax for this is slightly odd, because of the way it abuses the
 * pre-processor to do the job.
 *
 * \par
 * EXAMPLE
 *   hal_set_var_for_register_fields(varname, REGISTER, (
 *       (FIELDNAME, value,
 *       (FIELDNAME, value,
 *       ...
 *       (FIELDNAME, value, FIELDS_END
 *       )))));
 *
 * \par
 *  e.g.
 *  hal_set_var_for_register_fields(tardiness, CLKGEN_MINMAX_MMU_RATE,
 *          (CLKGEN_MAX_MMU_RATE, dormpsg.MAX_MMU_CLOCK,
 *           (CLKGEN_MIN_MMU_RATE, dormpsg.MAX_MMU_CLOCK, FIELDS_END)));
 *
 */
#define hal_set_var_for_register_fields(var, register, fields) \
    CHECK_FIELD_TYPE(register, FIRST_FIELD_NAME fields)     \
    ((void) ((var) = ((var) & ~FIELDS_MASKS_SHIFTED(register,fields)) | \
     (FIELDS_VALUES_SHIFTED(register, fields))))

/**
 * \brief  Set multiple fields in a constant as if it were the given register,
 * leaving any unspecified fields as zero.
 *
 * \param  register  register which is to be compared
 *
 * \param  fields  fields to be set as a (fieldname,value) pair.
 *
 * This can be used to assign to a variable directly (though
 * \ref hal_set_var_for_register_fields() is usually preferable) or creating
 * tables and the like.
 *
 * This macro checks that the given field names exist in the given register,
 * and fails to compile if not.
 *
 * \note
 * The syntax for this is slightly odd, because of the way it abuses the
 * preprocessor to do the job.
 *
 * \par
 * EXAMPLE
 *    mode = hal_make_register_fields(LPC_SLV_PMEM_WINDOW_LPC_MODE,
 *              (LPC_SLV_PMEM_WINDOW_LPC_MODE_40M, lpc_clkrate_80M,
 *               (LPC_SLV_PMEM_WINDOW_LPC_MODE_WIDTH, lpc_width_4bit)));
 */
#define hal_make_register_fields(register, fields) \
    CHECK_FIELD_TYPE(register, FIRST_FIELD_NAME fields) \
    (FIELDS_VALUES_SHIFTED(register, fields))

/**
 * \brief  Set multiple fields in the same register.
 *
 * \param  first  first field name
 *
 * \param  val value to be  written to the field.
 *
 * \param  rest  rest of the fields to be set as a (fieldname,value) pair.
 *
 * This macro checks that the given field names exist in the same register,
 * and fails to compile if not.
 *
 * \note
 * The syntax for this is slightly odd, because of the way it abuses the
 * preprocessor to do the job.
 *
 * \par
 * EXAMPLE
 *  hal_set_fields(
 *       FIELDNAME, value,
 *       (FIELDNAME, value,
 *       ...
 *       (FIELDNAME, value, FIELDS_END
 *       )));
 *
 * \par
 *  e.g.
 *  hal_set_fields(INT_CLRB, 1, (INT_EN, 1, (INT_EVENT_EN, 1, FIELDS_END)));
 *
 */
#define hal_set_fields(first, val, rest)                \
    hal_set_register_fields(REGISTER_FOR(first), (first, val, rest))

/**
 * \brief  Get a single field from a variable as if it were the given register,
 * so that an existing copy of the register can be tested.
 *
 * \param  var  Variable to be read.
 *
 * \param  register  register which is to be compared
 *
 * \param  field  field to be read.
 *
 * This macro checks that the given field name exist in the given register,
 * and fails to compile if not.
 *
 * \note
 * EXAMPLE
 *       min_rate = hal_get_register_field_from_var(tardiness,
 *           CLKGEN_MINMAX_MMU_RATE, CLKGEN_MIN_MMU_RATE);
 *
 */
#define hal_get_register_field_from_var(var, register, field) \
    CHECK_FIELD_TYPE(register, field)               \
    (((var) & FIELD_MASK_SHIFTED(field)) >> FIELD_SHIFT(field))

/**
 * \brief Sets a single field from a variable assuming the field in the variable
 * is in the correct position.
 *
 * \param  register
 *
 * \param  field
 *
 * \param  shifted_field
 *
 * This macro checks that the given field name exists in the given register,
 * and fails to compile if not.
 *
 * \note
 * The user must ensure that the other fields in the variable are not set,
 * as for better optimisation this macro does not mask them.
 *
 * \par
 * EXAMPLE
 *       hal_set_register_field_already_shifted(BT_ANA_RX_MIX_CONFIG,
 *                                              BT_ANA_RX_MIX_CMM,
 *                                              mixer_cmm_rx_mode);
 *
 */
#ifdef REG_32BIT
#define hal_set_register_field_already_shifted(register, field, shifted_field) \
    CHECK_FIELD_TYPE(register, field)                                   \
    SETTER_FOR(register)((GETTER_FOR(register)() & ~FIELD_MASK_SHIFTED(field)) | \
            ((uint32) (shifted_field)))
#else
#define hal_set_register_field_already_shifted(register, field, shifted_field) \
    CHECK_FIELD_TYPE(register, field)                                   \
    SETTER_FOR(register)((GETTER_FOR(register)() & ~FIELD_MASK_SHIFTED(field)) | \
                         ((uint24) (shifted_field)))
#endif

/**
 * \brief Tests a field in a variable as if it was the register the field refers
 * to, returning TRUE if the field in the variable is equal to the value given.
 *
 * \param  var
 *
 * \param  field
 *
 * \param  value
 *
 * \note
 * EXAMPLE
 *        if (hal_equals_field_in_var(mode,
 *                                    LPC_SLV_PMEM_WINDOW_LPC_MODE_40M,
 *                                    lpc_clkrate_80M))
 *        {
 *             Going fast...
 *        }
 */
#define hal_equals_field_in_var(var, field, value) \
    hal_equals_register_field_in_var(var, REGISTER_FOR(field), field, value)

/**
 * \brief As \ref hal_equals_field_in_var except that the register that the
 * variable is to be treated as is explicitly supplied rather than inferred.
 *
 * \param  var
 *
 * \param  register
 *
 * \param  field
 *
 * \param  value
 *
 * This macro checks that the given field name exists in the given register,
 * and fails to compile if not.
 *
 * \note
 * EXAMPLE
 *        if (hal_equals_register_field_in_var(mode,
 *              LPC_SLV_PMEM_WINDOW_LPC_MODE,
 *              LPC_SLV_PMEM_WINDOW_LPC_MODE_40M,
 *              lpc_clkrate_80M))
 *        {
 *             Going fast...
 *        }
 */
#define hal_equals_register_field_in_var(var, register, field, value) \
    CHECK_FIELD_TYPE(register, field) \
    (((var) & FIELD_MASK_SHIFTED(field)) == ((value) << FIELD_SHIFT(field)))

/**
 * \brief Tests a field in a pair of variables as if they were the register the
 * field refers to, returning TRUE if the field in the variables are equal.
 *
 * \param  var1
 *
 * \param  var2
 *
 * \param  field
 *
 * \note
 * EXAMPLE
 *        if (hal_equals_field_in_vars(this_mode, that_mode,
 *                                     LPC_SLV_PMEM_WINDOW_LPC_MODE_40M))
 *        {
 *             Same speed...
 *        }
 */
#define hal_equals_field_in_vars(var1, var2, field) \
    hal_equals_register_field_in_vars(var1, var2, REGISTER_FOR(field), field)

/**
 * \brief As \ref hal_equals_field_in_vars except that the register that the
 * variables are to be treated as is explicitly supplied rather than inferred.
 *
 * \param  var1
 *
 * \param  var2
 *
 * \param  register
 *
 * \param  field
 *
 * This macro checks that the given field name exists in the given register,
 * and fails to compile if not.
 *
 * \note
 * This macro should be used in preference to something like
 *         hal_get_register_field_from_var(v1, reg, fld) ==
 *         hal_get_register_field_from_var(v2, req, fld)
 * since avoids unnecessary shifts and should generate better code.
 *
 * \par
 * EXAMPLE
 *        if (hal_equals_register_field_in_vars(
 *              this_mode, that_mode,
 *              LPC_SLV_PMEM_WINDOW_LPC_MODE,
 *              LPC_SLV_PMEM_WINDOW_LPC_MODE_WIDTH))
 *        {
 *             Same bus width...
 *        }
 */
#define hal_equals_register_field_in_vars(var1, var2, register, field) \
    CHECK_FIELD_TYPE(register, field) \
    ((((var1) ^ (var2)) & FIELD_MASK_SHIFTED(field)) == 0)

/**
 * \brief Tests a number of fields in a pair of variables as if they were the
 * register the field refers to, returning TRUE if the fields are the same in
 * both variables.
 *
 * \param  var1
 *
 * \param  var2
 *
 * \param  fields  fields to be set as a (fieldname,value) pair.
 *
 * \note
 * The syntax for this is slightly odd, because of the way it abuses the
 * pre-processor to do the job. It's even odder than the usual "fields" macros
 * because the parameter after each field is unused.  A tidier solution would
 * be to add another set of magic "FIELDS" auto-generated macros, but it really
 * doesn't seem worth the effort.
 *
 * \par
 * EXAMPLE
 *        if (hal_equals_fields_in_vars(
 *              this_mode, that_mode,
 *              (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_40M, 0
 *               (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_FORCE_BYPASS_VAL, 0,
 *                (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_FORCE_BYPASS_EN, 0)))))
 *        {
 *            Timing values all the same...
 *        }
 */
#define hal_equals_fields_in_vars(var1, var2, fields) \
    hal_equals_register_fields_in_vars(var1, var2, REGISTER_FOR(FIRST_FIELD_NAME fields), fields)

/**
 * \brief As \ref hal_equals_fields_in_vars except that the register that the
 * variables are to be treated as is explicitly supplied rather than inferred.
 *
 * \param  var1
 *
 * \param  var2
 *
 * \param  register
 *
 * \param  fields
 *
 * This macro checks that the given field name exists in the given register,
 * and fails to compile if not.
 *
 * \note
 * The syntax for this is slightly odd, because of the way it abuses the
 * pre-processor to do the job. It's even odder than the usual "fields" macros
 * because the parameter after each field is unused.  A tidier solution would
 * be to add another set of magic "FIELDS" auto-generated macros, but it really
 * doesn't seem worth the effort.
 *
 * \par
 * EXAMPLE
 *        if (hal_equals_register_fields_in_vars(
 *              this_mode, that_mode,
 *              LPC_SLAVE_PMEM_WINDOW_LPC_MODE,
 *              (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_40M, 0
 *               (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_FORCE_BYPASS_VAL, 0,
 *                (LPC_SLAVE_PMEM_WINDOW_LPC_MODE_FORCE_BYPASS_EN, 0)))))
 *        {
 *            Timing values all the same...
 *        }
 */
#define hal_equals_register_fields_in_vars(var1, var2, register, fields) \
    CHECK_FIELD_TYPE(register, FIRST_FIELD_NAME fields) \
    ((((var1) ^ (var2)) & FIELDS_MASKS_SHIFTED(register, fields)) == 0)

/*******************************************************************
FUNCTIONS FOR USE IN AUTOGENERATED CODE

This section contains macros which are intended to be invoked by the
hal_macros.h auto-generated header file. The rest of the firmware should
not need to invoke them, because hal_macros.h should define the relevant
accessor macro, e.g.

#define hal_set_disco_lights_en(x) hal_set_field(DISCO_LIGHTS_EN,(x))

It also contains the macros which are invoked by the macros in the
previous section.

*/
#define hal_set_field(field, value) \
    hal_set_register_field(REGISTER_FOR(field), field, value)

#ifdef REG_32BIT
#define hal_set_register_field(register, field, value)  \
    CHECK_FIELD_TYPE(register, field)                   \
       SETTER_FOR(register)((GETTER_FOR(register)() &   \
                          ~FIELD_MASK_SHIFTED(field)) | \
       ((uint32) (value) << FIELD_SHIFT(field)))
#else
#define hal_set_register_field(register, field, value)  \
    CHECK_FIELD_TYPE(register, field)                   \
    SETTER_FOR(register)((GETTER_FOR(register)() &      \
                          ~FIELD_MASK_SHIFTED(field)) | \
            ((uint24) (value) << FIELD_SHIFT(field)))
#endif

#define hal_set_register_fields(register, fields) \
    CHECK_FIELD_TYPE(register, FIRST_FIELD_NAME fields)                 \
    SETTER_FOR(register)((GETTER_FOR(register)() &                      \
                          ~FIELDS_MASKS_SHIFTED(register, fields)) |    \
                         (FIELDS_VALUES_SHIFTED(register, fields)))

#define hal_get_field(field) \
    hal_get_register_field(REGISTER_FOR(field), field)

#ifdef REG_32BIT
#define hal_get_register_field8(register, field) \
    ((uint8) (hal_get_register_field(register, field)))
#define hal_get_register_field16(register, field) \
    ((uint16) (hal_get_register_field(register, field)))
#define hal_get_register_field32(register, field) \
    ((uint32) (hal_get_register_field(register, field)))

#define hal_get_register_field(register, field) \
    CHECK_FIELD_TYPE(register, field)           \
    ((uint32) ((GETTER_FOR(register)() >> FIELD_SHIFT(field)) & FIELD_MASK(field)))
#else
#define hal_get_register_field(register, field) \
    CHECK_FIELD_TYPE(register, field)           \
    ((uint24) ((GETTER_FOR(register)() >> FIELD_SHIFT(field)) & FIELD_MASK(field)))
#endif

#define hal_test_field(field) \
    hal_test_register_field(REGISTER_FOR(field), field)

#define hal_test_register_field(register, field) \
    CHECK_FIELD_TYPE(register, field)            \
    (GETTER_FOR(register)() & FIELD_MASK_SHIFTED(field))

/****************************************************************************
HIDDEN WORKINGS

This section contains stuff from which you should avert your eyes. Nothing to
see here, move along.

*/

#define FIELDS_END (END, 0, (END))

/* We enforce that the bits for reg REG are named REG_..._[ML]SB_POSN */

#define REGISTER_FOR(bit) REGISTER_FOR_(bit)
#define REGISTER_FOR_(bit) REGISTER_FOR_ ## bit
#define TYPE_OF(bit) TYPE_OF_(bit)
#define TYPE_OF_(bit) TYPE_OF_ ## bit

#define FIELD_MASK(field) FIELD_MASK_1(REGISTER_FOR(field), field)
#define FIELD_MASK_1(reg, field) FIELD_MASK_2(reg, field)

#ifdef REG_32BIT
#define FIELD_MASK_2(reg, field) \
        ((uint32) ((1UL<<(reg ## _ ## field ## _MSB_POSN - \
                    reg ## _ ## field ## _LSB_POSN + 1)) -1))
#else
#define FIELD_MASK_2(reg, field) \
    ((uint24) ((1UL<<(reg ## _ ## field ## _MSB_POSN - \
                reg ## _ ## field ## _LSB_POSN + 1)) -1))
#endif
#define FIELD_SHIFT(field) FIELD_SHIFT_1(REGISTER_FOR(field), field)
#define FIELD_SHIFT_1(reg, field) FIELD_SHIFT_2(reg, field)
#define FIELD_SHIFT_2(reg, field) reg ## _ ## field ## _LSB_POSN
#define FIELD_MASK_SHIFTED(field) (FIELD_MASK(field) << FIELD_SHIFT(field))

#define FIELD_LENGTH_2(reg, field) ((reg ## _ ## field ## _MSB_POSN) - \
                                    (reg ## _ ## field ## _LSB_POSN) + 1)
#define FIELD_LENGTH_1(reg, field) FIELD_LENGTH_2(reg, field)
#define FIELD_LENGTH(field) FIELD_LENGTH_1(REGISTER_FOR(field), field)

#define FIELDS_MASKS_SHIFTED(register, fields) \
    (FIELDS_MASKS_SHIFTED_ ## register fields)

#define FIELDS_VALUES_SHIFTED(register, fields) \
    (FIELDS_VALUES_SHIFTED_ ## register fields)

#define FIELDS_MASKS_SHIFTED_END(end) 0
#define FIELDS_VALUES_SHIFTED_END(end) 0

#define FIRST_FIELD_NAME(a, b, c) a
#define TYPE_OF_END END
#define REGISTER_FOR_END_END_LSB_POSN 0
#define REGISTER_FOR_END_END_MSB_POSN -1

#define CHECK_FIELD_TYPE(reg, bit) CHECK_FIELD_TYPE_(reg, TYPE_OF(bit))
#define CHECK_FIELD_TYPE_(reg, type) CHECK_FIELD_TYPE__(reg, type)
#define CHECK_FIELD_TYPE__(reg, type) \
    CHECK_FIELD_TYPE_ ## reg ## _ ## type

#define GETTER_FOR(reg) GETTER_FOR_ ## reg
#define SETTER_FOR(reg) SETTER_FOR_ ## reg
