
/home/svc-audio-dspsw/kymera_builds/builds/2019/kymera_1907221320/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_rtp_decode.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_rtp_decode_create>:
}

/* ********************************** API functions ************************************* */

bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200000:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200002:	17 00       	r5 = r0 + Null;
84200004:	1a 09       	r8 = r1 + Null;
84200006:	20 09       	r6 = r2 + Null;
84200008:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420000a:	0a f0 39 e8 	call (m) $_base_op_get_instance_data;
8420000e:	16 00       	r4 = r0 + Null;
bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200010:	4d 08       	r3 = r7 + Null;
84200012:	44 08       	r2 = r6 + Null;
84200014:	53 08       	r1 = r8 + Null;
84200016:	3a 00       	r0 = r5 + Null;
84200018:	ff fd 00 f0 	call (m) 0x8c;
8420001c:	35 e3 
8420001e:	10 04       	Null = r0 - Null;
84200020:	03 62       	if NE jump (m) Lc_rtp_decode_create_3;

84200022 <Lc_rtp_decode_create_2>:
    {
        return FALSE;
84200022:	02 00       	r0 = Null + Null;
84200024:	15 6e       	jump (m) Lc_rtp_decode_create_4;

84200026 <Lc_rtp_decode_create_3>:
    }

    /* Make sure the input and output buffer is null. */
    opx_data->ip_buffer = NULL;
84200026:	f0 9f       	M[r4 + 60] = Null;
    opx_data->op_buffer = NULL;
84200028:	30 ae       	M[r4 + 64] = Null;

    /* Reset the first tag logic.*/
    opx_data->continuation_for_frame = FALSE;
8420002a:	f0 8f       	M[r4 + 28] = Null;

    opx_data->latency_buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
8420002c:	01 f0 00 42 	rMAC = Null + 512;
84200030:	71 af       	M[r4 + 84] = rMAC;
    opx_data->kick_on_full_output = FALSE;
84200032:	f0 be       	M[r4 + 108] = Null;

    opx_data->aac_codec = NULL;
84200034:	70 8f       	M[r4 + 20] = Null;

    opx_data->aac_utility_select = AAC_LC_OVER_LATM;
84200036:	30 ba       	MB[r4 + 24] = Null;

    opx_data->max_packet_len = 0;
84200038:	f0 af       	M[r4 + 92] = Null;
    opx_data->last_toa_valid = FALSE;
8420003a:	70 be       	M[r4 + 100] = Null;
    opx_data->last_op_tag_octets = opx_data->max_packet_len;
8420003c:	b0 be       	M[r4 + 104] = Null;

    opx_data->prev_src_id = SRC_ID_INVALID;
8420003e:	bc fa 81 f6 	rMAC = Null + -1412623820;
84200042:	34 62 
84200044:	b1 bf       	M[r4 + 120] = rMAC;
    /* Initialise specific data (was allocated and pointer to it filled by OpMgr  */
    rtp_decode_reset_working_data(op_data);
84200046:	3a 00       	r0 = r5 + Null;
84200048:	05 f0 21 e4 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
8420004c:	42 20       	r0 = Null + 1;

8420004e <Lc_rtp_decode_create_4>:
}
8420004e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200050:	d8 4c       	rts;

84200052 <$_rtp_decode_destroy>:


bool rtp_decode_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200052:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200054:	16 00       	r4 = r0 + Null;
84200056:	19 09       	r7 = r1 + Null;
84200058:	20 09       	r6 = r2 + Null;
8420005a:	2f 00       	r5 = r3 + Null;
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
8420005c:	0a f0 2f e3 	call (m) $_opmgr_op_is_running;
84200060:	10 04       	Null = r0 - Null;
84200062:	08 60       	if EQ jump (m) Lc_rtp_decode_destroy_3;

84200064 <Lc_rtp_decode_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200064:	03 f0 00 60 	r1 = Null + 4096;
84200068:	3c 00       	r2 = r5 + Null;
8420006a:	32 00       	r0 = r4 + Null;
8420006c:	0a f0 2b e4 	call (m) $_base_op_build_std_response_ex;
84200070:	16 6e       	jump (m) Lc_rtp_decode_destroy_4;

84200072 <Lc_rtp_decode_destroy_3>:
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200072:	32 00       	r0 = r4 + Null;
84200074:	0a f0 2f e5 	call (m) $_base_op_get_instance_data;
84200078:	12 09       	r8 = r0 + Null;
    else
    {
        RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

        /* Delete the time to play instance*/
        ttp_free(opx_data->ttp_instance);
8420007a:	a2 f0 14 88 	r0 = M[r8 + 80];
8420007e:	ff fd b5 f0 	call (m) 0x16af4;
84200082:	37 e3 

        pfree(opx_data->src_latency_map);
84200084:	a2 f0 1c 88 	r0 = M[r8 + 112];
84200088:	ff fd 27 f0 	call (m) 0x4f62;
8420008c:	3b e6 

    /* call base_op destroy that creates and fills response message, too */
        return base_op_destroy(op_data, message_data, response_id, response_data);
8420008e:	3d 00       	r3 = r5 + Null;
84200090:	44 08       	r2 = r6 + Null;
84200092:	4b 08       	r1 = r7 + Null;
84200094:	32 00       	r0 = r4 + Null;
84200096:	ff fd 00 f0 	call (m) 0xac;
8420009a:	37 e0 

8420009c <Lc_rtp_decode_destroy_4>:
    }
}
8420009c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420009e:	d8 4c       	rts;

842000a0 <$_rtp_decode_start>:

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000a0:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842000a2:	16 00       	r4 = r0 + Null;
842000a4:	19 09       	r7 = r1 + Null;
842000a6:	20 09       	r6 = r2 + Null;
842000a8:	2f 00       	r5 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842000aa:	0a f0 39 e3 	call (m) $_base_op_get_instance_data;

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    if ((opx_data->mode == RTP_DECODE)  || (opx_data->mode == RTP_TTP_ONLY))
842000ae:	11 90       	rMAC = MBS[r0 + 8];
842000b0:	48 24       	Null = rMAC - 1;
842000b2:	03 60       	if EQ jump (m) Lc_rtp_decode_start_3;

842000b4 <Lc_rtp_decode_start_2>:
842000b4:	c8 24       	Null = rMAC - 3;
842000b6:	18 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000b8 <Lc_rtp_decode_start_3>:
    {
        /* Check if the sample rate is different than zero. */
        if(opx_data->sample_rate == 0)
842000b8:	90 a9       	Null = M[r0 + 88];
842000ba:	08 62       	if NE jump (m) Lc_rtp_decode_start_5;

842000bc <Lc_rtp_decode_start_4>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000bc:	03 f0 00 60 	r1 = Null + 4096;
842000c0:	3c 00       	r2 = r5 + Null;
842000c2:	32 00       	r0 = r4 + Null;
842000c4:	0a f0 33 e1 	call (m) $_base_op_build_std_response_ex;
842000c8:	16 6e       	jump (m) Lc_rtp_decode_start_10;

842000ca <Lc_rtp_decode_start_5>:
        }
    }

    if((opx_data->mode == RTP_DECODE) && (opx_data->codec_type == AAC) && (opx_data->aac_codec == NULL))
842000ca:	48 24       	Null = rMAC - 1;
842000cc:	0d 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000ce <Lc_rtp_decode_start_6>:
842000ce:	51 a0       	rMAC = MBS[r0 + 17];
842000d0:	08 25       	Null = rMAC - 4;
842000d2:	0a 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000d4 <Lc_rtp_decode_start_7>:
842000d4:	51 89       	rMAC = M[r0 + 20];
842000d6:	08 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000d8 <Lc_rtp_decode_start_8>:
    {
        /* It is very hard to decode and AAC frame to get the sample count. Therefore
         * RTP decode needs the help of a decoder which is set through the
         * OPMSG_RTP_DECODE_ID_SET_AAC_DECODER message. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000d8:	03 f0 00 60 	r1 = Null + 4096;
842000dc:	3c 00       	r2 = r5 + Null;
842000de:	32 00       	r0 = r4 + Null;
842000e0:	0a f0 37 e0 	call (m) $_base_op_build_std_response_ex;
842000e4:	08 6e       	jump (m) Lc_rtp_decode_start_10;

842000e6 <Lc_rtp_decode_start_9>:
    }

    return base_op_start(op_data, message_data, response_id, response_data);
842000e6:	3d 00       	r3 = r5 + Null;
842000e8:	44 08       	r2 = r6 + Null;
842000ea:	4b 08       	r1 = r7 + Null;
842000ec:	32 00       	r0 = r4 + Null;
842000ee:	ef fd ff ff 	call (m) 0x4a;
842000f2:	3d ea 

842000f4 <Lc_rtp_decode_start_10>:
}
842000f4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842000f6:	d8 4c       	rts;

842000f8 <$_rtp_decode_reset>:

bool rtp_decode_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000f8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842000fa:	16 00       	r4 = r0 + Null;
    if (!base_op_reset(op_data, message_data, response_id, response_data))
842000fc:	ef fd ff ff 	call (m) 0x28;
84200100:	2d e9 
84200102:	10 04       	Null = r0 - Null;
84200104:	03 62       	if NE jump (m) Lc_rtp_decode_reset_3;

84200106 <Lc_rtp_decode_reset_2>:
    {
        return FALSE;
84200106:	02 00       	r0 = Null + Null;
84200108:	05 6e       	jump (m) Lc_rtp_decode_reset_4;

8420010a <Lc_rtp_decode_reset_3>:
    }

    /* now initialise specific working data */
    rtp_decode_reset_working_data(op_data);
8420010a:	32 00       	r0 = r4 + Null;
8420010c:	04 f0 3d ed 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
84200110:	42 20       	r0 = Null + 1;

84200112 <Lc_rtp_decode_reset_4>:
}
84200112:	f1 48       	popm <FP, r4, rLink>;
84200114:	d8 4c       	rts;

84200116 <$_rtp_decode_connect>:

    return buffer;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200116:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200118:	11 09       	r7 = r0 + Null;
8420011a:	18 09       	r6 = r1 + Null;
8420011c:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420011e:	0a f0 25 e0 	call (m) $_base_op_get_instance_data;
84200122:	17 00       	r5 = r0 + Null;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
84200124:	86 f0 00 e8 	r4 = M[r6 + Null];
    unsigned  channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200128:	03 00       	r1 = Null + Null;
8420012a:	54 08       	r2 = r8 + Null;
8420012c:	4a 08       	r0 = r7 + Null;
8420012e:	09 f0 29 ee 	call (m) $_base_op_build_std_response_ex;
84200132:	10 04       	Null = r0 - Null;
84200134:	03 62       	if NE jump (m) Lc_rtp_decode_connect_3;

84200136 <Lc_rtp_decode_connect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200136:	02 00       	r0 = Null + Null;
84200138:	67 6e       	jump (m) Lc_rtp_decode_connect_17;

8420013a <Lc_rtp_decode_connect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
8420013a:	bf ff 61 ff 	rMAC = r4 AND 0xff7fffff;
8420013e:	ff 1f 
84200140:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_5;

84200142 <Lc_rtp_decode_connect_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
84200142:	01 f0 03 60 	rMAC = Null + 4099;
84200146:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420014a:	51 8e       	M[r0 + 4] = rMAC;
8420014c:	5c 6e       	jump (m) Lc_rtp_decode_connect_16;

8420014e <Lc_rtp_decode_connect_5>:
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    if (terminal_id & TERMINAL_SINK_MASK)
8420014e:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200152:	00 00 
84200154:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_8;

84200156 <Lc_rtp_decode_connect_6>:
    {
        if (opx_data->ip_buffer == NULL)
84200156:	f9 99       	rMAC = M[r5 + 60];
84200158:	3c 62       	if NE jump (m) Lc_rtp_decode_connect_13;

8420015a <Lc_rtp_decode_connect_7>:
        {
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->ip_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
8420015a:	81 f0 01 88 	rMAC = M[r6 + 4];
8420015e:	f9 9f       	M[r5 + 60] = rMAC;
84200160:	52 6e       	jump (m) Lc_rtp_decode_connect_16;

84200162 <Lc_rtp_decode_connect_8>:
            return TRUE;
        }
    }
    else
    {
        if (opx_data->op_buffer == NULL)
84200162:	39 a8       	rMAC = M[r5 + 64];
84200164:	36 62       	if NE jump (m) Lc_rtp_decode_connect_13;

84200166 <Lc_rtp_decode_connect_9>:
        {
            tCbuffer *connection_buf = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84200166:	86 f0 01 88 	r4 = M[r6 + 4];
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->op_buffer = connection_buf;
8420016a:	3e ae       	M[r5 + 64] = r4;
#ifdef DATAFORMAT_32
            cbuffer_set_usable_octets(opx_data->op_buffer, NR_OF_OCTETS_IN_WORD(USE_32BIT_PER_WORD));
#else
            cbuffer_set_usable_octets(opx_data->op_buffer, NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD));
8420016c:	83 20       	r1 = Null + 2;
8420016e:	32 00       	r0 = r4 + Null;
84200170:	09 f0 3b e9 	call (m) $_cbuffer_set_usable_octets;
#endif /* DATAFORMAT_32 */
            {

                if (opx_data->pack_latency_buffer)
84200174:	78 b9       	Null = M[r5 + 116];
84200176:	33 60       	if EQ jump (m) Lc_rtp_decode_connect_14;

84200178 <Lc_rtp_decode_connect_10>:
                    opx_data->u.pack.frame_buffer = rtp_create_internal_buffer(
                            NULL,/* Create a new buffer for decoding the rtp payload. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
84200178:	32 00       	r0 = r4 + Null;
8420017a:	ff fd 93 f0 	call (m) 0x12858;
8420017e:	3f e6 
84200180:	13 00       	r1 = r0 + Null;
84200182:	85 20       	r3 = Null + 2;
84200184:	74 89       	r2 = M[r4 + 20];
84200186:	02 00       	r0 = Null + Null;
84200188:	06 f0 2f e2 	call (m) Lc_rtp_create_internal_buffer_1;
8420018c:	ba ae       	M[r5 + 72] = r0;
                    if(opx_data->u.pack.frame_buffer == NULL)
8420018e:	b9 a8       	rMAC = M[r5 + 72];
84200190:	20 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

84200192 <Lc_rtp_decode_connect_11>:
                    opx_data->u.pack.clone_frame_buffer = rtp_create_internal_buffer(
                            opx_data->u.pack.frame_buffer->base_addr, /* clone buffer is only used to discard corrupt frames. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
84200192:	32 00       	r0 = r4 + Null;
84200194:	ff fd 93 f0 	call (m) 0x12858;
84200198:	25 e6 
8420019a:	13 00       	r1 = r0 + Null;
8420019c:	85 20       	r3 = Null + 2;
8420019e:	74 89       	r2 = M[r4 + 20];
842001a0:	b9 a8       	rMAC = M[r5 + 72];
842001a2:	ca 88       	r0 = M[rMAC + 12];
842001a4:	06 f0 33 e1 	call (m) Lc_rtp_create_internal_buffer_1;
842001a8:	7a ae       	M[r5 + 68] = r0;
                    if(opx_data->u.pack.clone_frame_buffer == NULL)
842001aa:	79 a8       	rMAC = M[r5 + 68];
842001ac:	12 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001ae <Lc_rtp_decode_connect_12>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                        return TRUE;
                    }
                    opx_data->u.pack.clone_frame_buffer->aux_ptr = (void*)(opx_data->u.pack.frame_buffer);
842001ae:	ba a8       	r0 = M[r5 + 72];
842001b0:	0a 8f       	M[rMAC + 16] = r0;
                    BUF_DESC_IN_PLACE_SET(opx_data->u.pack.clone_frame_buffer->descriptor); /* this is an inplace buffer. */
842001b2:	79 a8       	rMAC = M[r5 + 68];
842001b4:	09 29       	rMAC = rMAC + 20;
842001b6:	0a e8       	r0 = M[rMAC + Null];
842001b8:	d2 ce       	r0 = r0 OR 0x10000;
842001ba:	0a ee       	M[rMAC + Null] = r0;
                    opx_data->u.pack.internal_buffer = rtp_create_internal_buffer(
                            NULL, /* Create a new buffer */
                            opx_data->latency_buffer_size/2, /* Due to packing use half of the size. */
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_32BIT_PER_WORD)
                    );
842001bc:	05 21       	r3 = Null + 4;
842001be:	74 89       	r2 = M[r4 + 20];
842001c0:	7a a9       	r0 = M[r5 + 84];
842001c2:	13 50       	r1 = r0 LSHIFT -1;
842001c4:	02 00       	r0 = Null + Null;
842001c6:	06 f0 31 e0 	call (m) Lc_rtp_create_internal_buffer_1;
842001ca:	fa ae       	M[r5 + 76] = r0;
                    if(opx_data->u.pack.internal_buffer == NULL)
842001cc:	f9 a8       	rMAC = M[r5 + 76];
842001ce:	1b 62       	if NE jump (m) Lc_rtp_decode_connect_16;

842001d0 <Lc_rtp_decode_connect_13>:
842001d0:	01 f0 00 60 	rMAC = Null + 4096;
842001d4:	a2 f0 00 e8 	r0 = M[r8 + Null];
842001d8:	51 8e       	M[r0 + 4] = rMAC;
842001da:	15 6e       	jump (m) Lc_rtp_decode_connect_16;

842001dc <Lc_rtp_decode_connect_14>:
                    /* Now, clone the buffer which will be used internally. Make it an in-place
                     * buffer to save place and to avoid overwriting data. Note the output
                     * buffer is not in-place just the internal one. Also the clone buffer
                     * does not need to hold any metadata, however metadata must be allocated
                     * otherwise the buffer is treated as 32bit when running in stre rom v02. */
                    buffer_flags = connection_buf->descriptor;
842001dc:	68 f0 05 88 	r6 = M[r4 + 20];
                    BUF_DESC_IN_PLACE_SET(buffer_flags);
842001e0:	00 f1 00 f8 	r6 = r6 OR 0x10000;
842001e4:	58 d8 
                    in_place_buffer =  rtp_create_internal_buffer(
                            connection_buf->base_addr, /* clone the output buffer. */
                            cbuffer_get_size_in_words(connection_buf),
                            buffer_flags,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
842001e6:	32 00       	r0 = r4 + Null;
842001e8:	ff fd 93 f0 	call (m) 0x12858;
842001ec:	31 e3 
842001ee:	13 00       	r1 = r0 + Null;
842001f0:	85 20       	r3 = Null + 2;
842001f2:	f2 88       	r0 = M[r4 + 12];
842001f4:	44 08       	r2 = r6 + Null;
842001f6:	05 f0 21 ef 	call (m) Lc_rtp_create_internal_buffer_1;
                    if(in_place_buffer == NULL)
842001fa:	10 04       	Null = r0 - Null;
842001fc:	ea 61       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001fe <Lc_rtp_decode_connect_15>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);

                        return TRUE;
                    }
                    opx_data->u.clone_op_buffer = in_place_buffer;
842001fe:	7a ae       	M[r5 + 68] = r0;
                    opx_data->u.clone_op_buffer->aux_ptr = (void*)opx_data->op_buffer;
84200200:	39 a8       	rMAC = M[r5 + 64];
84200202:	11 8f       	M[r0 + 16] = rMAC;

84200204 <Lc_rtp_decode_connect_16>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200204:	42 20       	r0 = Null + 1;

84200206 <Lc_rtp_decode_connect_17>:
        }
    }


    return TRUE;
}
84200206:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200208:	d8 4c       	rts;

8420020a <$_rtp_decode_disconnect>:


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420020a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420020c:	11 09       	r7 = r0 + Null;
8420020e:	1f 00       	r5 = r1 + Null;
84200210:	28 09       	r6 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200212:	09 f0 31 e8 	call (m) $_base_op_get_instance_data;
84200216:	16 00       	r4 = r0 + Null;


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
84200218:	3f e8       	r5 = M[r5 + Null];
    unsigned channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420021a:	03 00       	r1 = Null + Null;
8420021c:	44 08       	r2 = r6 + Null;
8420021e:	4a 08       	r0 = r7 + Null;
84200220:	09 f0 37 e6 	call (m) $_base_op_build_std_response_ex;
84200224:	10 04       	Null = r0 - Null;
84200226:	03 62       	if NE jump (m) Lc_rtp_decode_disconnect_3;

84200228 <Lc_rtp_decode_disconnect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200228:	02 00       	r0 = Null + Null;
8420022a:	2a 6e       	jump (m) Lc_rtp_decode_disconnect_11;

8420022c <Lc_rtp_decode_disconnect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
8420022c:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200230:	ff 1f 
84200232:	07 60       	if EQ jump (m) Lc_rtp_decode_disconnect_5;

84200234 <Lc_rtp_decode_disconnect_4>:
84200234:	01 f0 03 60 	rMAC = Null + 4099;
84200238:	82 f0 00 e8 	r0 = M[r6 + Null];
8420023c:	51 8e       	M[r0 + 4] = rMAC;
8420023e:	1f 6e       	jump (m) Lc_rtp_decode_disconnect_10;

84200240 <Lc_rtp_decode_disconnect_5>:
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }


    if (terminal_id & TERMINAL_SINK_MASK)
84200240:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200244:	00 00 
84200246:	03 60       	if EQ jump (m) Lc_rtp_decode_disconnect_7;

84200248 <Lc_rtp_decode_disconnect_6>:
    {
        opx_data->ip_buffer = NULL;
84200248:	f0 9f       	M[r4 + 60] = Null;
8420024a:	19 6e       	jump (m) Lc_rtp_decode_disconnect_10;

8420024c <Lc_rtp_decode_disconnect_7>:
    }
    else
    {
        opx_data->op_buffer = NULL;
8420024c:	30 ae       	M[r4 + 64] = Null;
        if (opx_data->pack_latency_buffer)
8420024e:	70 b9       	Null = M[r4 + 116];
84200250:	11 60       	if EQ jump (m) Lc_rtp_decode_disconnect_9;

84200252 <Lc_rtp_decode_disconnect_8>:
        {
            /* Destroy the internal buffer */
            cbuffer_destroy(opx_data->u.pack.internal_buffer);
84200252:	f2 a8       	r0 = M[r4 + 76];
84200254:	ff fd 92 f0 	call (m) 0x12802;
84200258:	2f ed 
            opx_data->u.pack.internal_buffer = NULL;
8420025a:	f0 ae       	M[r4 + 76] = Null;

            /* Only destroy the buffer struct, the buffer be freed with opx_data->u.pack.frame_buffer */
            cbuffer_destroy_struct(opx_data->u.pack.clone_frame_buffer);
8420025c:	72 a8       	r0 = M[r4 + 68];
8420025e:	ff fd 92 f0 	call (m) 0x12834;
84200262:	37 ee 
            opx_data->u.pack.clone_frame_buffer = NULL;
84200264:	70 ae       	M[r4 + 68] = Null;

            cbuffer_destroy(opx_data->u.pack.frame_buffer);
84200266:	b2 a8       	r0 = M[r4 + 72];
84200268:	ff fd 92 f0 	call (m) 0x12802;
8420026c:	3b ec 
            opx_data->u.pack.frame_buffer = NULL;
8420026e:	b0 ae       	M[r4 + 72] = Null;
84200270:	06 6e       	jump (m) Lc_rtp_decode_disconnect_10;

84200272 <Lc_rtp_decode_disconnect_9>:
        }
        else
        {
            cbuffer_destroy_struct(opx_data->u.clone_op_buffer);
84200272:	72 a8       	r0 = M[r4 + 68];
84200274:	ff fd 92 f0 	call (m) 0x12834;
84200278:	21 ee 
            opx_data->u.clone_op_buffer = NULL;
8420027a:	70 ae       	M[r4 + 68] = Null;

8420027c <Lc_rtp_decode_disconnect_10>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
8420027c:	42 20       	r0 = Null + 1;

8420027e <Lc_rtp_decode_disconnect_11>:
            opx_data->u.clone_op_buffer = NULL;
        }
    }

    return TRUE;
}
8420027e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200280:	d8 4c       	rts;

84200282 <$_rtp_decode_buffer_details>:


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200282:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200284:	11 09       	r7 = r0 + Null;
84200286:	18 09       	r6 = r1 + Null;
84200288:	22 09       	r8 = r2 + Null;
8420028a:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420028c:	09 f0 37 e4 	call (m) $_base_op_get_instance_data;
84200290:	17 00       	r5 = r0 + Null;


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned *)message_data)[0];
84200292:	8b f0 00 e8 	r9 = M[r6 + Null];

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200296:	35 00       	r3 = r4 + Null;
84200298:	54 08       	r2 = r8 + Null;
8420029a:	43 08       	r1 = r6 + Null;
8420029c:	4a 08       	r0 = r7 + Null;
8420029e:	ef fd ff ff 	call (m) 0xbe;
842002a2:	21 e1 
842002a4:	10 04       	Null = r0 - Null;
842002a6:	03 62       	if NE jump (m) Lc_rtp_decode_buffer_details_3;

842002a8 <Lc_rtp_decode_buffer_details_2>:
    {
        return FALSE;
842002a8:	02 00       	r0 = Null + Null;
842002aa:	25 6e       	jump (m) Lc_rtp_decode_buffer_details_10;

842002ac <Lc_rtp_decode_buffer_details_3>:
    }

    /* RTP does not reuse any of its metadata on other channels. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->metadata_buffer = NULL;
842002ac:	31 e8       	rMAC = M[r4 + Null];
842002ae:	c8 8e       	M[rMAC + 12] = Null;

    /* Metadata on the output buffer is only present if the capability decodes the RTP
     * header but the working mode config message could arrive after the connect. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->supports_metadata = TRUE;
842002b0:	31 e8       	rMAC = M[r4 + Null];
842002b2:	09 22       	rMAC = rMAC + 8;
842002b4:	0a e2       	r0 = MBU[rMAC + Null];
842002b6:	22 ff ef 1f 	r0 = r0 AND 0xffffffef;
842002ba:	d2 c9       	r0 = r0 OR 0x10;
842002bc:	0a ea       	MB[rMAC + Null] = r0;

    /* If the data is packed internaly, use the default output buffer size. */
    if ((!opx_data->pack_latency_buffer)&&((terminal_id & TERMINAL_SINK_MASK) == 0))
842002be:	78 b9       	Null = M[r5 + 116];
842002c0:	09 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

842002c2 <Lc_rtp_decode_buffer_details_4>:
842002c2:	40 f0 b1 f0 	rMAC = r9 AND 0x800000;
842002c6:	00 00 
842002c8:	05 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

842002ca <Lc_rtp_decode_buffer_details_5>:
    {
        /* Output, use the latency buffer size */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = opx_data->latency_buffer_size;
842002ca:	79 a9       	rMAC = M[r5 + 84];
842002cc:	32 e8       	r0 = M[r4 + Null];
842002ce:	11 8f       	M[r0 + 16] = rMAC;
842002d0:	05 6e       	jump (m) Lc_rtp_decode_buffer_details_7;

842002d2 <Lc_rtp_decode_buffer_details_6>:
    }
    else
    {
        /* Default buffer size for input terminal */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
842002d2:	01 f0 00 42 	rMAC = Null + 512;
842002d6:	32 e8       	r0 = M[r4 + Null];
842002d8:	11 8f       	M[r0 + 16] = rMAC;

842002da <Lc_rtp_decode_buffer_details_7>:
    }

    L4_DBG_MSG1("rtp_decode_buffer_details  %d \n", ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size  );
842002da:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842002de:	08 25       	Null = rMAC - 4;
842002e0:	09 68       	if LT jump (m) Lc_rtp_decode_buffer_details_9;

842002e2 <Lc_rtp_decode_buffer_details_8>:
842002e2:	31 e8       	rMAC = M[r4 + Null];
842002e4:	0b 89       	r1 = M[rMAC + 16];
842002e6:	55 f1 02 f0 	r0 = Null + 357564885;
842002ea:	d5 41 
842002ec:	ff fd 03 f0 	call (m) 0x9b4;
842002f0:	29 e6 

842002f2 <Lc_rtp_decode_buffer_details_9>:

    return TRUE;
842002f2:	42 20       	r0 = Null + 1;

842002f4 <Lc_rtp_decode_buffer_details_10>:
}
842002f4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842002f6:	d8 4c       	rts;

842002f8 <$_rtp_decode_get_sched_info>:


bool rtp_decode_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002f8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842002fa:	17 00       	r5 = r0 + Null;
842002fc:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
842002fe:	08 f0 39 ee 	call (m) $_base_op_get_sched_info_ex;
    if (resp == NULL)
84200302:	10 04       	Null = r0 - Null;
84200304:	08 62       	if NE jump (m) Lc_rtp_decode_get_sched_info_3;

84200306 <Lc_rtp_decode_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200306:	03 f0 00 60 	r1 = Null + 4096;
8420030a:	34 00       	r2 = r4 + Null;
8420030c:	3a 00       	r0 = r5 + Null;
8420030e:	08 f0 29 ef 	call (m) $_base_op_build_std_response_ex;
84200312:	05 6e       	jump (m) Lc_rtp_decode_get_sched_info_4;

84200314 <Lc_rtp_decode_get_sched_info_3>:
    }
    *response_data = resp;
84200314:	32 ee       	M[r4 + Null] = r0;

    /* Same buffer size for sink and source.
       No additional verification needed.*/
    resp->block_size = RTP_DECODE_DEFAULT_BLOCK_SIZE;
84200316:	41 20       	rMAC = Null + 1;
84200318:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
8420031a:	0a 00       	r0 = rMAC + Null;

8420031c <Lc_rtp_decode_get_sched_info_4>:
}
8420031c:	f2 48       	popm <FP, r4, r5, rLink>;
8420031e:	d8 4c       	rts;

84200320 <$_rtp_decode_get_data_format>:


bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200320:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200322:	10 09       	r6 = r0 + Null;
84200324:	1a 09       	r8 = r1 + Null;
84200326:	21 09       	r7 = r2 + Null;
84200328:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420032a:	08 f0 39 ef 	call (m) $_base_op_get_instance_data;
8420032e:	17 00       	r5 = r0 + Null;

bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if (!base_op_get_data_format(op_data, message_data, response_id, response_data))
84200330:	35 00       	r3 = r4 + Null;
84200332:	4c 08       	r2 = r7 + Null;
84200334:	53 08       	r1 = r8 + Null;
84200336:	42 08       	r0 = r6 + Null;
84200338:	ef fd ff ff 	call (m) 0x17a;
8420033c:	23 e2 
8420033e:	10 04       	Null = r0 - Null;
84200340:	03 62       	if NE jump (m) Lc_rtp_decode_get_data_format_3;

84200342 <Lc_rtp_decode_get_data_format_2>:
    {
        return FALSE;
84200342:	02 00       	r0 = Null + Null;
84200344:	0f 6e       	jump (m) Lc_rtp_decode_get_data_format_7;

84200346 <Lc_rtp_decode_get_data_format_3>:
    }

    /* return the terminal's data format - purely based on terminal data direction flag */
    if((((unsigned*)message_data)[0] & TERMINAL_SINK_MASK) == 0)
84200346:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420034a:	40 f0 11 f0 	rMAC = rMAC AND 0x800000;
8420034e:	00 00 
84200350:	05 62       	if NE jump (m) Lc_rtp_decode_get_data_format_5;

84200352 <Lc_rtp_decode_get_data_format_4>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->op_format;
84200352:	79 88       	rMAC = M[r5 + 4];
84200354:	32 e8       	r0 = M[r4 + Null];
84200356:	91 8e       	M[r0 + 8] = rMAC;
84200358:	04 6e       	jump (m) Lc_rtp_decode_get_data_format_6;

8420035a <Lc_rtp_decode_get_data_format_5>:
    }
    else
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->ip_format;
8420035a:	39 e8       	rMAC = M[r5 + Null];
8420035c:	32 e8       	r0 = M[r4 + Null];
8420035e:	91 8e       	M[r0 + 8] = rMAC;

84200360 <Lc_rtp_decode_get_data_format_6>:
    }

    return TRUE;
84200360:	42 20       	r0 = Null + 1;

84200362 <Lc_rtp_decode_get_data_format_7>:
}
84200362:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200364:	d8 4c       	rts;

84200366 <$_rtp_decode_opmsg_set_working_mode>:

/* **************************** Operator message handlers ******************************** */


bool rtp_decode_opmsg_set_working_mode(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200366:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200368:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420036a:	08 f0 39 ed 	call (m) $_base_op_get_instance_data;
8420036e:	16 00       	r4 = r0 + Null;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_WORKING_MODES wm;

    wm = (RTP_WORKING_MODES) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_WORKING_MODE, WORKING_MODE);
84200370:	f9 88       	rMAC = M[r5 + 12];
84200372:	89 c6       	rMAC = rMAC AND 0xffff;
84200374:	0f 08       	r5 = SE8 rMAC;

    if (wm >= RTP_NR_OF_MODES)
84200376:	38 25       	Null = r5 - 4;
84200378:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_working_mode_3;

8420037a <Lc_rtp_decode_opmsg_set_working_mode_2>:
    {
        return FALSE;
8420037a:	02 00       	r0 = Null + Null;
8420037c:	19 6e       	jump (m) Lc_rtp_decode_opmsg_set_working_mode_9;

8420037e <Lc_rtp_decode_opmsg_set_working_mode_3>:
    }

    /* Check a new time to play instance is needed. */
    if ((wm == RTP_DECODE)||(wm == RTP_TTP_ONLY))
8420037e:	78 24       	Null = r5 - 1;
84200380:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_5;

84200382 <Lc_rtp_decode_opmsg_set_working_mode_4>:
84200382:	f8 24       	Null = r5 - 3;
84200384:	13 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

84200386 <Lc_rtp_decode_opmsg_set_working_mode_5>:
    {
        if (opx_data->ttp_instance == NULL)
84200386:	31 a9       	rMAC = M[r4 + 80];
84200388:	11 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

8420038a <Lc_rtp_decode_opmsg_set_working_mode_6>:
        {
            ttp_params params;

            /* Create a new ttp instance*/
            opx_data->ttp_instance = ttp_init();
8420038a:	ff fd b1 f0 	call (m) 0x16698;
8420038e:	2f e8 
84200390:	32 af       	M[r4 + 80] = r0;
            if (opx_data->ttp_instance == NULL)
84200392:	31 a9       	rMAC = M[r4 + 80];
84200394:	f3 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_2;

84200396 <Lc_rtp_decode_opmsg_set_working_mode_7>:
            {
                return FALSE;
            }

            ttp_get_default_params(&params, TTP_TYPE_A2DP);
84200396:	83 20       	r1 = Null + 2;
84200398:	02 11       	r0 = FP + 16;
8420039a:	ff fd b1 f0 	call (m) 0x166de;
8420039e:	25 ea 
            ttp_configure_params(opx_data->ttp_instance, &params);
842003a0:	03 11       	r1 = FP + 16;
842003a2:	32 a9       	r0 = M[r4 + 80];
842003a4:	ff fd b2 f0 	call (m) 0x16822;
842003a8:	3f e3 

842003aa <Lc_rtp_decode_opmsg_set_working_mode_8>:
        }
    }

    opx_data->mode = wm;
842003aa:	37 9a       	MB[r4 + 8] = r5;

    return TRUE;
842003ac:	42 20       	r0 = Null + 1;

842003ae <Lc_rtp_decode_opmsg_set_working_mode_9>:
}
842003ae:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842003b0:	d8 4c       	rts;

842003b2 <$_rtp_decode_opmsg_set_codec_type>:


bool rtp_decode_opmsg_set_codec_type(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003b2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842003b4:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003b6:	08 f0 2d eb 	call (m) $_base_op_get_instance_data;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_CODEC_TYPE codec_type;

    codec_type = (RTP_CODEC_TYPE) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_CODEC_TYPE, CODEC_TYPE);
842003ba:	f1 88       	rMAC = M[r4 + 12];
842003bc:	89 c6       	rMAC = rMAC AND 0xffff;
842003be:	09 08       	rMAC = SE8 rMAC;

    if (codec_type >= NR_OF_CODECS)
842003c0:	c8 25       	Null = rMAC - 7;
842003c2:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_codec_type_3;

842003c4 <Lc_rtp_decode_opmsg_set_codec_type_2>:
    {
        return FALSE;
842003c4:	02 00       	r0 = Null + Null;
842003c6:	05 6e       	jump (m) Lc_rtp_decode_opmsg_set_codec_type_4;

842003c8 <Lc_rtp_decode_opmsg_set_codec_type_3>:
    }

    opx_data->codec_type = codec_type;
842003c8:	51 aa       	MB[r0 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
842003ca:	02 f0 3f ec 	call (m) Lc_rtp_set_payload_header_size_1;

    return TRUE;
842003ce:	42 20       	r0 = Null + 1;

842003d0 <Lc_rtp_decode_opmsg_set_codec_type_4>:
}
842003d0:	f1 48       	popm <FP, r4, rLink>;
842003d2:	d8 4c       	rts;

842003d4 <$_rtp_decode_opmsg_set_content_protection>:


bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003d4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842003d6:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003d8:	08 f0 2b ea 	call (m) $_base_op_get_instance_data;
bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->scms_enable = OPMSG_FIELD_GET(message_data,
                             OPMSG_RTP_SET_CONTENT_PROTECTION, CONTENT_PROTECTION_ENABLED) & 1;
842003dc:	11 a2       	rMAC = MBU[r0 + 16];
842003de:	f3 88       	r1 = M[r4 + 12];
842003e0:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;
842003e4:	1b c0       	r1 = r1 AND 0x1;
842003e6:	c9 12       	rMAC = rMAC OR r1;
842003e8:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
842003ea:	42 20       	r0 = Null + 1;

842003ec <Lc_rtp_decode_opmsg_set_content_protection_2>:
}
842003ec:	f1 48       	popm <FP, r4, rLink>;
842003ee:	d8 4c       	rts;

842003f0 <$_rtp_decode_opmsg_set_AAC_decoder>:
    }
    return NULL;
}

bool rtp_decode_opmsg_set_AAC_decoder(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003f0:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842003f2:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003f4:	08 f0 2f e9 	call (m) $_base_op_get_instance_data;
842003f8:	17 00       	r5 = r0 + Null;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned aac_operator_id;
    void *aac_codec;

    aac_operator_id = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_AAC_CODEC, OPERATOR_ID);
842003fa:	f1 88       	rMAC = M[r4 + 12];
842003fc:	8a c6       	r0 = rMAC AND 0xffff;

    aac_codec = get_AAC_codec(aac_operator_id);
842003fe:	06 f0 3d e8 	call (m) Lc_get_AAC_codec_1;
    if (aac_codec != NULL)
84200402:	10 04       	Null = r0 - Null;
84200404:	04 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_AAC_decoder_3;

84200406 <Lc_rtp_decode_opmsg_set_AAC_decoder_2>:
    {
        opx_data->aac_codec = aac_codec;
84200406:	7a 8f       	M[r5 + 20] = r0;
        return TRUE;
84200408:	42 20       	r0 = Null + 1;
8420040a:	02 6e       	jump (m) Lc_rtp_decode_opmsg_set_AAC_decoder_4;

8420040c <Lc_rtp_decode_opmsg_set_AAC_decoder_3>:
    }
    /* Operator not found, signal an error back. */
    return FALSE;
8420040c:	02 00       	r0 = Null + Null;

8420040e <Lc_rtp_decode_opmsg_set_AAC_decoder_4>:
}
8420040e:	f2 48       	popm <FP, r4, r5, rLink>;
84200410:	d8 4c       	rts;

84200412 <$_rtp_decode_opmsg_set_AAC_utility>:

bool rtp_decode_opmsg_set_AAC_utility(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200412:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200414:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200416:	08 f0 2d e8 	call (m) $_base_op_get_instance_data;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    AAC_UTILITY_SEL utility_selector;

    utility_selector = (AAC_UTILITY_SEL) OPMSG_FIELD_GET(message_data,
                        OPMSG_RTP_SET_AAC_UTILITY, UTILITY_SEL);
8420041a:	f1 88       	rMAC = M[r4 + 12];
8420041c:	89 c6       	rMAC = rMAC AND 0xffff;

    if ((utility_selector == AAC_LC_OVER_LATM)||(utility_selector == AAC_GENERIC))
8420041e:	09 08       	rMAC = SE8 rMAC;
84200420:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_3;

84200422 <Lc_rtp_decode_opmsg_set_AAC_utility_2>:
84200422:	48 24       	Null = rMAC - 1;
84200424:	04 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_4;

84200426 <Lc_rtp_decode_opmsg_set_AAC_utility_3>:
    {
        opx_data->aac_utility_select = utility_selector;
84200426:	11 ba       	MB[r0 + 24] = rMAC;
        return TRUE;
84200428:	42 20       	r0 = Null + 1;
8420042a:	02 6e       	jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_5;

8420042c <Lc_rtp_decode_opmsg_set_AAC_utility_4>:
    }
    /* Operator not found, signal an error back. */
    return FALSE;
8420042c:	02 00       	r0 = Null + Null;

8420042e <Lc_rtp_decode_opmsg_set_AAC_utility_5>:
}
8420042e:	f1 48       	popm <FP, r4, rLink>;
84200430:	d8 4c       	rts;

84200432 <$_rtp_decode_opmsg_set_max_packet_length>:

    return TRUE;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200432:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200434:	17 00       	r5 = r0 + Null;
84200436:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200438:	08 f0 2b e7 	call (m) $_base_op_get_instance_data;
8420043c:	10 09       	r6 = r0 + Null;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    if (opmgr_op_is_running(op_data))
8420043e:	3a 00       	r0 = r5 + Null;
84200440:	08 f0 2b e4 	call (m) $_opmgr_op_is_running;
84200444:	10 04       	Null = r0 - Null;
84200446:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_3;

84200448 <Lc_rtp_decode_opmsg_set_max_packet_length_2>:
    {
        return FALSE;
84200448:	02 00       	r0 = Null + Null;
8420044a:	08 6e       	jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_4;

8420044c <Lc_rtp_decode_opmsg_set_max_packet_length_3>:
    }
    else
    {
        opx_data->max_packet_len = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_MAX_PACKET_LENGTH, LENGTH);
8420044c:	f1 88       	rMAC = M[r4 + 12];
8420044e:	89 c6       	rMAC = rMAC AND 0xffff;
84200450:	81 f0 17 8e 	M[r6 + 92] = rMAC;
        opx_data->last_op_tag_octets = opx_data->max_packet_len;
84200454:	81 f0 1a 8e 	M[r6 + 104] = rMAC;
        return TRUE;
84200458:	42 20       	r0 = Null + 1;

8420045a <Lc_rtp_decode_opmsg_set_max_packet_length_4>:
    }
}
8420045a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420045c:	d8 4c       	rts;

8420045e <$_rtp_decode_opmsg_set_src_latency_mapping>:
bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420045e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200460:	17 00       	r5 = r0 + Null;
84200462:	18 09       	r6 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200464:	08 f0 3f e5 	call (m) $_base_op_get_instance_data;
84200468:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_SRC_LATENCY_MAP *src_latency_map;
    unsigned count, num_entries, alloc_size;
    if (opmgr_op_is_running(op_data))
8420046a:	3a 00       	r0 = r5 + Null;
8420046c:	08 f0 3f e2 	call (m) $_opmgr_op_is_running;
84200470:	10 04       	Null = r0 - Null;
84200472:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_3;

84200474 <Lc_rtp_decode_opmsg_set_src_latency_mapping_2>:
    {
        return FALSE;
84200474:	02 00       	r0 = Null + Null;
84200476:	2f 6e       	jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_9;

84200478 <Lc_rtp_decode_opmsg_set_src_latency_mapping_3>:
    }
    num_entries = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, COUNT);
84200478:	81 f0 03 88 	rMAC = M[r6 + 12];
8420047c:	8f c6       	r5 = rMAC AND 0xffff;
    alloc_size = sizeof(RTP_SRC_LATENCY_MAP) + num_entries * sizeof(RTP_SRC_LATENCY_MAP_ENTRY);
8420047e:	ba 54       	r0 = r5 LSHIFT 3;
84200480:	12 21       	r0 = r0 + 4;
    src_latency_map = (RTP_SRC_LATENCY_MAP *)xpmalloc(alloc_size);
84200482:	c3 20       	r1 = Null + 3;
84200484:	ff fd 24 f0 	call (m) 0x4e2e;
84200488:	2b ed 
8420048a:	11 09       	r7 = r0 + Null;
    if (src_latency_map == NULL)
8420048c:	f4 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_2;

8420048e <Lc_rtp_decode_opmsg_set_src_latency_mapping_4>:
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
8420048e:	97 f0 00 ee 	M[r7 + Null] = r5;
    for (count = 0; count < num_entries; count++)
84200492:	03 00       	r1 = Null + Null;
84200494:	91 f0 04 20 	rMAC = r7 + 4;
84200498:	82 f0 10 20 	r0 = r6 + 16;
8420049c:	d8 05       	Null = r1 - r5;
8420049e:	02 f0 a9 e0 	if C jump (m) Lc__loop0;

842004a2 <Lc_rtp_decode_opmsg_set_src_latency_mapping_5>:
842004a2:	3c 09       	r10 = r5 + Null;
842004a4:	11 4c       	do (m) Lc__loop0;

842004a6 <Lc_rtp_decode_opmsg_set_src_latency_mapping_6>:
    {
        src_latency_map->entries[count].source_id =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 1);
842004a6:	13 e8       	r1 = M[r0 + Null];
842004a8:	54 88       	r2 = M[r0 + 4];
842004aa:	9b c6       	r1 = r1 AND 0xffff;
842004ac:	a4 c6       	r2 = r2 AND 0xffff;
842004ae:	9b 56       	r1 = r1 LSHIFT 16;
842004b0:	e3 00       	r1 = r2 + r1;
842004b2:	0b ee       	M[rMAC + Null] = r1;
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
842004b4:	93 88       	r1 = M[r0 + 8];
842004b6:	d4 88       	r2 = M[r0 + 12];
842004b8:	9b c6       	r1 = r1 AND 0xffff;
842004ba:	a4 c6       	r2 = r2 AND 0xffff;
842004bc:	12 28       	r0 = r0 + 16;
842004be:	9b 56       	r1 = r1 LSHIFT 16;
842004c0:	e3 00       	r1 = r2 + r1;
842004c2:	4b 8e       	M[rMAC + 4] = r1;
842004c4:	09 22       	rMAC = rMAC + 8;

842004c6 <Lc__loop0>:
    if (src_latency_map == NULL)
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
    for (count = 0; count < num_entries; count++)
842004c6:	32 b9       	r0 = M[r4 + 112];
842004c8:	ff fd 25 f0 	call (m) 0x4f62;
842004cc:	3b e4 
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
    }
    pfree(opx_data->src_latency_map);
    opx_data->src_latency_map = src_latency_map;
842004ce:	69 f0 1c 8e 	M[r4 + 112] = r7;
    return TRUE;
842004d2:	42 20       	r0 = Null + 1;

842004d4 <Lc_rtp_decode_opmsg_set_src_latency_mapping_9>:
}
842004d4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842004d6:	d8 4c       	rts;

842004d8 <$_rtp_decode_opmsg_set_packing>:


bool rtp_decode_opmsg_set_packing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004d8:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842004da:	17 00       	r5 = r0 + Null;
842004dc:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842004de:	08 f0 25 e2 	call (m) $_base_op_get_instance_data;
842004e2:	10 09       	r6 = r0 + Null;
    L2_DBG_MSG("rtp_decode_opmsg_set_packing: DATAFORMAT_32 is enabled, there is no need to pack");
    return TRUE;
#else
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned packing;
    if (opmgr_op_is_running(op_data))
842004e4:	3a 00       	r0 = r5 + Null;
842004e6:	07 f0 25 ef 	call (m) $_opmgr_op_is_running;
842004ea:	10 04       	Null = r0 - Null;
842004ec:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_packing_3;

842004ee <Lc_rtp_decode_opmsg_set_packing_2>:
    {
        return FALSE;
842004ee:	02 00       	r0 = Null + Null;
842004f0:	09 6e       	jump (m) Lc_rtp_decode_opmsg_set_packing_4;

842004f2 <Lc_rtp_decode_opmsg_set_packing_3>:
    }
    else
    {
        packing = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_PACKING, PACKING);
842004f2:	f1 88       	rMAC = M[r4 + 12];
        if (packing != 0)
        {
            opx_data->pack_latency_buffer = TRUE;
842004f4:	02 00       	r0 = Null + Null;
842004f6:	89 c6       	rMAC = rMAC AND 0xffff;
842004f8:	21 f0 42 ce 	if NE r0 = Null + 1;
842004fc:	82 f0 1d 8e 	M[r6 + 116] = r0;
        }
        else
        {
            opx_data->pack_latency_buffer = FALSE;
        }
        return TRUE;
84200500:	42 20       	r0 = Null + 1;

84200502 <Lc_rtp_decode_opmsg_set_packing_4>:
    }
#endif
}
84200502:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200504:	d8 4c       	rts;

84200506 <$_rtp_decode_opmsg_set_ttp_latency>:
    /* Operator not found, signal an error back. */
    return FALSE;
}

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200506:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200508:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420050a:	08 f0 39 e0 	call (m) $_base_op_get_instance_data;
8420050e:	17 00       	r5 = r0 + Null;

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200510:	39 90       	rMAC = MBS[r5 + 8];
84200512:	48 24       	Null = rMAC - 1;
84200514:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

84200516 <Lc_rtp_decode_opmsg_set_ttp_latency_2>:
84200516:	c8 24       	Null = rMAC - 3;
84200518:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

8420051a <Lc_rtp_decode_opmsg_set_ttp_latency_3>:
    {
        return FALSE;
8420051a:	02 00       	r0 = Null + Null;
8420051c:	0b 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_5;

8420051e <Lc_rtp_decode_opmsg_set_ttp_latency_4>:
    }

    ttp_configure_latency(opx_data->ttp_instance, ttp_get_msg_latency(message_data));
8420051e:	32 00       	r0 = r4 + Null;
84200520:	ff fd b0 f0 	call (m) 0x16706;
84200524:	27 ef 
84200526:	13 00       	r1 = r0 + Null;
84200528:	3a a9       	r0 = M[r5 + 80];
8420052a:	ff fd b1 f0 	call (m) 0x167da;
8420052e:	31 e5 
    return TRUE;
84200530:	42 20       	r0 = Null + 1;

84200532 <Lc_rtp_decode_opmsg_set_ttp_latency_5>:
}
84200532:	f2 48       	popm <FP, r4, r5, rLink>;
84200534:	d8 4c       	rts;

84200536 <$_rtp_decode_opmsg_set_latency_limits>:

bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200536:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200538:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420053a:	07 f0 29 ef 	call (m) $_base_op_get_instance_data;
8420053e:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200540:	31 90       	rMAC = MBS[r4 + 8];
84200542:	48 24       	Null = rMAC - 1;
84200544:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

84200546 <Lc_rtp_decode_opmsg_set_latency_limits_2>:
84200546:	c8 24       	Null = rMAC - 3;
84200548:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

8420054a <Lc_rtp_decode_opmsg_set_latency_limits_3>:
    {
        return FALSE;
8420054a:	02 00       	r0 = Null + Null;
8420054c:	0e 6e       	jump (m) Lc_rtp_decode_opmsg_set_latency_limits_5;

8420054e <Lc_rtp_decode_opmsg_set_latency_limits_4>:
    }
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
8420054e:	44 11       	r2 = FP + 20;
84200550:	03 11       	r1 = FP + 16;
84200552:	3a 00       	r0 = r5 + Null;
84200554:	ff fd b0 f0 	call (m) 0x1673c;
84200558:	29 ef 
    ttp_configure_latency_limits(opx_data->ttp_instance, min_latency, max_latency);
8420055a:	2c d8       	r2 = M[FP + 20];
8420055c:	23 d8       	r1 = M[FP + 16];
8420055e:	32 a9       	r0 = M[r4 + 80];
84200560:	ff fd b1 f0 	call (m) 0x167fa;
84200564:	3b e4 

    return TRUE;
84200566:	42 20       	r0 = Null + 1;

84200568 <Lc_rtp_decode_opmsg_set_latency_limits_5>:
}
84200568:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420056a:	d8 4c       	rts;

8420056c <$_rtp_decode_opmsg_set_ttp_params>:

bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420056c:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420056e:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200570:	07 f0 33 ed 	call (m) $_base_op_get_instance_data;
84200574:	17 00       	r5 = r0 + Null;
bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    ttp_params params;

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200576:	39 90       	rMAC = MBS[r5 + 8];
84200578:	48 24       	Null = rMAC - 1;
8420057a:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

8420057c <Lc_rtp_decode_opmsg_set_ttp_params_2>:
8420057c:	c8 24       	Null = rMAC - 3;
8420057e:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

84200580 <Lc_rtp_decode_opmsg_set_ttp_params_3>:
    {
        return FALSE;
84200580:	02 00       	r0 = Null + Null;
84200582:	0c 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_params_5;

84200584 <Lc_rtp_decode_opmsg_set_ttp_params_4>:
    }

    ttp_get_msg_params(&params, message_data);
84200584:	02 11       	r0 = FP + 16;
84200586:	33 00       	r1 = r4 + Null;
84200588:	ff fd b0 f0 	call (m) 0x16786;
8420058c:	3f ef 
    ttp_configure_params(opx_data->ttp_instance, &params);
8420058e:	03 11       	r1 = FP + 16;
84200590:	3a a9       	r0 = M[r5 + 80];
84200592:	ff fd b1 f0 	call (m) 0x16822;
84200596:	31 e4 

    return TRUE;
84200598:	42 20       	r0 = Null + 1;

8420059a <Lc_rtp_decode_opmsg_set_ttp_params_5>:
}
8420059a:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420059c:	d8 4c       	rts;

8420059e <$_rtp_decode_opmsg_set_sample_rate>:


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420059e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005a0:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005a2:	07 f0 21 ec 	call (m) $_base_op_get_instance_data;


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned sample_rate = 25 * OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE);
842005a6:	f1 88       	rMAC = M[r4 + 12];
842005a8:	89 c6       	rMAC = rMAC AND 0xffff;
842005aa:	4b 46       	r1 = rMAC * 25 (int);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
842005ac:	11 90       	rMAC = MBS[r0 + 8];
842005ae:	48 24       	Null = rMAC - 1;
842005b0:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

842005b2 <Lc_rtp_decode_opmsg_set_sample_rate_2>:
842005b2:	c8 24       	Null = rMAC - 3;
842005b4:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

842005b6 <Lc_rtp_decode_opmsg_set_sample_rate_3>:
    {
        return FALSE;
842005b6:	02 00       	r0 = Null + Null;
842005b8:	07 6e       	jump (m) Lc_rtp_decode_opmsg_set_sample_rate_5;

842005ba <Lc_rtp_decode_opmsg_set_sample_rate_4>:
    }

    opx_data->sample_rate = sample_rate;
842005ba:	93 af       	M[r0 + 88] = r1;
    ttp_configure_rate(opx_data->ttp_instance, sample_rate);
842005bc:	12 a9       	r0 = M[r0 + 80];
842005be:	ff fd b1 f0 	call (m) 0x1684c;
842005c2:	2f e4 

    return TRUE;
842005c4:	42 20       	r0 = Null + 1;

842005c6 <Lc_rtp_decode_opmsg_set_sample_rate_5>:
}
842005c6:	f1 48       	popm <FP, r4, rLink>;
842005c8:	d8 4c       	rts;

842005ca <$_rtp_decode_opmsg_set_buffer_size>:

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005ca:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005cc:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005ce:	07 f0 35 ea 	call (m) $_base_op_get_instance_data;
}

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    opx_data->latency_buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
842005d2:	f1 88       	rMAC = M[r4 + 12];
842005d4:	89 c6       	rMAC = rMAC AND 0xffff;
842005d6:	51 af       	M[r0 + 84] = rMAC;

    if (opx_data->latency_buffer_size > RTP_DECODE_DEFAULT_BUFFER_SIZE)
842005d8:	10 f0 00 26 	Null = rMAC - 512;
842005dc:	09 f0 89 e0 	if LS jump (m) Lc_rtp_decode_opmsg_set_buffer_size_3;

842005e0 <Lc_rtp_decode_opmsg_set_buffer_size_2>:
    {
        opx_data->kick_on_full_output = TRUE;
842005e0:	41 20       	rMAC = Null + 1;
842005e2:	d1 be       	M[r0 + 108] = rMAC;

842005e4 <Lc_rtp_decode_opmsg_set_buffer_size_3>:
    }

    return TRUE;
842005e4:	42 20       	r0 = Null + 1;

842005e6 <Lc_rtp_decode_opmsg_set_buffer_size_4>:
}
842005e6:	f1 48       	popm <FP, r4, rLink>;
842005e8:	d8 4c       	rts;

842005ea <$_rtp_decode_opmsg_set_latency_change_notification>:
    }
#endif
}

bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005ea:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005ec:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005ee:	07 f0 35 e9 	call (m) $_base_op_get_instance_data;
bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->latency_change_notify_enable = OPMSG_FIELD_GET(message_data,
                                             OPMSG_RTP_SET_LATENCY_CHANGE_NOTIFICATION, ENABLE_LATENCY_NOTIFY) & 1;
842005f2:	11 a2       	rMAC = MBU[r0 + 16];
842005f4:	f3 88       	r1 = M[r4 + 12];
842005f6:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
842005fa:	1b c0       	r1 = r1 AND 0x1;
842005fc:	1b 54       	r1 = r1 LSHIFT 1;
842005fe:	c9 12       	rMAC = rMAC OR r1;
84200600:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
84200602:	42 20       	r0 = Null + 1;

84200604 <Lc_rtp_decode_opmsg_set_latency_change_notification_2>:
}
84200604:	f1 48       	popm <FP, r4, rLink>;
84200606:	d8 4c       	rts;

84200608 <$_rtp_decode_process_data>:
    }
}


void rtp_decode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200608:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420060a:	54 4c       	SP = SP + 80;
8420060c:	42 de       	M[FP + 32] = r0;
8420060e:	4b de       	M[FP + 36] = r1;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200610:	07 f0 33 e8 	call (m) $_base_op_get_instance_data;
84200614:	10 09       	r6 = r0 + Null;
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    unsigned packet_size;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer *ip_buffer = opx_data->ip_buffer;
84200616:	8a f0 0f 88 	r8 = M[r6 + 60];
    tCbuffer *op_buffer = opx_data->op_buffer;
8420061a:	81 f0 10 88 	rMAC = M[r6 + 64];
8420061e:	51 de       	M[FP + 40] = rMAC;
    unsigned available_octets, available_space;
    unsigned rtp_header_size = RTP_MINIMUM_HEADER_SIZE +
                   (opx_data->scms_enable ? SCMS_HEADER_SIZE : 0);
84200620:	81 f0 10 82 	rMAC = MBU[r6 + 16];
84200624:	42 23       	r0 = Null + 13;
84200626:	03 23       	r1 = Null + 12;
84200628:	09 c0       	rMAC = rMAC AND 0x1;
8420062a:	01 f2 03 c0 	if NE r1 = r0 + Null;
8420062e:	5b de       	M[FP + 44] = r1;
    metadata_tag* tag;

    patch_fn(rtp_decode_process_data);

    if ((ip_buffer == NULL) || (op_buffer == NULL))
84200630:	0f fa 00 c2 	Null = r8 - Null;
84200634:	00 f0 af e6 	if EQ jump (m) Lc_rtp_decode_process_data_60;

84200638 <Lc_rtp_decode_process_data_2>:
84200638:	51 d8       	rMAC = M[FP + 40];
8420063a:	00 f0 a9 e6 	if EQ jump (m) Lc_rtp_decode_process_data_60;

8420063e <Lc_rtp_decode_process_data_3>:
    {
        return;
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
8420063e:	80 f0 1d 88 	Null = M[r6 + 116];
84200642:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_5;

84200644 <Lc_rtp_decode_process_data_4>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84200644:	81 f0 11 88 	rMAC = M[r6 + 68];
84200648:	61 de       	M[FP + 48] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
8420064a:	81 f0 12 88 	rMAC = M[r6 + 72];
8420064e:	69 de       	M[FP + 52] = rMAC;
84200650:	06 6e       	jump (m) Lc_rtp_decode_process_data_6;

84200652 <Lc_rtp_decode_process_data_5>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200652:	81 f0 11 88 	rMAC = M[r6 + 68];
84200656:	61 de       	M[FP + 48] = rMAC;
        buffer = opx_data->op_buffer;
84200658:	51 d8       	rMAC = M[FP + 40];
8420065a:	69 de       	M[FP + 52] = rMAC;

8420065c <Lc_rtp_decode_process_data_6>:
     */
    /* TODO There could be an octet difference between _ex (used by a2dp endpoint)
     * and cbuffer (used by octet_buffer therefore by RTP) when asking for available data.
     * To avoid that difference use the buff_metadata_available_octets until RTP is not
     * convert to _ex buffer. NOTE  _ex buffer does not support unaligned copy yet.  */
    available_octets = buff_metadata_available_octets(ip_buffer);
8420065c:	52 08       	r0 = r8 + Null;
8420065e:	ff fd 8b f0 	call (m) 0x11d04;
84200662:	27 e5 
84200664:	13 09       	r9 = r0 + Null;
    available_space = cbuffer_calc_amount_space_ex(op_buffer);
84200666:	52 d8       	r0 = M[FP + 40];
84200668:	08 f0 25 ec 	call (m) $_cbuffer_calc_amount_space_ex;
8420066c:	16 00       	r4 = r0 + Null;

    L4_DBG_MSG2("RTP START available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
8420066e:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200672:	08 25       	Null = rMAC - 4;
84200674:	10 68       	if LT jump (m) Lc_rtp_decode_process_data_8;

84200676 <Lc_rtp_decode_process_data_7>:
84200676:	52 08       	r0 = r8 + Null;
84200678:	08 f0 25 e9 	call (m) $_cbuffer_calc_amount_data_ex;
8420067c:	17 00       	r5 = r0 + Null;
8420067e:	52 d8       	r0 = M[FP + 40];
84200680:	08 f0 2d eb 	call (m) $_cbuffer_calc_amount_space_ex;
84200684:	14 00       	r2 = r0 + Null;
84200686:	55 f1 02 f0 	r0 = Null + 357565082;
8420068a:	9a 42 
8420068c:	3b 00       	r1 = r5 + Null;
8420068e:	ff fd 01 f0 	call (m) 0x9c8;
84200692:	3b e9 

84200694 <Lc_rtp_decode_process_data_8>:

    if (opx_data->kick_on_full_output && (available_octets > available_space))
84200694:	80 f0 1b 88 	Null = M[r6 + 108];
84200698:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_11;

8420069a <Lc_rtp_decode_process_data_9>:
8420069a:	6f fb 00 c2 	Null = r9 - r4;
8420069e:	09 f0 8b e0 	if LS jump (m) Lc_rtp_decode_process_data_11;

842006a2 <Lc_rtp_decode_process_data_10>:
    {
        /* Kick forwards to keep data flowing in case the next operator is a splitter */
        touched->sources = TOUCHED_SOURCE_0;
842006a2:	41 20       	rMAC = Null + 1;
842006a4:	4a d8       	r0 = M[FP + 36];
842006a6:	11 ee       	M[r0 + Null] = rMAC;

842006a8 <Lc_rtp_decode_process_data_11>:
    }

    if(opx_data->mode == RTP_PASSTHROUGH)
842006a8:	81 f0 08 80 	rMAC = MBS[r6 + 8];
842006ac:	1c 62       	if NE jump (m) Lc_rtp_decode_process_data_16;

842006ae <Lc_rtp_decode_process_data_12>:
    {
        unsigned octets_copied = cbuffer_copy_ex(op_buffer, ip_buffer, available_octets);
842006ae:	5c 08       	r2 = r9 + Null;
842006b0:	53 08       	r1 = r8 + Null;
842006b2:	52 d8       	r0 = M[FP + 40];
842006b4:	06 f0 25 e8 	call (m) $_cbuffer_copy_ex;

        /* copy as many data as possible to the output buffer.*/
        if (octets_copied > 0)
842006b8:	10 04       	Null = r0 - Null;
842006ba:	0a 60       	if EQ jump (m) Lc_rtp_decode_process_data_14;

842006bc <Lc_rtp_decode_process_data_13>:
        {
            /* Propagate any metadata to the output.*/
            metadata_strict_transport(ip_buffer, op_buffer, octets_copied);
842006bc:	14 00       	r2 = r0 + Null;
842006be:	52 08       	r0 = r8 + Null;
842006c0:	53 d8       	r1 = M[FP + 40];
842006c2:	ff fd 8c f0 	call (m) 0x12076;
842006c6:	35 ed 
            touched->sources = TOUCHED_SOURCE_0;
842006c8:	41 20       	rMAC = Null + 1;
842006ca:	4a d8       	r0 = M[FP + 36];
842006cc:	11 ee       	M[r0 + Null] = rMAC;

842006ce <Lc_rtp_decode_process_data_14>:
        }

        if (cbuffer_calc_amount_data_ex(ip_buffer) == 0)
842006ce:	52 08       	r0 = r8 + Null;
842006d0:	08 f0 2d e6 	call (m) $_cbuffer_calc_amount_data_ex;
842006d4:	10 04       	Null = r0 - Null;
842006d6:	01 f0 8d e5 	if NE jump (m) Lc_rtp_decode_process_data_60;

842006da <Lc_rtp_decode_process_data_15>:
        {
            touched->sinks = TOUCHED_SINK_0;
842006da:	41 20       	rMAC = Null + 1;
842006dc:	4a d8       	r0 = M[FP + 36];
842006de:	51 8e       	M[r0 + 4] = rMAC;
842006e0:	0f f0 83 e5 	jump (m) Lc_rtp_decode_process_data_60;

842006e4 <Lc_rtp_decode_process_data_16>:
        }
        return;
    }
    else if ((opx_data->mode == RTP_TTP_ONLY) && (opx_data->codec_type == APTX))
842006e4:	c8 24       	Null = rMAC - 3;
842006e6:	2e 62       	if NE jump (m) Lc_rtp_decode_process_data_26;

842006e8 <Lc_rtp_decode_process_data_17>:
842006e8:	81 f0 11 80 	rMAC = MBS[r6 + 17];
842006ec:	2b 62       	if NE jump (m) Lc_rtp_decode_process_data_26;

842006ee <Lc_rtp_decode_process_data_18>:
    {

        unsigned octets_copied = MIN(available_octets, available_space);
842006ee:	6f fb 00 c2 	Null = r9 - r4;
842006f2:	02 f0 89 e0 	if C jump (m) Lc_rtp_decode_process_data_20;

842006f6 <Lc_rtp_decode_process_data_19>:
842006f6:	5e 08       	r4 = r9 + Null;
842006f8:	01 6e       	jump (m) Lc_rtp_decode_process_data_20;

842006fa <Lc_rtp_decode_process_data_20>:
         * actually exists. It can only ever process 4 octets at a time,
         * so rounding down here should always be safe
         */
        octets_copied &= ~1;

        if (octets_copied > 0)
842006fa:	66 ff fe 1f 	r4 = r4 AND 0xfffffffe;
842006fe:	1b 60       	if EQ jump (m) Lc_rtp_decode_process_data_25;

84200700 <Lc_rtp_decode_process_data_22>:
        {
            metadata_transport_with_ttp(opx_data, octets_copied);
84200700:	33 00       	r1 = r4 + Null;
84200702:	42 08       	r0 = r6 + Null;
84200704:	04 f0 27 e6 	call (m) Lc_metadata_transport_with_ttp_1;
            if (opx_data->pack_latency_buffer)
84200708:	80 f0 1d 88 	Null = M[r6 + 116];
8420070c:	0c 60       	if EQ jump (m) Lc_rtp_decode_process_data_24;

8420070e <Lc_rtp_decode_process_data_23>:
            {
                /* Pack to internal buffer. */
                cbuffer_copy_ex(opx_data->u.pack.internal_buffer, ip_buffer, octets_copied);
8420070e:	82 f0 13 88 	r0 = M[r6 + 76];
84200712:	34 00       	r2 = r4 + Null;
84200714:	53 08       	r1 = r8 + Null;
84200716:	06 f0 23 e5 	call (m) $_cbuffer_copy_ex;
                /* Copy as much as possible to the output. */
                rtp_decode_empty_internal_buffers(opx_data,touched);
8420071a:	42 08       	r0 = r6 + Null;
8420071c:	4b d8       	r1 = M[FP + 36];
8420071e:	04 f0 2b ed 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
84200722:	09 6e       	jump (m) Lc_rtp_decode_process_data_25;

84200724 <Lc_rtp_decode_process_data_24>:
            }
            else
            {
                /* Copy to output. */
                cbuffer_copy_ex(op_buffer, ip_buffer, octets_copied);
84200724:	34 00       	r2 = r4 + Null;
84200726:	53 08       	r1 = r8 + Null;
84200728:	52 d8       	r0 = M[FP + 40];
8420072a:	06 f0 2f e4 	call (m) $_cbuffer_copy_ex;
                touched->sources = TOUCHED_SOURCE_0;
8420072e:	41 20       	rMAC = Null + 1;
84200730:	4a d8       	r0 = M[FP + 36];
84200732:	11 ee       	M[r0 + Null] = rMAC;

84200734 <Lc_rtp_decode_process_data_25>:
            }
        }

        /* Kick back if less than one whole word in the input buffer */
        if (cbuffer_calc_amount_data_ex(ip_buffer) < 2)
84200734:	52 08       	r0 = r8 + Null;
84200736:	08 f0 27 e3 	call (m) $_cbuffer_calc_amount_data_ex;
8420073a:	90 24       	Null = r0 - 2;
8420073c:	cf 65       	if NC jump (m) Lc_rtp_decode_process_data_15;

8420073e <Lc_18>:
8420073e:	0f f0 a5 e4 	jump (m) Lc_rtp_decode_process_data_60;

84200742 <Lc_rtp_decode_process_data_26>:
        }
        return;
    }

    /* Get the next from the input buffer.*/
    tag = buff_metadata_peek(ip_buffer);
84200742:	52 08       	r0 = r8 + Null;
84200744:	ff fd 8a f0 	call (m) 0x11cc6;
84200748:	23 ec 
8420074a:	16 00       	r4 = r0 + Null;
    packet_size = get_tag_size (tag);
8420074c:	02 f0 39 e0 	call (m) Lc_get_tag_size_1;
84200750:	17 00       	r5 = r0 + Null;

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);
84200752:	42 08       	r0 = r6 + Null;
84200754:	4b d8       	r1 = M[FP + 36];
84200756:	04 f0 33 eb 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
8420075a:	41 20       	rMAC = Null + 1;
8420075c:	71 de       	M[FP + 56] = rMAC;
8420075e:	41 6e       	jump (m) Lc_rtp_decode_process_data_34;

84200760 <Lc_rtp_decode_process_data_27>:
                        (opx_data->sample_rate/2)) / opx_data->sample_rate);
                }
#endif
                else
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, header_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
84200760:	33 25       	r1 = r4 - 4;
84200762:	52 08       	r0 = r8 + Null;
84200764:	08 f0 2f ed 	call (m) $_cbuffer_advance_read_ptr_ex;

84200768 <Lc_rtp_decode_process_data_28>:
                }

                /* Copy the payload without the padding to the clone buffer. There the
                 * decoded frame is analysed to see how many sample is in it.  */
                cbuffer_copy_ex(clone_buffer, ip_buffer, payload_size);
84200768:	4c 08       	r2 = r7 + Null;
8420076a:	53 08       	r1 = r8 + Null;
8420076c:	62 d8       	r0 = M[FP + 48];
8420076e:	06 f0 2b e2 	call (m) $_cbuffer_copy_ex;

                /* Partially decode the frame to get a robust sample count determination
                 * for the time to play. */
                get_samples_in_packet(opx_data, &frame_data);
84200772:	03 15       	r1 = FP + 80;
84200774:	42 08       	r0 = r6 + Null;
84200776:	04 f0 3b ee 	call (m) $_get_samples_in_packet;

                if(opx_data->mode == RTP_STRIP)
8420077a:	81 f0 08 80 	rMAC = MBS[r6 + 8];
8420077e:	88 24       	Null = rMAC - 2;
84200780:	ce 62       	if NE jump (m) Lc_rtp_decode_process_data_55;

84200782 <Lc_rtp_decode_process_data_29>:
                {
                    /* Make the data available in the frame buffer. */
                    cbuffer_advance_write_ptr_ex(buffer, payload_size);
84200782:	4b 08       	r1 = r7 + Null;
84200784:	6a d8       	r0 = M[FP + 52];
84200786:	08 f0 27 e9 	call (m) $_cbuffer_advance_write_ptr_ex;
                    /* Remove all the encoded data from the clone buffer. */
                    cbuffer_advance_read_ptr(clone_buffer, payload_size);
8420078a:	4b 08       	r1 = r7 + Null;
8420078c:	62 d8       	r0 = M[FP + 48];
8420078e:	ff fd 5d f1 	call (m) 0x2c216;
84200792:	29 e4 
                    /* Delete the tag as it is not used any more.  */
                    delete_consumed_metadata_tag(ip_buffer, packet_size);
84200794:	3b 00       	r1 = r5 + Null;
84200796:	52 08       	r0 = r8 + Null;
84200798:	01 f0 39 ee 	call (m) Lc_delete_consumed_metadata_tag_1;
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
8420079c:	05 00       	r3 = Null + Null;
8420079e:	03 00       	r1 = Null + Null;
842007a0:	4c 08       	r2 = r7 + Null;
842007a2:	6a d8       	r0 = M[FP + 52];
842007a4:	ff fd 89 f0 	call (m) 0x11adc;
842007a8:	39 e9 

842007aa <Lc_rtp_decode_process_data_30>:
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
842007aa:	72 d8       	r0 = M[FP + 56];
842007ac:	49 d8       	rMAC = M[FP + 36];
842007ae:	0a ee       	M[rMAC + Null] = r0;

842007b0 <Lc_rtp_decode_process_data_31>:
                        touched->sources = TOUCHED_SOURCE_0;
                    }
                }

#ifdef DEBUG_RTP_DECODE
                opx_data->rtp_decode_packet_count++;
842007b0:	81 f0 0c 88 	rMAC = M[r6 + 48];
842007b4:	49 20       	rMAC = rMAC + 1;
842007b6:	81 f0 0c 8e 	M[r6 + 48] = rMAC;
#endif
                /* discard any padding */
                if (padding_amount != 0)
842007ba:	7b d8       	r1 = M[FP + 60];
842007bc:	04 60       	if EQ jump (m) Lc_rtp_decode_process_data_33;

842007be <Lc_rtp_decode_process_data_32>:
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, padding_amount);
842007be:	52 08       	r0 = r8 + Null;
842007c0:	08 f0 33 ea 	call (m) $_cbuffer_advance_read_ptr_ex;

842007c4 <Lc_rtp_decode_process_data_33>:
                }

            }
        }
        available_octets -= packet_size;
842007c4:	00 f7 3b c2 	r9 = r9 - r5;

        /* unpack to output if possible. */
        rtp_decode_empty_internal_buffers(opx_data,touched);
842007c8:	42 08       	r0 = r6 + Null;
842007ca:	4b d8       	r1 = M[FP + 36];
842007cc:	04 f0 3d e7 	call (m) Lc_rtp_decode_empty_internal_buffers_1;

        /* Read the next packet tag. */
        tag = buff_metadata_peek(ip_buffer);
842007d0:	52 08       	r0 = r8 + Null;
842007d2:	ff fd 8a f0 	call (m) 0x11cc6;
842007d6:	35 e7 
842007d8:	16 00       	r4 = r0 + Null;
        packet_size = get_tag_size (tag);
842007da:	01 f0 2b ec 	call (m) Lc_get_tag_size_1;
842007de:	17 00       	r5 = r0 + Null;

842007e0 <Lc_rtp_decode_process_data_34>:
    packet_size = get_tag_size (tag);

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);

    while ( (packet_size != 0) && (available_octets >= packet_size))
842007e0:	38 04       	Null = r5 - Null;
842007e2:	aa 60       	if EQ jump (m) Lc_rtp_decode_process_data_58;

842007e4 <Lc_rtp_decode_process_data_35>:
842007e4:	7f fb 00 c2 	Null = r9 - r5;
842007e8:	a7 64       	if NC jump (m) Lc_rtp_decode_process_data_58;

842007ea <Lc_rtp_decode_process_data_36>:
    {
        if(!tag_valid(tag, opx_data))
842007ea:	43 08       	r1 = r6 + Null;
842007ec:	32 00       	r0 = r4 + Null;
842007ee:	01 f0 39 e8 	call (m) Lc_tag_valid_1;
842007f2:	10 04       	Null = r0 - Null;
842007f4:	b7 60       	if EQ jump (m) Lc_rtp_decode_process_data_60;

842007f6 <Lc_rtp_decode_process_data_37>:
        }
        /* Is there space in the sink for the unpacked data?
         * this needs to be a quick check and hence don't worry
         * about calculating the header size which isn't copied.
         */
        if ((cbuffer_calc_amount_space_ex(clone_buffer) - 4 ) < packet_size)
842007f6:	62 d8       	r0 = M[FP + 48];
842007f8:	07 f0 35 ef 	call (m) $_cbuffer_calc_amount_space_ex;
842007fc:	11 25       	rMAC = r0 - 4;
842007fe:	c8 05       	Null = rMAC - r5;
84200800:	02 f0 ad e0 	if C jump (m) Lc_rtp_decode_process_data_40;

84200804 <Lc_rtp_decode_process_data_38>:
        {
            L4_DBG_MSG2("RTP END  available data (octets) = %d, available space (octets) = %d !!output space smaller than packet size!!",
                    cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
84200804:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200808:	08 25       	Null = rMAC - 4;
8420080a:	ac 68       	if LT jump (m) Lc_rtp_decode_process_data_60;

8420080c <Lc_rtp_decode_process_data_39>:
8420080c:	52 08       	r0 = r8 + Null;
8420080e:	07 f0 2f ec 	call (m) $_cbuffer_calc_amount_data_ex;
84200812:	16 00       	r4 = r0 + Null;
84200814:	52 d8       	r0 = M[FP + 40];
84200816:	07 f0 37 ee 	call (m) $_cbuffer_calc_amount_space_ex;
8420081a:	14 00       	r2 = r0 + Null;
8420081c:	55 f1 02 f0 	r0 = Null + 357565152;
84200820:	e0 42 
84200822:	33 00       	r1 = r4 + Null;
84200824:	ff fd 00 f0 	call (m) 0x9c8;
84200828:	25 ed 
8420082a:	9c 6e       	jump (m) Lc_rtp_decode_process_data_60;

8420082c <Lc_rtp_decode_process_data_40>:
            return;
        }

        if (packet_size < (rtp_header_size +
                opx_data->payload_header_size))
8420082c:	81 f0 09 88 	rMAC = M[r6 + 36];
84200830:	5a d8       	r0 = M[FP + 44];
84200832:	51 00       	rMAC = r0 + rMAC;
84200834:	78 04       	Null = r5 - rMAC;
84200836:	02 f0 97 e0 	if C jump (m) Lc_rtp_decode_process_data_42;

8420083a <Lc_rtp_decode_process_data_41>:
        {
            /* packet is too small to contain header so discard it.*/
            cbuffer_advance_read_ptr_ex(ip_buffer, packet_size);
8420083a:	3b 00       	r1 = r5 + Null;
8420083c:	52 08       	r0 = r8 + Null;
8420083e:	08 f0 35 e6 	call (m) $_cbuffer_advance_read_ptr_ex;
            delete_consumed_metadata_tag(ip_buffer, packet_size);
84200842:	3b 00       	r1 = r5 + Null;
84200844:	52 08       	r0 = r8 + Null;
84200846:	01 f0 2b e9 	call (m) Lc_delete_consumed_metadata_tag_1;
8420084a:	bd 6f       	jump (m) Lc_rtp_decode_process_data_33;

8420084c <Lc_rtp_decode_process_data_42>:
        }
        else
        {
            unsigned int fixed_header_first_part[RTP_FIXED_HEADER_FIRST_PART_LENGTH];
            /* read in first few bytes of RTP header */
            unpack_cbuff_to_array((int*)fixed_header_first_part, ip_buffer, RTP_FIXED_HEADER_FIRST_PART_LENGTH);
8420084c:	04 21       	r2 = Null + 4;
8420084e:	02 14       	r0 = FP + 64;
84200850:	53 08       	r1 = r8 + Null;
84200852:	05 f0 29 e5 	call (m) $_unpack_cbuff_to_array;

            /* validate version */
            if ((fixed_header_first_part[0] & RTP0_VERSION_MASK) != RTP0_VERSION_2)
84200856:	81 d8       	rMAC = M[FP + 64];
84200858:	12 f0 c0 00 	r0 = rMAC AND 0xc0;
8420085c:	20 f0 80 24 	Null = r0 - 128;
84200860:	0f 60       	if EQ jump (m) Lc_rtp_decode_process_data_44;

84200862 <Lc_rtp_decode_process_data_43>:
            {
                /* Unsupported version - discard */
                cbuffer_advance_read_ptr_ex(ip_buffer, packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
84200862:	3b 25       	r1 = r5 - 4;
84200864:	52 08       	r0 = r8 + Null;
84200866:	08 f0 2d e5 	call (m) $_cbuffer_advance_read_ptr_ex;
                delete_consumed_metadata_tag(ip_buffer, packet_size);
8420086a:	3b 00       	r1 = r5 + Null;
8420086c:	52 08       	r0 = r8 + Null;
8420086e:	01 f0 23 e8 	call (m) Lc_delete_consumed_metadata_tag_1;
#ifdef DEBUG_RTP_DECODE
                /* Increment decode lost */
                opx_data->rtp_decode_lost++;
84200872:	81 f0 0b 88 	rMAC = M[r6 + 44];
84200876:	49 20       	rMAC = rMAC + 1;
84200878:	81 f0 0b 8e 	M[r6 + 44] = rMAC;
8420087c:	a4 6f       	jump (m) Lc_rtp_decode_process_data_33;

8420087e <Lc_rtp_decode_process_data_44>:
#endif
            }
            else
            {
                unsigned csrc_count = (fixed_header_first_part[0] & RTP0_CSRC_COUNT_MASK);
8420087e:	8e c1       	r4 = rMAC AND 0xf;
                unsigned seq = fixed_header_first_part[3] | (fixed_header_first_part[2]<<8);
84200880:	92 d8       	r0 = M[FP + 72];
84200882:	99 d8       	rMAC = M[FP + 76];
84200884:	d2 55       	r0 = r0 LSHIFT 8;
84200886:	1f f2 49 c8 	r7 = r0 OR rMAC;
                unsigned padding_amount = 0;
8420088a:	78 de       	M[FP + 60] = Null;
                unsigned header_size;
                unsigned payload_size;
                RTP_FRAME_DECODE_DATA frame_data = {FALSE, 0, 0, 0, 0};
8420088c:	07 f0 03 f0 	r1 = Null + 7340240;
84200890:	d0 40 
84200892:	02 15       	r0 = FP + 80;
84200894:	44 21       	r2 = Null + 5;
84200896:	ff fd b4 f0 	call (m) 0x17116;
8420089a:	21 e4 
                /* Set the frame header decode structure to remove gcc warnings. */

                /* check the sequence number unless local value is 0 which
                 * means initialisation. */
                if ((opx_data->sequence_number != 0) &&
                    (seq != (opx_data->sequence_number + 1)))
8420089c:	81 f0 03 88 	rMAC = M[r6 + 12];
842008a0:	0c 60       	if EQ jump (m) Lc_rtp_decode_process_data_47;

842008a2 <Lc_rtp_decode_process_data_45>:
842008a2:	4a 20       	r0 = rMAC + 1;
842008a4:	2f f9 00 c2 	Null = r7 - r0;
842008a8:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_47;

842008aa <Lc_rtp_decode_process_data_46>:
                {
#ifdef DEBUG_RTP_DECODE
                    opx_data->rtp_decode_late += seq - (opx_data->sequence_number + 1);
842008aa:	82 f0 0a 88 	r0 = M[r6 + 40];
842008ae:	4a 0c       	r0 = r7 + r0;
842008b0:	52 24       	r0 = r0 - 1;
842008b2:	51 04       	rMAC = r0 - rMAC;
842008b4:	81 f0 0a 8e 	M[r6 + 40] = rMAC;

842008b8 <Lc_rtp_decode_process_data_47>:
                    /* TODO - insert dummy frame when data is lost? (TODO This is an old comment) */
#endif
                }

                /* update sequence number */
                opx_data->sequence_number = seq;
842008b8:	89 f0 03 8e 	M[r6 + 12] = r7;

                /* Calculate the header size */
                header_size = rtp_header_size + (csrc_count * 4) +
                             opx_data->payload_header_size;
842008bc:	72 54       	r0 = r4 LSHIFT 2;
842008be:	81 f0 09 88 	rMAC = M[r6 + 36];
842008c2:	51 00       	rMAC = r0 + rMAC;
842008c4:	5a d8       	r0 = M[FP + 44];
842008c6:	8e 00       	r4 = rMAC + r0;

                if ((fixed_header_first_part[0] & RTP0_PADDING) != 0)
842008c8:	81 d8       	rMAC = M[FP + 64];
842008ca:	49 c2       	rMAC = rMAC AND 0x20;
842008cc:	0e 60       	if EQ jump (m) Lc_rtp_decode_process_data_50;

842008ce <Lc_rtp_decode_process_data_48>:
                {
                    /* padding amount is the last byte in the buffer. The first part
                     * of the header is already read. The current read offset is
                     * RTP_FIXED_HEADER_FIRST_PART_LENGTH. */
                    unpack_cbuff_to_array_from_offset((int*) &padding_amount, ip_buffer,
                            packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH - 1, 1);
842008ce:	45 20       	r3 = Null + 1;
842008d0:	74 f3 fb 3b 	r2 = r5 + -5;
842008d4:	c2 13       	r0 = FP + 60;
842008d6:	53 08       	r1 = r8 + Null;
842008d8:	05 f0 27 e3 	call (m) $_unpack_cbuff_to_array_from_offset;

                    /* ignore rogue values  */
                    if (padding_amount > (packet_size - header_size))
842008dc:	79 d8       	rMAC = M[FP + 60];
842008de:	ba 05       	r0 = r5 - r4;
842008e0:	88 04       	Null = rMAC - r0;
842008e2:	09 f0 87 e0 	if LS jump (m) Lc_rtp_decode_process_data_50;

842008e6 <Lc_rtp_decode_process_data_49>:
                    {
                        padding_amount = 0;
842008e6:	78 de       	M[FP + 60] = Null;

842008e8 <Lc_rtp_decode_process_data_50>:
                    }
                }

                /* calc size of the frame that needs to be written to DSP  */
                payload_size = packet_size - header_size - padding_amount;
842008e8:	b9 05       	rMAC = r5 - r4;
842008ea:	7a d8       	r0 = M[FP + 60];
842008ec:	2f f1 09 c2 	r7 = rMAC - r0;

                /* The RTP timestamp field is actually a sample count which is
                 * only reliable for APTX adaptive. For other decoders the header is discarded. */
                if (opx_data->mode == RTP_DECODE && opx_data->codec_type == APTXADAPTIVE)
842008f0:	81 f0 08 80 	rMAC = MBS[r6 + 8];
842008f4:	48 24       	Null = rMAC - 1;
842008f6:	35 63       	if NE jump (m) Lc_rtp_decode_process_data_27;

842008f8 <Lc_rtp_decode_process_data_51>:
842008f8:	81 f0 11 80 	rMAC = MBS[r6 + 17];
842008fc:	88 25       	Null = rMAC - 6;
842008fe:	31 63       	if NE jump (m) Lc_rtp_decode_process_data_27;

84200900 <Lc_rtp_decode_process_data_52>:
                {
                    rtp_header_decode(opx_data, header_size, &rtp_header);
84200900:	44 16       	r2 = FP + 100;
84200902:	33 00       	r1 = r4 + Null;
84200904:	42 08       	r0 = r6 + Null;
84200906:	4d 4e       	call (m) Lc_rtp_header_decode_1;
                    if (rtp_header.source != opx_data->prev_src_id)
84200908:	db d8       	r1 = M[FP + 108];
8420090a:	81 f0 1e 88 	rMAC = M[r6 + 120];
8420090e:	58 04       	Null = r1 - rMAC;
84200910:	03 60       	if EQ jump (m) Lc_rtp_decode_process_data_54;

84200912 <Lc_rtp_decode_process_data_53>:
                    {
                        rtp_source_changed(op_data, rtp_header.source);
84200912:	42 d8       	r0 = M[FP + 32];
84200914:	9e 4e       	call (m) Lc_rtp_source_changed_1;

84200916 <Lc_rtp_decode_process_data_54>:
                    }
                    frame_data.rtp_timestamp = rtp_header.timestamp;
84200916:	d1 d8       	rMAC = M[FP + 104];
84200918:	c1 de       	M[FP + 96] = rMAC;
8420091a:	27 6f       	jump (m) Lc_rtp_decode_process_data_28;

8420091c <Lc_rtp_decode_process_data_55>:
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
                }
                else if (opx_data->mode == RTP_DECODE)
8420091c:	48 24       	Null = rMAC - 1;
8420091e:	49 63       	if NE jump (m) Lc_rtp_decode_process_data_31;

84200920 <Lc_rtp_decode_process_data_56>:
                {
                    /* Timestamp and transport the tag. */
                    transport_metadata_tag(opx_data, &frame_data, packet_size);
84200920:	03 15       	r1 = FP + 80;
84200922:	3c 00       	r2 = r5 + Null;
84200924:	42 08       	r0 = r6 + Null;
84200926:	01 f0 3f e5 	call (m) Lc_transport_metadata_tag_1;
                    if ((frame_data.nr_of_frames > 0)&&(!opx_data->pack_latency_buffer))
8420092a:	b8 d8       	Null = M[FP + 92];
8420092c:	42 61       	if EQ jump (m) Lc_rtp_decode_process_data_31;

8420092e <Lc_rtp_decode_process_data_57>:
8420092e:	80 f0 1d 88 	Null = M[r6 + 116];
84200932:	3f 63       	if NE jump (m) Lc_rtp_decode_process_data_31;

84200934 <Lc_19>:
84200934:	3b 6f       	jump (m) Lc_rtp_decode_process_data_30;

84200936 <Lc_rtp_decode_process_data_58>:
    }

    /*
     * Consumed all the available data -> kick backwards.
     */
    touched->sinks = TOUCHED_SINK_0;
84200936:	41 20       	rMAC = Null + 1;
84200938:	4a d8       	r0 = M[FP + 36];
8420093a:	51 8e       	M[r0 + 4] = rMAC;

    L4_DBG_MSG2("RTP END available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
8420093c:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200940:	08 25       	Null = rMAC - 4;
84200942:	10 68       	if LT jump (m) Lc_rtp_decode_process_data_60;

84200944 <Lc_rtp_decode_process_data_59>:
84200944:	52 08       	r0 = r8 + Null;
84200946:	07 f0 37 e2 	call (m) $_cbuffer_calc_amount_data_ex;
8420094a:	16 00       	r4 = r0 + Null;
8420094c:	52 d8       	r0 = M[FP + 40];
8420094e:	07 f0 3f e4 	call (m) $_cbuffer_calc_amount_space_ex;
84200952:	14 00       	r2 = r0 + Null;
84200954:	55 f1 02 f0 	r0 = Null + 357565263;
84200958:	4f 43 
8420095a:	33 00       	r1 = r4 + Null;
8420095c:	ff fd 00 f0 	call (m) 0x9c8;
84200960:	2d e3 

84200962 <Lc_rtp_decode_process_data_60>:
}
84200962:	6c 4c       	SP = SP + -80;
84200964:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200966:	d8 4c       	rts;

84200968 <Lc_rtp_set_payload_header_size_1>:
 * potentially other parameters in the future) will be set according to the codec type.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
84200968:	c8 1c       	pushm <FP(=SP), rLink>;
    switch (opx_data->codec_type)
8420096a:	51 a0       	rMAC = MBS[r0 + 17];
8420096c:	11 60       	if EQ jump (m) Lc_rtp_set_payload_header_size_9;

8420096e <Lc_rtp_set_payload_header_size_2>:
8420096e:	08 24       	Null = rMAC - 0;
84200970:	11 6c       	if LE jump (m) Lc_rtp_set_payload_header_size_10;

84200972 <Lc_rtp_set_payload_header_size_3>:
84200972:	88 24       	Null = rMAC - 2;
84200974:	04 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_5;

84200976 <Lc_rtp_set_payload_header_size_4>:
    {
        case SBC:
        {
            opx_data->payload_header_size = SBC_PAYLOAD_HEADER_SIZE;
84200976:	41 20       	rMAC = Null + 1;
84200978:	51 9e       	M[r0 + 36] = rMAC;
8420097a:	11 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

8420097c <Lc_rtp_set_payload_header_size_5>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
8420097c:	c8 24       	Null = rMAC - 3;
8420097e:	04 62       	if NE jump (m) Lc_rtp_set_payload_header_size_7;

84200980 <Lc_rtp_set_payload_header_size_6>:
            opx_data->payload_header_size = ATRAC_PAYLOAD_HEADER_SIZE;
            break;
        }
        case MP3:
        {
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
84200980:	01 21       	rMAC = Null + 4;
84200982:	51 9e       	M[r0 + 36] = rMAC;
            break;
84200984:	0c 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200986 <Lc_rtp_set_payload_header_size_7>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
84200986:	08 25       	Null = rMAC - 4;
84200988:	05 68       	if LT jump (m) Lc_rtp_set_payload_header_size_10;

8420098a <Lc_rtp_set_payload_header_size_8>:
8420098a:	88 25       	Null = rMAC - 6;
8420098c:	03 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_10;

8420098e <Lc_rtp_set_payload_header_size_9>:
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
            break;
        }
        case APTX:
        {
            opx_data->payload_header_size = APTX_PAYLOAD_HEADER_SIZE;
8420098e:	50 9e       	M[r0 + 36] = Null;
84200990:	06 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200992 <Lc_rtp_set_payload_header_size_10>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
84200992:	02 f0 7a 40 	r0 = Null + 122;
84200996:	ff fd 9a f0 	call (m) 0x13f08;
8420099a:	33 eb 

8420099c <Lc_rtp_set_payload_header_size_11>:
            break;
        }
    }

}
8420099c:	c8 48       	popm <FP, rLink>;
8420099e:	d8 4c       	rts;

842009a0 <Lc_rtp_header_decode_1>:
 *
 * \param opx_data Pointer to the RTP operator data.
 * \param header_size RTP header size.
 */
static void rtp_header_decode(RTP_DECODE_OP_DATA *opx_data, unsigned header_size, RTP_HEADER_DATA *header)
{
842009a0:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
842009a2:	1a 09       	r8 = r1 + Null;
842009a4:	21 09       	r7 = r2 + Null;

    tCbuffer *ip_buffer = opx_data->ip_buffer;
842009a6:	28 f0 0f 88 	r6 = M[r0 + 60];
    TIME rtp_timestamp;
    uint32 rtp_source;

    /* Get the sequence number */
    unpack_cbuff_to_array((int*)fixed_header, ip_buffer,
        RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH);
842009aa:	04 22       	r2 = Null + 8;
842009ac:	c2 11       	r0 = FP + 28;
842009ae:	43 08       	r1 = r6 + Null;
842009b0:	04 f0 2b ea 	call (m) $_unpack_cbuff_to_array;

    /* The RTP timestamp field is actually a sample count.
     * This sample count should be used to generate the time to play
     * timestamp . */
    rtp_timestamp = (((uint32)fixed_header[0])<<24) + (fixed_header[1]<<16) + (fixed_header[2]<<8) + fixed_header[3];
842009b4:	3a d8       	r0 = M[FP + 28];
842009b6:	4b d8       	r1 = M[FP + 36];
842009b8:	44 d8       	r2 = M[FP + 32];
842009ba:	52 57       	r0 = r0 LSHIFT 24;
842009bc:	db 55       	r1 = r1 LSHIFT 8;
842009be:	a4 56       	r2 = r2 LSHIFT 16;
842009c0:	19 01       	rMAC = r1 + r2;
842009c2:	51 00       	rMAC = r0 + rMAC;
842009c4:	52 d8       	r0 = M[FP + 40];
842009c6:	8e 00       	r4 = rMAC + r0;
    rtp_source = (((uint32)fixed_header[4])<<24) + (fixed_header[5]<<16) + (fixed_header[6]<<8) + fixed_header[7];
842009c8:	5a d8       	r0 = M[FP + 44];
842009ca:	6b d8       	r1 = M[FP + 52];
842009cc:	64 d8       	r2 = M[FP + 48];
842009ce:	52 57       	r0 = r0 LSHIFT 24;
842009d0:	db 55       	r1 = r1 LSHIFT 8;
842009d2:	a4 56       	r2 = r2 LSHIFT 16;
842009d4:	19 01       	rMAC = r1 + r2;
842009d6:	51 00       	rMAC = r0 + rMAC;
842009d8:	72 d8       	r0 = M[FP + 56];
842009da:	8f 00       	r5 = rMAC + r0;

    /* Protected from the rtp timestamp overflow.*/

    /* TODO make this a L4 log*/
    L4_DBG_MSG2("RTP decode: rtp_timestamp = %u source = %u", rtp_timestamp, rtp_source);
842009dc:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842009e0:	08 25       	Null = rMAC - 4;
842009e2:	09 68       	if LT jump (m) Lc_rtp_header_decode_3;

842009e4 <Lc_rtp_header_decode_2>:
842009e4:	55 f1 02 f0 	r0 = Null + 357564416;
842009e8:	00 40 
842009ea:	3c 00       	r2 = r5 + Null;
842009ec:	33 00       	r1 = r4 + Null;
842009ee:	ef fd ff ff 	call (m) 0x9c8;
842009f2:	3b ee 

842009f4 <Lc_rtp_header_decode_3>:

    /* Save the RTP timestamp */

    /* Discard the rest of the header. */
    cbuffer_advance_read_ptr_ex(ip_buffer, header_size -
            (RTP_FIXED_HEADER_FIRST_PART_LENGTH + RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH));
842009f4:	a3 f3 f4 3b 	r1 = r8 + -12;
842009f8:	42 08       	r0 = r6 + Null;
842009fa:	07 f0 39 e8 	call (m) $_cbuffer_advance_read_ptr_ex;
    header->timestamp = rtp_timestamp;
842009fe:	96 f0 01 8e 	M[r7 + 4] = r4;
    header->source = rtp_source;
84200a02:	97 f0 02 8e 	M[r7 + 8] = r5;

84200a06 <Lc_rtp_header_decode_4>:
}
84200a06:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200a08:	d8 4c       	rts;

84200a0a <Lc_rtp_notify_latency_change_1>:


static void rtp_notify_latency_change(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL latency)
{
84200a0a:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200a0c:	16 00       	r4 = r0 + Null;
84200a0e:	1f 00       	r5 = r1 + Null;
84200a10:	20 09       	r6 = r2 + Null;
    unsigned latency_changed_msg[OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE];

    L4_DBG_MSG2( "RTP decode target latency change %d for source %u is notified", latency, source );
84200a12:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200a16:	08 25       	Null = rMAC - 4;
84200a18:	09 68       	if LT jump (m) Lc_rtp_notify_latency_change_3;

84200a1a <Lc_rtp_notify_latency_change_2>:
84200a1a:	55 f1 02 f0 	r0 = Null + 357564459;
84200a1e:	2b 40 
84200a20:	3c 00       	r2 = r5 + Null;
84200a22:	43 08       	r1 = r6 + Null;
84200a24:	ef fd ff ff 	call (m) 0x9c8;
84200a28:	25 ed 

84200a2a <Lc_rtp_notify_latency_change_3>:

    latency_changed_msg[0] =   source & 0xffff;
84200a2a:	b9 c6       	rMAC = r5 AND 0xffff;
84200a2c:	29 de       	M[FP + 20] = rMAC;
    latency_changed_msg[1] =   source >> 16;
84200a2e:	ba 52       	r0 = r5 LSHIFT -16;
84200a30:	32 de       	M[FP + 24] = r0;
    latency_changed_msg[2] =   (uint32)latency & 0xffff;
84200a32:	81 f7 ff 1f 	rMAC = r6 AND 0xffff;
84200a36:	39 de       	M[FP + 28] = rMAC;
    latency_changed_msg[3] =   (uint32)latency >> 16;
84200a38:	78 f8 d2 c8 	r0 = r6 LSHIFT -16;
84200a3c:	42 de       	M[FP + 32] = r0;

    common_send_unsolicited_message( op_data, (unsigned)OPMSG_REPLY_ID_LATENCY_CHANGED,
                                     OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE,
                                     (unsigned*)latency_changed_msg);
84200a3e:	45 11       	r3 = FP + 20;
84200a40:	04 21       	r2 = Null + 4;
84200a42:	43 21       	r1 = Null + 5;
84200a44:	32 00       	r0 = r4 + Null;
84200a46:	ef fd fc ff 	call (m) 0x25e;
84200a4a:	39 e0 

84200a4c <Lc_rtp_notify_latency_change_4>:
}
84200a4c:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200a4e:	d8 4c       	rts;

84200a50 <Lc_rtp_source_changed_1>:

static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source)
{
84200a50:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200a52:	11 09       	r7 = r0 + Null;
84200a54:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200a56:	05 f0 2d e6 	call (m) $_base_op_get_instance_data;
84200a5a:	17 00       	r5 = r0 + Null;
static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL new_latency;
    unsigned count;
    opx_data->prev_src_id = source;
84200a5c:	be bf       	M[r5 + 120] = r4;
    if (opx_data->src_latency_map != NULL)
84200a5e:	3c b9       	r2 = M[r5 + 112];
84200a60:	2b 60       	if EQ jump (m) Lc_rtp_source_changed_9;

84200a62 <Lc_rtp_source_changed_2>:
84200a62:	23 e8       	r1 = M[r2 + Null];
    {
        for (count = 0; count < opx_data->src_latency_map->num_entries; count++)
84200a64:	02 00       	r0 = Null + Null;
84200a66:	21 21       	rMAC = r2 + 4;
84200a68:	03 6e       	jump (m) Lc_rtp_source_changed_4;

84200a6a <Lc_rtp_source_changed_3>:
84200a6a:	52 20       	r0 = r0 + 1;
84200a6c:	09 22       	rMAC = rMAC + 8;

84200a6e <Lc_rtp_source_changed_4>:
84200a6e:	d0 04       	Null = r0 - r1;
84200a70:	02 f0 c7 e0 	if C jump (m) Lc_rtp_source_changed_9;

84200a74 <Lc_rtp_source_changed_5>:
        {
            if (opx_data->src_latency_map->entries[count].source_id == source)
84200a74:	6f f1 00 c3 	Null = M[rMAC] - r4;
84200a78:	f9 63       	if NE jump (m) Lc_rtp_source_changed_3;

84200a7a <Lc_rtp_source_changed_6>:
            {
                new_latency = opx_data->src_latency_map->entries[count].target_latency;
84200a7a:	92 54       	r0 = r0 LSHIFT 3;
84200a7c:	14 01       	r2 = r0 + r2;
84200a7e:	48 f0 02 88 	r6 = M[r2 + 8];
                L2_DBG_MSG2("RTP decode target latency changed to %d for source %u", new_latency, source);
84200a82:	55 f1 02 f0 	r0 = Null + 357564521;
84200a86:	69 40 
84200a88:	34 00       	r2 = r4 + Null;
84200a8a:	43 08       	r1 = r6 + Null;
84200a8c:	ef fd ff ff 	call (m) 0x9c8;
84200a90:	3d e9 
                /* Notify the latency change */
                if( opx_data->latency_change_notify_enable == 1)
84200a92:	3a a2       	r0 = MBU[r5 + 16];
84200a94:	12 50       	r0 = r0 LSHIFT -1;
84200a96:	11 c0       	rMAC = r0 AND 0x1;
84200a98:	05 60       	if EQ jump (m) Lc_rtp_source_changed_8;

84200a9a <Lc_rtp_source_changed_7>:
                {
                    rtp_notify_latency_change( op_data, source, new_latency );
84200a9a:	44 08       	r2 = r6 + Null;
84200a9c:	33 00       	r1 = r4 + Null;
84200a9e:	4a 08       	r0 = r7 + Null;
84200aa0:	b5 4f       	call (m) Lc_rtp_notify_latency_change_1;

84200aa2 <Lc_rtp_source_changed_8>:
                }

                ttp_configure_latency(opx_data->ttp_instance, new_latency);
84200aa2:	3a a9       	r0 = M[r5 + 80];
84200aa4:	43 08       	r1 = r6 + Null;
84200aa6:	ff fd ae f0 	call (m) 0x167da;
84200aaa:	35 e9 
                ttp_reset(opx_data->ttp_instance);
84200aac:	3a a9       	r0 = M[r5 + 80];
84200aae:	ff fd ae f0 	call (m) 0x166c0;
84200ab2:	33 e0 
                return;
84200ab4:	08 6e       	jump (m) Lc_rtp_source_changed_10;

84200ab6 <Lc_rtp_source_changed_9>:
            }
        }
    }
    L2_DBG_MSG1("RTP decode: no latency target for source %u, target unchanged", source);
84200ab6:	55 f1 02 f0 	r0 = Null + 357564575;
84200aba:	9f 40 
84200abc:	33 00       	r1 = r4 + Null;
84200abe:	ef fd ff ff 	call (m) 0x9b4;
84200ac2:	37 e7 

84200ac4 <Lc_rtp_source_changed_10>:
84200ac4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200ac6:	d8 4c       	rts;

84200ac8 <Lc_rtp_decode_reset_working_data_1>:
 * Initialise various working data parameters for the RTP operator.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_decode_reset_working_data(OPERATOR_DATA *op_data)
{
84200ac8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200aca:	05 f0 39 e2 	call (m) $_base_op_get_instance_data;
84200ace:	16 00       	r4 = r0 + Null;

#ifdef DATAFORMAT_32
    opx_data->ip_format = AUDIO_DATA_FORMAT_32_BIT;
    opx_data->op_format = AUDIO_DATA_FORMAT_32_BIT;
#else
    opx_data->ip_format = AUDIO_DATA_FORMAT_16_BIT;
84200ad0:	30 ee       	M[r4 + Null] = Null;
    opx_data->op_format = AUDIO_DATA_FORMAT_16_BIT;
84200ad2:	70 8e       	M[r4 + 4] = Null;
#endif /* DATAFORMAT_32 */

    /* Set the default working mode as RTP header stripping. */
    opx_data->mode = RTP_STRIP;
84200ad4:	81 20       	rMAC = Null + 2;
84200ad6:	31 9a       	MB[r4 + 8] = rMAC;

    /* Disable content protection by default. */
    opx_data->scms_enable = 0;
84200ad8:	31 a2       	rMAC = MBU[r4 + 16];
84200ada:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;

    /* disable letency notification */
    opx_data->latency_change_notify_enable = 0;
84200ade:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
84200ae2:	31 aa       	MB[r4 + 16] = rMAC;

    /* For the moment the default code is SBC. */
    opx_data->codec_type = SBC;
84200ae4:	41 20       	rMAC = Null + 1;
84200ae6:	71 aa       	MB[r4 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
84200ae8:	40 4f       	call (m) Lc_rtp_set_payload_header_size_1;
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = -1;
84200aea:	41 24       	rMAC = Null - 1;
84200aec:	71 9f       	M[r4 + 52] = rMAC;
    opx_data->rtp_decode_last_tag_length = -1;
84200aee:	b1 9f       	M[r4 + 56] = rMAC;

84200af0 <Lc_rtp_decode_reset_working_data_2>:
#endif
}
84200af0:	f1 48       	popm <FP, r4, rLink>;
84200af2:	d8 4c       	rts;

84200af4 <Lc_get_read_index_from_buff_1>:
/*
 * Returns the read index for a buffer. Supports 32-bit packed and
 * 16-bit unpacked data.
 */
static unsigned int get_read_index_from_buff(tCbuffer *cbuffer)
{
84200af4:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned int read_index;
#ifndef DATAFORMAT_32
    unsigned int offset;
#endif /* !DATAFORMAT_32 */
    read_index = cbuffer_get_read_offset_ex(cbuffer);
84200af6:	04 f0 3f e4 	call (m) $_cbuffer_get_read_offset_ex;

#ifndef DATAFORMAT_32
    offset = read_index & 0x1;
84200afa:	11 c0       	rMAC = r0 AND 0x1;
    /*Convert the adresses to words. */
    read_index = read_index >> LOG2_ADDR_PER_WORD;
84200afc:	52 50       	r0 = r0 LSHIFT -2;

    /* Convert the words to usable octets. */
    read_index = read_index << 1;
84200afe:	12 54       	r0 = r0 LSHIFT 1;
    read_index += offset;
84200b00:	8a 00       	r0 = rMAC + r0;

84200b02 <Lc_get_read_index_from_buff_2>:
#endif /* !DATAFORMAT_32 */

    return read_index;
84200b02:	c8 48       	popm <FP, rLink>;
84200b04:	d8 4c       	rts;

84200b06 <Lc_tag_valid_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 * \param opx_data Pointer to the RTP operator data.
 */
static bool tag_valid(metadata_tag* tag, RTP_DECODE_OP_DATA *opx_data )
{
84200b06:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200b08:	17 00       	r5 = r0 + Null;
84200b0a:	1e 00       	r4 = r1 + Null;

    if (get_read_index_from_buff(opx_data->ip_buffer) != tag->index )
84200b0c:	f2 99       	r0 = M[r4 + 60];
84200b0e:	f3 4f       	call (m) Lc_get_read_index_from_buff_1;
84200b10:	b9 88       	rMAC = M[r5 + 8];
84200b12:	50 04       	Null = r0 - rMAC;
84200b14:	22 60       	if EQ jump (m) Lc_tag_valid_3;

84200b16 <Lc_tag_valid_2>:
        unsigned discard_buffer;
        unsigned discard_metadata;
        unsigned octets_2_first_tag, octets_post_last_tag;
        metadata_tag  *tag_list;
        /* Probably the metadata and the buffer will have different amount of data. */
        discard_buffer = cbuffer_calc_amount_data_ex(opx_data->ip_buffer);
84200b16:	f2 99       	r0 = M[r4 + 60];
84200b18:	06 f0 25 e4 	call (m) $_cbuffer_calc_amount_data_ex;
84200b1c:	10 09       	r6 = r0 + Null;
        cbuffer_advance_read_ptr_ex(opx_data->ip_buffer, discard_buffer);
84200b1e:	f2 99       	r0 = M[r4 + 60];
84200b20:	43 08       	r1 = r6 + Null;
84200b22:	06 f0 31 ef 	call (m) $_cbuffer_advance_read_ptr_ex;

        discard_metadata = buff_metadata_available_octets(opx_data->ip_buffer);
84200b26:	f2 99       	r0 = M[r4 + 60];
84200b28:	ff fd 88 f0 	call (m) 0x11d04;
84200b2c:	3d ee 
84200b2e:	17 00       	r5 = r0 + Null;
        tag_list = buff_metadata_remove(opx_data->ip_buffer, discard_metadata, &octets_2_first_tag, &octets_post_last_tag);
84200b30:	85 11       	r3 = FP + 24;
84200b32:	44 11       	r2 = FP + 20;
84200b34:	f2 99       	r0 = M[r4 + 60];
84200b36:	3b 00       	r1 = r5 + Null;
84200b38:	ff fd 89 f0 	call (m) 0x11d7a;
84200b3c:	23 e2 
        buff_metadata_tag_list_delete(tag_list);
84200b3e:	ff fd 86 f0 	call (m) 0x11906;
84200b42:	29 ee 

        L2_DBG_MSG2("RTP Decode buffer out of sink. discard_buffer = %d, discard_metadata =%d",
                discard_buffer, discard_metadata);
84200b44:	55 f1 02 f0 	r0 = Null + 357564637;
84200b48:	dd 40 
84200b4a:	3c 00       	r2 = r5 + Null;
84200b4c:	43 08       	r1 = r6 + Null;
84200b4e:	ef fd ff ff 	call (m) 0x9c8;
84200b52:	3b e3 
        return FALSE;
84200b54:	02 00       	r0 = Null + Null;
84200b56:	05 6e       	jump (m) Lc_tag_valid_4;

84200b58 <Lc_tag_valid_3>:
    }
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = tag->index;
84200b58:	71 9f       	M[r4 + 52] = rMAC;
    opx_data->rtp_decode_last_tag_length = tag->length;
84200b5a:	f9 88       	rMAC = M[r5 + 12];
84200b5c:	b1 9f       	M[r4 + 56] = rMAC;
#endif
    return TRUE;
84200b5e:	42 20       	r0 = Null + 1;

84200b60 <Lc_tag_valid_4>:
}
84200b60:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200b62:	d8 4c       	rts;

84200b64 <Lc_get_tag_size_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 */
static unsigned int get_tag_size(metadata_tag* tag)
{
    if (tag == NULL)
84200b64:	10 04       	Null = r0 - Null;
84200b66:	03 62       	if NE jump (m) Lc_get_tag_size_3;

84200b68 <Lc_get_tag_size_2>:
    {
        return 0;
84200b68:	02 00       	r0 = Null + Null;
84200b6a:	02 6e       	jump (m) Lc_get_tag_size_4;

84200b6c <Lc_get_tag_size_3>:
    }
    return tag->length;
84200b6c:	d2 88       	r0 = M[r0 + 12];

84200b6e <Lc_get_tag_size_4>:
84200b6e:	d8 4c       	rts;

84200b70 <Lc_delete_consumed_metadata_tag_1>:
 *
 * \param o_buff Pointer to the octet buffer from which the tag will be consumed.
 * \param octets_consumed Octets consumed from the buffer. Must be only one tag.
 */
static void delete_consumed_metadata_tag(tCbuffer *o_buff, unsigned int  octets_consumed)
{
84200b70:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
84200b72:	1e 00       	r4 = r1 + Null;

    unsigned int octets_b4idx, octets_afteridx;

    metadata_tag *tag = buff_metadata_remove(o_buff, octets_consumed, &octets_b4idx , &octets_afteridx);
84200b74:	05 11       	r3 = FP + 16;
84200b76:	c4 10       	r2 = FP + 12;
84200b78:	ff fd 89 f0 	call (m) 0x11d7a;
84200b7c:	23 e0 

    /* get_next_tag_size checks if the tag is at the beginning of the buffer. Therefore
     * octets_b4idx will be 0.*/
    /* Check metadata is synced */
    PL_ASSERT(tag != NULL);
84200b7e:	10 04       	Null = r0 - Null;
84200b80:	09 62       	if NE jump (m) Lc_delete_consumed_metadata_tag_3;

84200b82 <Lc_delete_consumed_metadata_tag_2>:
84200b82:	03 f0 71 41 	r1 = Null + 369;
84200b86:	02 f0 13 60 	r0 = Null + 4115;
84200b8a:	ff fd 99 f0 	call (m) 0x13f12;
84200b8e:	29 ec 
84200b90:	1a 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200b92 <Lc_delete_consumed_metadata_tag_3>:
    PL_ASSERT(octets_b4idx == 0);
84200b92:	18 d8       	Null = M[FP + 12];
84200b94:	09 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_5;

84200b96 <Lc_delete_consumed_metadata_tag_4>:
84200b96:	03 f0 72 41 	r1 = Null + 370;
84200b9a:	02 f0 13 60 	r0 = Null + 4115;
84200b9e:	ff fd 99 f0 	call (m) 0x13f12;
84200ba2:	35 eb 
84200ba4:	10 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200ba6 <Lc_delete_consumed_metadata_tag_5>:
    PL_ASSERT(octets_afteridx == octets_consumed);
84200ba6:	21 d8       	rMAC = M[FP + 16];
84200ba8:	88 05       	Null = rMAC - r4;
84200baa:	09 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_7;

84200bac <Lc_delete_consumed_metadata_tag_6>:
84200bac:	03 f0 73 41 	r1 = Null + 371;
84200bb0:	02 f0 13 60 	r0 = Null + 4115;
84200bb4:	ff fd 99 f0 	call (m) 0x13f12;
84200bb8:	3f ea 
84200bba:	05 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200bbc <Lc_delete_consumed_metadata_tag_7>:

    buff_metadata_delete_tag(tag, TRUE);
84200bbc:	43 20       	r1 = Null + 1;
84200bbe:	ff fd 86 f0 	call (m) 0x118b2;
84200bc2:	35 e7 

84200bc4 <Lc_delete_consumed_metadata_tag_8>:
}
84200bc4:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84200bc6:	d8 4c       	rts;

84200bc8 <Lc_get_time_of_arrival_1>:
/**
 * Returns the time of arrival of the tag. If the time of arrival is not set for the tag
 * the hal get time is used.
 */
static unsigned get_time_of_arrival( metadata_tag* tag)
{
84200bc8:	c8 1c       	pushm <FP(=SP), rLink>;
    if (IS_TIME_OF_ARRIVAL_TAG(tag))
84200bca:	51 88       	rMAC = M[r0 + 4];
84200bcc:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200bd0:	10 f0 40 24 	Null = rMAC - 64;
84200bd4:	03 62       	if NE jump (m) Lc_get_time_of_arrival_3;

84200bd6 <Lc_get_time_of_arrival_2>:
    {
        return tag->timestamp;
84200bd6:	12 89       	r0 = M[r0 + 16];
84200bd8:	04 6e       	jump (m) Lc_get_time_of_arrival_4;

84200bda <Lc_get_time_of_arrival_3>:
    }
    else
    {
        /* Maybe we are connected to a tester/file endpoint.*/
        return time_get_time();
84200bda:	ff fd 86 f1 	call (m) 0x317e8;
84200bde:	2f e0 

84200be0 <Lc_get_time_of_arrival_4>:
    }
}
84200be0:	c8 48       	popm <FP, rLink>;
84200be2:	d8 4c       	rts;

84200be4 <Lc_transport_metadata_tag_1>:
 * \param frame_data Pointer frame header decode data.
 * \param packet_size Size of the tag from the input buffer.
 */
static void transport_metadata_tag(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data,
        unsigned packet_size)
{
84200be4:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200be6:	4c 4c       	SP = SP + 48;
84200be8:	12 09       	r8 = r0 + Null;
84200bea:	19 09       	r7 = r1 + Null;
84200bec:	26 00       	r4 = r2 + Null;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer* ip_buffer = opx_data->ip_buffer;
84200bee:	a2 f0 0f 88 	r0 = M[r8 + 60];
    unsigned octets_2_first_tag, octets_post_last_tag;
    unsigned frame_length = frame_data->frame_length;
84200bf2:	9b f0 01 88 	r9 = M[r7 + 4];
    metadata_tag  *tag;
    ttp_status status;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200bf6:	a0 f0 1d 88 	Null = M[r8 + 116];
84200bfa:	08 60       	if EQ jump (m) Lc_transport_metadata_tag_3;

84200bfc <Lc_transport_metadata_tag_2>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84200bfc:	a1 f0 11 88 	rMAC = M[r8 + 68];
84200c00:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
84200c02:	a1 f0 12 88 	rMAC = M[r8 + 72];
84200c06:	49 de       	M[FP + 36] = rMAC;
84200c08:	07 6e       	jump (m) Lc_transport_metadata_tag_4;

84200c0a <Lc_transport_metadata_tag_3>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200c0a:	a1 f0 11 88 	rMAC = M[r8 + 68];
84200c0e:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->op_buffer;
84200c10:	a1 f0 10 88 	rMAC = M[r8 + 64];
84200c14:	49 de       	M[FP + 36] = rMAC;

84200c16 <Lc_transport_metadata_tag_4>:



    /* Remove the tag consumed in this cycle.
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);
84200c16:	45 13       	r3 = FP + 52;
84200c18:	04 13       	r2 = FP + 48;
84200c1a:	33 00       	r1 = r4 + Null;
84200c1c:	ff fd 88 f0 	call (m) 0x11d7a;
84200c20:	3f ea 
84200c22:	52 de       	M[FP + 40] = r0;

    PL_ASSERT(octets_2_first_tag == 0);
84200c24:	60 d8       	Null = M[FP + 48];
84200c26:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_6;

84200c28 <Lc_transport_metadata_tag_5>:
84200c28:	03 f0 b5 41 	r1 = Null + 437;
84200c2c:	02 f0 13 60 	r0 = Null + 4115;
84200c30:	ff fd 99 f0 	call (m) 0x13f12;
84200c34:	23 e7 
84200c36:	cd 6e       	jump (m) Lc_transport_metadata_tag_32;

84200c38 <Lc_transport_metadata_tag_6>:
    PL_ASSERT(octets_post_last_tag == packet_size);
84200c38:	69 d8       	rMAC = M[FP + 52];
84200c3a:	88 05       	Null = rMAC - r4;
84200c3c:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_8;

84200c3e <Lc_transport_metadata_tag_7>:
84200c3e:	03 f0 b6 41 	r1 = Null + 438;
84200c42:	02 f0 13 60 	r0 = Null + 4115;
84200c46:	ff fd 99 f0 	call (m) 0x13f12;
84200c4a:	2d e6 
84200c4c:	c2 6e       	jump (m) Lc_transport_metadata_tag_32;

84200c4e <Lc_transport_metadata_tag_8>:
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200c4e:	51 d8       	rMAC = M[FP + 40];
84200c50:	3e 60       	if EQ jump (m) Lc_transport_metadata_tag_21;

84200c52 <Lc_transport_metadata_tag_9>:
84200c52:	51 d8       	rMAC = M[FP + 40];
84200c54:	09 e8       	rMAC = M[rMAC + Null];
84200c56:	3b 62       	if NE jump (m) Lc_transport_metadata_tag_21;

84200c58 <Lc_transport_metadata_tag_10>:

    if (opx_data->codec_type == AAC)
84200c58:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
84200c5c:	08 25       	Null = rMAC - 4;
84200c5e:	26 62       	if NE jump (m) Lc_transport_metadata_tag_17;

84200c60 <Lc_transport_metadata_tag_11>:
    {
        unsigned clone_buf_avail_octets = cbuffer_calc_amount_data_ex(clone_buffer);
84200c60:	42 d8       	r0 = M[FP + 32];
84200c62:	05 f0 3b e9 	call (m) $_cbuffer_calc_amount_data_ex;
84200c66:	16 00       	r4 = r0 + Null;
        /* There shouln't be more than one AAC frames in the clone buffer. */
        if (frame_data->nr_of_frames > 1)
84200c68:	93 f0 03 88 	r1 = M[r7 + 12];
84200c6c:	58 24       	Null = r1 - 1;
84200c6e:	09 f0 97 e0 	if LS jump (m) Lc_transport_metadata_tag_13;

84200c72 <Lc_transport_metadata_tag_12>:
        {
            L2_DBG_MSG1("RTP decode: Number of AAC frames grater than 1! nr frames = %d",
                    frame_data->nr_of_frames);
84200c72:	55 f1 02 f0 	r0 = Null + 357564710;
84200c76:	26 41 
84200c78:	ef fd fe ff 	call (m) 0x9b4;
84200c7c:	3d e9 
            frame_data->nr_of_frames = 1;
84200c7e:	41 20       	rMAC = Null + 1;
84200c80:	91 f0 03 8e 	M[r7 + 12] = rMAC;

84200c84 <Lc_transport_metadata_tag_13>:
        /* Mark the frame as invalid if the frame length is different from the available
         * octets in the clone buffer. Note: Only do this if the frame data is valid
         * and if we have at least one frames in the clone buffer. */
        if ((frame_data->valid) &&
            (frame_data->nr_of_frames > 0) &&
            (frame_length != clone_buf_avail_octets) )
84200c84:	90 f0 00 e8 	Null = M[r7 + Null];
84200c88:	93 60       	if EQ jump (m) Lc_transport_metadata_tag_31;

84200c8a <Lc_transport_metadata_tag_14>:
84200c8a:	90 f0 03 88 	Null = M[r7 + 12];
84200c8e:	0e 60       	if EQ jump (m) Lc_transport_metadata_tag_17;

84200c90 <Lc_transport_metadata_tag_15>:
84200c90:	6f fb 00 c2 	Null = r9 - r4;
84200c94:	0b 60       	if EQ jump (m) Lc_transport_metadata_tag_17;

84200c96 <Lc_transport_metadata_tag_16>:
        {
            L2_DBG_MSG2("RTP decode: AAC frame length = %d is different from the payload length= %d",
                frame_length, clone_buf_avail_octets);
84200c96:	55 f1 02 f0 	r0 = Null + 357564773;
84200c9a:	65 41 
84200c9c:	34 00       	r2 = r4 + Null;
84200c9e:	5b 08       	r1 = r9 + Null;
84200ca0:	ef fd fe ff 	call (m) 0x9c8;
84200ca4:	29 e9 
            frame_data->valid = FALSE;
84200ca6:	90 f0 00 ee 	M[r7 + Null] = Null;

84200caa <Lc_transport_metadata_tag_17>:
        }
    }

    if ((frame_data->valid) && (frame_data->nr_of_frames > 0))
84200caa:	90 f0 00 e8 	Null = M[r7 + Null];
84200cae:	80 60       	if EQ jump (m) Lc_transport_metadata_tag_31;

84200cb0 <Lc_transport_metadata_tag_18>:
84200cb0:	91 f0 03 88 	rMAC = M[r7 + 12];
84200cb4:	70 60       	if EQ jump (m) Lc_transport_metadata_tag_30;

84200cb6 <Lc_transport_metadata_tag_19>:
        unsigned count;
        unsigned total_encoded_data;
        metadata_tag *last_tag, *tag_list, *new_tag;
        unsigned time_of_arrival;

        total_encoded_data = frame_length * frame_data->nr_of_frames;
84200cb6:	00 fb b1 c9 	rMAC = rMAC * r9 (int);
84200cba:	59 de       	M[FP + 44] = rMAC;

        if (opx_data->continuation_for_frame)
84200cbc:	a0 f0 07 88 	Null = M[r8 + 28];
84200cc0:	0e 60       	if EQ jump (m) Lc_transport_metadata_tag_22;

84200cc2 <Lc_transport_metadata_tag_20>:
        {
            time_of_arrival = opx_data->first_tag_time_of_arrival;
84200cc2:	a3 f0 08 88 	r1 = M[r8 + 32];
            opx_data->continuation_for_frame = FALSE;
84200cc6:	a0 f0 07 8e 	M[r8 + 28] = Null;
84200cca:	0c 6e       	jump (m) Lc_transport_metadata_tag_23;

84200ccc <Lc_transport_metadata_tag_21>:
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);

    PL_ASSERT(octets_2_first_tag == 0);
    PL_ASSERT(octets_post_last_tag == packet_size);
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200ccc:	03 f0 b7 41 	r1 = Null + 439;
84200cd0:	02 f0 13 60 	r0 = Null + 4115;
84200cd4:	ff fd 99 f0 	call (m) 0x13f12;
84200cd8:	3f e1 
84200cda:	7b 6e       	jump (m) Lc_transport_metadata_tag_32;

84200cdc <Lc_transport_metadata_tag_22>:
            time_of_arrival = opx_data->first_tag_time_of_arrival;
            opx_data->continuation_for_frame = FALSE;
        }
        else
        {
            time_of_arrival = get_time_of_arrival(tag);
84200cdc:	52 d8       	r0 = M[FP + 40];
84200cde:	75 4f       	call (m) Lc_get_time_of_arrival_1;
84200ce0:	13 00       	r1 = r0 + Null;

84200ce2 <Lc_transport_metadata_tag_23>:
        }

        /* Get the timestamp and sp adjust from the TTP module. Cannot put these two calls
         * to the for loop because the compiler gives status potentially unitialised. */
#ifndef TTP_SOURCE_TIME_TEST
        if (frame_data->frame_samples != 0)
84200ce2:	91 f0 02 88 	rMAC = M[r7 + 8];
84200ce6:	0b 60       	if EQ jump (m) Lc_transport_metadata_tag_25;

84200ce8 <Lc_transport_metadata_tag_24>:
        {
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival,
                frame_data->nr_of_frames * frame_data->frame_samples, &status);
84200ce8:	85 13       	r3 = FP + 56;
84200cea:	92 f0 03 88 	r0 = M[r7 + 12];
84200cee:	54 1a       	r2 = r0 * rMAC (int);
84200cf0:	a2 f0 14 88 	r0 = M[r8 + 80];
84200cf4:	ff fd ad f0 	call (m) 0x16860;
84200cf8:	2d eb 
84200cfa:	09 6e       	jump (m) Lc_transport_metadata_tag_26;

84200cfc <Lc_transport_metadata_tag_25>:
        }
        else
#endif
        {
            ttp_update_ttp_from_source_time(opx_data->ttp_instance, time_of_arrival,
                    frame_data->rtp_timestamp, &status);
84200cfc:	85 13       	r3 = FP + 56;
84200cfe:	94 f0 04 88 	r2 = M[r7 + 16];
84200d02:	a2 f0 14 88 	r0 = M[r8 + 80];
84200d06:	ff ff 17 f0 	call (m) 0x4003bbc;
84200d0a:	37 e5 

84200d0c <Lc_transport_metadata_tag_26>:
        }
        new_tag = tag_list = last_tag = tag;
84200d0c:	e8 f0 0a 88 	r6 = M[FP + 40];
84200d10:	41 08       	rMAC = r6 + Null;


        METADATA_TIME_OF_ARRIVAL_UNSET(tag);
84200d12:	0a 00       	r0 = rMAC + Null;
84200d14:	49 88       	rMAC = M[rMAC + 4];
84200d16:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84200d1a:	51 8e       	M[r0 + 4] = rMAC;
        /* Populate the new metadata tag. */
        ttp_utils_populate_tag(new_tag, &status);
84200d1c:	83 13       	r1 = FP + 56;
84200d1e:	ef fd fd ff 	call (m) 0x8d0;
84200d22:	33 ed 
84200d24:	41 08       	rMAC = r6 + Null;

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84200d26:	88 de       	M[FP + 68] = Null;

        new_tag->length = frame_length;
84200d28:	1b f0 03 8e 	M[rMAC + 12] = r9;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200d2c:	47 20       	r5 = Null + 1;

84200d2e <Lc_transport_metadata_tag_27>:
84200d2e:	91 f0 03 88 	rMAC = M[r7 + 12];
84200d32:	78 04       	Null = r5 - rMAC;
84200d34:	02 f0 c1 e0 	if C jump (m) Lc_transport_metadata_tag_29;

84200d38 <Lc_transport_metadata_tag_28>:
        {
            /* The first tag is allocated outside the for loop.*/
            new_tag = buff_metadata_new_tag();
84200d38:	ff fd 85 f0 	call (m) 0x11862;
84200d3c:	2b e9 
84200d3e:	16 00       	r4 = r0 + Null;
            status.ttp = ttp_get_next_timestamp(status.ttp, frame_data->frame_samples,
                opx_data->sample_rate, status.sp_adjustment);
84200d40:	7d d8       	r3 = M[FP + 60];
84200d42:	a4 f0 16 88 	r2 = M[r8 + 88];
84200d46:	93 f0 02 88 	r1 = M[r7 + 8];
84200d4a:	72 d8       	r0 = M[FP + 56];
84200d4c:	ff fd ae f0 	call (m) 0x16aa2;
84200d50:	37 ea 
84200d52:	72 de       	M[FP + 56] = r0;

            /* Populate the new metadata tag. */
            ttp_utils_populate_tag(new_tag, &status);
84200d54:	83 13       	r1 = FP + 56;
84200d56:	32 00       	r0 = r4 + Null;
84200d58:	ef fd fd ff 	call (m) 0x8d0;
84200d5c:	39 eb 
            METADATA_PACKET_START_SET(new_tag);
84200d5e:	71 88       	rMAC = M[r4 + 4];
84200d60:	c9 c8       	rMAC = rMAC OR 0x4;
            METADATA_PACKET_END_SET(new_tag);
84200d62:	49 c9       	rMAC = rMAC OR 0x8;
84200d64:	71 8e       	M[r4 + 4] = rMAC;
            new_tag->length = frame_length;
84200d66:	6b f0 03 8e 	M[r4 + 12] = r9;

            /* Add the new tag to the list. */
            last_tag->next = new_tag;
84200d6a:	86 f0 00 ee 	M[r6 + Null] = r4;
            last_tag = new_tag;
84200d6e:	30 09       	r6 = r4 + Null;

        new_tag->length = frame_length;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200d70:	7f 20       	r5 = r5 + 1;
84200d72:	de 6f       	jump (m) Lc_transport_metadata_tag_27;

84200d74 <Lc_transport_metadata_tag_29>:

        }

        /* Append the tag to the frame buffer. Note: the after index is only the data
         * after the last index. */
        buff_metadata_append(buffer, tag_list, 0, frame_length);
84200d74:	04 00       	r2 = Null + Null;
84200d76:	5d 08       	r3 = r9 + Null;
84200d78:	53 d8       	r1 = M[FP + 40];
84200d7a:	4a d8       	r0 = M[FP + 36];
84200d7c:	ff fd 86 f0 	call (m) 0x11adc;
84200d80:	21 eb 
        /* Make the data available in the output buffer. */
        cbuffer_advance_write_ptr_ex(buffer, total_encoded_data);
84200d82:	5b d8       	r1 = M[FP + 44];
84200d84:	4a d8       	r0 = M[FP + 36];
84200d86:	05 f0 27 e9 	call (m) $_cbuffer_advance_write_ptr_ex;
        /* Remove all the encoded data from the clone buffer. */
        cbuffer_advance_read_ptr_ex(clone_buffer, total_encoded_data);
84200d8a:	5b d8       	r1 = M[FP + 44];
84200d8c:	42 d8       	r0 = M[FP + 32];
84200d8e:	05 f0 25 ec 	call (m) $_cbuffer_advance_read_ptr_ex;
84200d92:	1f 6e       	jump (m) Lc_transport_metadata_tag_32;

84200d94 <Lc_transport_metadata_tag_30>:
    }
    else if (frame_data->valid)
    {
        opx_data->continuation_for_frame = TRUE;
84200d94:	41 20       	rMAC = Null + 1;
84200d96:	a1 f0 07 8e 	M[r8 + 28] = rMAC;
        opx_data->first_tag_time_of_arrival = get_time_of_arrival(tag);
84200d9a:	52 d8       	r0 = M[FP + 40];
84200d9c:	16 4f       	call (m) Lc_get_time_of_arrival_1;
84200d9e:	a2 f0 08 8e 	M[r8 + 32] = r0;
        /* TODO can any information hold in the tag get lost. My concern is the end of
         * file marker. */
        buff_metadata_delete_tag(tag, TRUE);
84200da2:	43 20       	r1 = Null + 1;
84200da4:	52 d8       	r0 = M[FP + 40];
84200da6:	ff fd 85 f0 	call (m) 0x118b2;
84200daa:	2d e8 
84200dac:	12 6e       	jump (m) Lc_transport_metadata_tag_32;

84200dae <Lc_transport_metadata_tag_31>:
    }
    else
    {
        opx_data->continuation_for_frame = FALSE;
84200dae:	a0 f0 07 8e 	M[r8 + 28] = Null;
        /* A corrupt frame is in the input buffer. Discard it. Note we discard everything
         * accumulated in the clone buffer. */
        clone_buffer->write_ptr = buffer->write_ptr;
84200db2:	49 d8       	rMAC = M[FP + 36];
84200db4:	42 d8       	r0 = M[FP + 32];
84200db6:	89 88       	rMAC = M[rMAC + 8];
84200db8:	91 8e       	M[r0 + 8] = rMAC;
        buff_metadata_delete_tag(tag, TRUE);
84200dba:	43 20       	r1 = Null + 1;
84200dbc:	52 d8       	r0 = M[FP + 40];
84200dbe:	ff fd 85 f0 	call (m) 0x118b2;
84200dc2:	35 e7 

        L2_DBG_MSG("RTP decode corrupt frame discarded! ");
84200dc4:	55 f1 02 f0 	r0 = Null + 357564848;
84200dc8:	b0 41 
84200dca:	ef fd fd ff 	call (m) 0x9a2;
84200dce:	39 ee 

84200dd0 <Lc_transport_metadata_tag_32>:
84200dd0:	74 4c       	SP = SP + -48;
84200dd2:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200dd4:	d8 4c       	rts;

84200dd6 <Lc_rtp_create_internal_buffer_1>:

    return TRUE;
}

static tCbuffer *rtp_create_internal_buffer(int *base_addr, unsigned size, unsigned buffer_flags, unsigned usable_octets)
{
84200dd6:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200dd8:	19 00       	rMAC = r1 + Null;
84200dda:	2e 00       	r4 = r3 + Null;
    tCbuffer *buffer;

    /* unset the metadata flag otherwise cbuffer create will fail. */
    BUF_DESC_METADATA_UNSET(buffer_flags);
84200ddc:	44 fb ff 1f 	r2 = r2 AND 0xffff7fff;
    if (base_addr != NULL)
84200de0:	10 04       	Null = r0 - Null;
84200de2:	06 60       	if EQ jump (m) Lc_rtp_create_internal_buffer_3;

84200de4 <Lc_rtp_create_internal_buffer_2>:
    {
        /* reuse the base */
        buffer = cbuffer_create(base_addr,
                size, buffer_flags);
84200de4:	ff fd 8c f0 	call (m) 0x12762;
84200de8:	3f eb 
84200dea:	17 00       	r5 = r0 + Null;
84200dec:	07 6e       	jump (m) Lc_rtp_create_internal_buffer_4;

84200dee <Lc_rtp_create_internal_buffer_3>:
    }
    else
    {
        /* create a new buffer */
        buffer = cbuffer_create_with_malloc(size, buffer_flags);
84200dee:	23 00       	r1 = r2 + Null;
84200df0:	0a 00       	r0 = rMAC + Null;
84200df2:	ff fd 8c f0 	call (m) 0x12790;
84200df6:	3f ec 
84200df8:	17 00       	r5 = r0 + Null;

84200dfa <Lc_rtp_create_internal_buffer_4>:
    }
    if (buffer == NULL)
84200dfa:	38 04       	Null = r5 - Null;
84200dfc:	03 62       	if NE jump (m) Lc_rtp_create_internal_buffer_6;

84200dfe <Lc_rtp_create_internal_buffer_5>:
    {
        return NULL;
84200dfe:	02 00       	r0 = Null + Null;
84200e00:	18 6e       	jump (m) Lc_rtp_create_internal_buffer_8;

84200e02 <Lc_rtp_create_internal_buffer_6>:
    }
    /* Allocate the metadta buffer. */
    buffer->metadata = xzpnew(metadata_list);
84200e02:	c3 20       	r1 = Null + 3;
84200e04:	02 2a       	r0 = Null + 24;
84200e06:	ff fd 20 f0 	call (m) 0x4f2a;
84200e0a:	25 e9 
    if (buffer->metadata == NULL)
84200e0c:	ba 8f       	M[r5 + 24] = r0;
84200e0e:	f8 61       	if EQ jump (m) Lc_rtp_create_internal_buffer_5;

84200e10 <Lc_rtp_create_internal_buffer_7>:
    {
        return NULL;
    }
    /* make the metadata circular */
    buffer->metadata->next = buffer->metadata; /*only one metadata buffer. */
84200e10:	12 8f       	M[r0 + 16] = r0;
    buffer->metadata->ref_cnt = 1;/* only one user */
84200e12:	b9 89       	rMAC = M[r5 + 24];
84200e14:	09 29       	rMAC = rMAC + 20;
84200e16:	0a e8       	r0 = M[rMAC + Null];
84200e18:	22 ff c0 1f 	r0 = r0 AND 0xffffffc0;
84200e1c:	12 c8       	r0 = r0 OR 0x1;
84200e1e:	0a ee       	M[rMAC + Null] = r0;
    BUF_DESC_METADATA_SET(buffer->descriptor);
84200e20:	79 89       	rMAC = M[r5 + 20];
84200e22:	49 ce       	rMAC = rMAC OR 0x8000;
84200e24:	79 8f       	M[r5 + 20] = rMAC;
    /* Note cbuffer_set_usable_octets will set the buffer size too. */
    cbuffer_set_usable_octets(buffer, usable_octets);
84200e26:	33 00       	r1 = r4 + Null;
84200e28:	3a 00       	r0 = r5 + Null;
84200e2a:	03 f0 21 e4 	call (m) $_cbuffer_set_usable_octets;

    return buffer;
84200e2e:	3a 00       	r0 = r5 + Null;

84200e30 <Lc_rtp_create_internal_buffer_8>:
}
84200e30:	f2 48       	popm <FP, r4, r5, rLink>;
84200e32:	d8 4c       	rts;

84200e34 <Lc_metadata_transport_with_ttp_reframe_1>:
/* Transport metadata from input to output, reframing output tags
 * to a fixed length to constrain the maximum packet size
 * This is required when using TWS with aptX input
 */
static void metadata_transport_with_ttp_reframe(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84200e34:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200e36:	11 09       	r7 = r0 + Null;
84200e38:	1a 09       	r8 = r1 + Null;
    metadata_tag *mtag_op, *mtag_ip, *mtag_ip_list = NULL;
84200e3a:	40 de       	M[FP + 32] = Null;
    unsigned b4idx, afteridx, out_tagged_octets, append_length = 0;
    TIME base_toa, base_ttp;
    ttp_status status;

    if (BUFF_METADATA(opx_data->ip_buffer))
84200e3c:	92 f0 0f 88 	r0 = M[r7 + 60];
84200e40:	51 89       	rMAC = M[r0 + 20];
84200e42:	49 c6       	rMAC = rMAC AND 0x8000;
84200e44:	08 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_3;

84200e46 <Lc_metadata_transport_with_ttp_reframe_2>:
    {
        mtag_ip_list = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
84200e46:	c5 12       	r3 = FP + 44;
84200e48:	84 12       	r2 = FP + 40;
84200e4a:	ff fd 87 f0 	call (m) 0x11d7a;
84200e4e:	31 e9 
84200e50:	42 de       	M[FP + 32] = r0;
84200e52:	02 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_4;

84200e54 <Lc_metadata_transport_with_ttp_reframe_3>:
    }
    else
    {
        b4idx = 0;
84200e54:	50 de       	M[FP + 40] = Null;

84200e56 <Lc_metadata_transport_with_ttp_reframe_4>:
    }

    /* It's not worth doing anything if the output doesn't have metadata */
    if (BUFF_METADATA(opx_data->op_buffer))
84200e56:	91 f0 10 88 	rMAC = M[r7 + 64];
84200e5a:	49 89       	rMAC = M[rMAC + 20];
84200e5c:	49 c6       	rMAC = rMAC AND 0x8000;
84200e5e:	b0 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_31;

84200e60 <Lc_metadata_transport_with_ttp_reframe_5>:
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
84200e60:	46 d8       	r4 = M[FP + 32];

84200e62 <Lc_metadata_transport_with_ttp_reframe_6>:
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
84200e62:	30 04       	Null = r4 - Null;
84200e64:	42 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_15;

84200e66 <Lc_metadata_transport_with_ttp_reframe_7>:
84200e66:	71 88       	rMAC = M[r4 + 4];
84200e68:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200e6c:	10 f0 40 24 	Null = rMAC - 64;
84200e70:	07 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_9;

84200e72 <Lc_metadata_transport_with_ttp_reframe_8>:
        {
            b4idx += mtag_ip->length;
84200e72:	f1 88       	rMAC = M[r4 + 12];
84200e74:	52 d8       	r0 = M[FP + 40];
84200e76:	51 00       	rMAC = r0 + rMAC;
84200e78:	51 de       	M[FP + 40] = rMAC;
            mtag_ip = mtag_ip->next;
84200e7a:	36 e8       	r4 = M[r4 + Null];
    /* It's not worth doing anything if the output doesn't have metadata */
    if (BUFF_METADATA(opx_data->op_buffer))
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
84200e7c:	f3 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_6;

84200e7e <Lc_metadata_transport_with_ttp_reframe_9>:
        {
            b4idx += mtag_ip->length;
            mtag_ip = mtag_ip->next;
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84200e7e:	50 d8       	Null = M[FP + 40];
84200e80:	34 62       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_15;

84200e82 <Lc_metadata_transport_with_ttp_reframe_10>:
        {
            /* If the old tag is already at the start of the input data,
             * Just use its timestamp directly
             */
            base_toa = mtag_ip->timestamp;
84200e82:	31 89       	rMAC = M[r4 + 16];
84200e84:	49 de       	M[FP + 36] = rMAC;
            L3_DBG_MSG1("RTP reframe : tag at start, ToA = %d", base_toa);
84200e86:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200e8a:	c8 24       	Null = rMAC - 3;
84200e8c:	4f 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200e8e <Lc_metadata_transport_with_ttp_reframe_11>:
84200e8e:	55 f1 02 f0 	r0 = Null + 357564917;
84200e92:	f5 41 
84200e94:	4b d8       	r1 = M[FP + 36];
84200e96:	ef fd fd ff 	call (m) 0x9b4;
84200e9a:	3f e8 

84200e9c <Lc_metadata_transport_with_ttp_reframe_12>:
        }

        if (mtag_ip != NULL)
        {
            /* Save the timestamp info from the incoming metadata */
            opx_data->last_tag_timestamp = mtag_ip->timestamp;
84200e9c:	31 89       	rMAC = M[r4 + 16];
84200e9e:	91 f0 18 8e 	M[r7 + 96] = rMAC;
            opx_data->last_toa_valid = TRUE;
84200ea2:	41 20       	rMAC = Null + 1;
84200ea4:	91 f0 19 8e 	M[r7 + 100] = rMAC;

84200ea8 <Lc_metadata_transport_with_ttp_reframe_13>:
        }

        ttp_update_ttp(opx_data->ttp_instance, base_toa, octets_copied, &status);
84200ea8:	05 13       	r3 = FP + 48;
84200eaa:	92 f0 14 88 	r0 = M[r7 + 80];
84200eae:	54 08       	r2 = r8 + Null;
84200eb0:	4b d8       	r1 = M[FP + 36];
84200eb2:	ff fd ac f0 	call (m) 0x16860;
84200eb6:	2f ed 
        base_ttp = status.ttp;
84200eb8:	eb f0 0c 88 	r9 = M[FP + 48];

        /* Distance to the first tag */
        out_tagged_octets = opx_data->max_packet_len - opx_data->last_op_tag_octets;
84200ebc:	91 f0 17 88 	rMAC = M[r7 + 92];
84200ec0:	92 f0 1a 88 	r0 = M[r7 + 104];
84200ec4:	8f 04       	r5 = rMAC - r0;

        if (out_tagged_octets >= octets_copied)
84200ec6:	af f7 00 c2 	Null = r5 - r8;
84200eca:	33 64       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_21;

84200ecc <Lc_metadata_transport_with_ttp_reframe_14>:
        {
            /* No new tag in this chunk of data */
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
84200ecc:	92 f0 10 88 	r0 = M[r7 + 64];
84200ed0:	05 00       	r3 = Null + Null;
84200ed2:	03 00       	r1 = Null + Null;
84200ed4:	54 08       	r2 = r8 + Null;
84200ed6:	ff fd 86 f0 	call (m) 0x11adc;
84200eda:	27 e0 
            opx_data->last_op_tag_octets += octets_copied;
84200edc:	91 f0 1a 88 	rMAC = M[r7 + 104];
84200ee0:	51 0c       	rMAC = r8 + rMAC;
84200ee2:	91 f0 1a 8e 	M[r7 + 104] = rMAC;
84200ee6:	6c 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_31;

84200ee8 <Lc_metadata_transport_with_ttp_reframe_15>:
            L3_DBG_MSG1("RTP reframe : tag at start, ToA = %d", base_toa);
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp if there is one */
            if (opx_data->last_toa_valid)
84200ee8:	90 f0 19 88 	Null = M[r7 + 100];
84200eec:	10 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_18;

84200eee <Lc_metadata_transport_with_ttp_reframe_16>:
            {
                base_toa = opx_data->last_tag_timestamp;
84200eee:	91 f0 18 88 	rMAC = M[r7 + 96];
84200ef2:	49 de       	M[FP + 36] = rMAC;
                L3_DBG_MSG1("RTP reframe : old ToA = %d", base_toa);
84200ef4:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200ef8:	c8 24       	Null = rMAC - 3;
84200efa:	18 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200efc <Lc_metadata_transport_with_ttp_reframe_17>:
84200efc:	55 f1 02 f0 	r0 = Null + 357564954;
84200f00:	1a 42 
84200f02:	4b d8       	r1 = M[FP + 36];
84200f04:	ef fd fd ff 	call (m) 0x9b4;
84200f08:	31 e5 
84200f0a:	10 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200f0c <Lc_metadata_transport_with_ttp_reframe_18>:
            }
            else
            {
                /* Just use the current TIMER_TIME */
                base_toa = time_get_time();
84200f0c:	ff fd 84 f1 	call (m) 0x317e8;
84200f10:	3d e6 
84200f12:	4a de       	M[FP + 36] = r0;
                L3_DBG_MSG1("RTP reframe : no tag, ToA = %d", base_toa);
84200f14:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200f18:	c8 24       	Null = rMAC - 3;
84200f1a:	08 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200f1c <Lc_metadata_transport_with_ttp_reframe_19>:
84200f1c:	55 f1 02 f0 	r0 = Null + 357564981;
84200f20:	35 42 
84200f22:	4b d8       	r1 = M[FP + 36];
84200f24:	ef fd fd ff 	call (m) 0x9b4;
84200f28:	31 e4 

84200f2a <Lc_metadata_transport_with_ttp_reframe_20>:
            }
        }

        if (mtag_ip != NULL)
84200f2a:	30 04       	Null = r4 - Null;
84200f2c:	b8 63       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_12;

84200f2e <Lc_20>:
84200f2e:	bd 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_13;

84200f30 <Lc_metadata_transport_with_ttp_reframe_21>:
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
            opx_data->last_op_tag_octets += octets_copied;
        }
        else
        {
            b4idx = out_tagged_octets;
84200f30:	57 de       	M[FP + 40] = r5;

84200f32 <Lc_metadata_transport_with_ttp_reframe_22>:

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
            {
                mtag_op = buff_metadata_new_tag();
84200f32:	ff fd 84 f0 	call (m) 0x11862;
84200f36:	31 e9 
84200f38:	16 00       	r4 = r0 + Null;

                if (mtag_op != NULL)
84200f3a:	28 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_26;

84200f3c <Lc_metadata_transport_with_ttp_reframe_23>:
                {
                    mtag_op->length = opx_data->max_packet_len;
84200f3c:	91 f0 17 88 	rMAC = M[r7 + 92];
84200f40:	f1 8e       	M[r4 + 12] = rMAC;
                    METADATA_PACKET_START_SET(mtag_op);
84200f42:	71 88       	rMAC = M[r4 + 4];
84200f44:	c9 c8       	rMAC = rMAC OR 0x4;
                    METADATA_PACKET_END_SET(mtag_op);
84200f46:	49 c9       	rMAC = rMAC OR 0x8;
84200f48:	71 8e       	M[r4 + 4] = rMAC;
                    status.ttp = ttp_get_next_timestamp(base_ttp, out_tagged_octets, opx_data->sample_rate, status.sp_adjustment);
84200f4a:	6d d8       	r3 = M[FP + 52];
84200f4c:	94 f0 16 88 	r2 = M[r7 + 88];
84200f50:	3b 00       	r1 = r5 + Null;
84200f52:	5a 08       	r0 = r9 + Null;
84200f54:	ff fd ad f0 	call (m) 0x16aa2;
84200f58:	2f ea 
84200f5a:	62 de       	M[FP + 48] = r0;
                    ttp_utils_populate_tag(mtag_op, &status);
84200f5c:	03 13       	r1 = FP + 48;
84200f5e:	32 00       	r0 = r4 + Null;
84200f60:	ef fd fc ff 	call (m) 0x8d0;
84200f64:	31 eb 
                    L3_DBG_MSG5("RTP reframe tag, ToA = %d, base = %d, TTP = %d, len = %d, offset = %d", base_toa, base_ttp, status.ttp, mtag_op->length, out_tagged_octets);
84200f66:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200f6a:	c8 24       	Null = rMAC - 3;
84200f6c:	0e 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_25;

84200f6e <Lc_metadata_transport_with_ttp_reframe_24>:
84200f6e:	39 1c       	pushm <r5>;
84200f70:	f1 88       	rMAC = M[r4 + 12];
84200f72:	09 1c       	pushm <rMAC>;
84200f74:	65 d8       	r3 = M[FP + 48];
84200f76:	55 f1 02 f0 	r0 = Null + 357565012;
84200f7a:	54 42 
84200f7c:	5c 08       	r2 = r9 + Null;
84200f7e:	4b d8       	r1 = M[FP + 36];
84200f80:	ef fd fd ff 	call (m) 0xa12;
84200f84:	33 e4 
84200f86:	7e 4c       	SP = SP + -8;

84200f88 <Lc_metadata_transport_with_ttp_reframe_25>:
                    /* Make sure only one tag gets the stream start flag */
                    status.stream_restart = FALSE;
84200f88:	78 de       	M[FP + 60] = Null;

84200f8a <Lc_metadata_transport_with_ttp_reframe_26>:
                }
                out_tagged_octets += opx_data->max_packet_len;
84200f8a:	98 f0 17 88 	r6 = M[r7 + 92];
84200f8e:	47 0c       	r5 = r6 + r5;
                if (out_tagged_octets > octets_copied)
84200f90:	af f7 00 c2 	Null = r5 - r8;
84200f94:	09 f0 8f e0 	if LS jump (m) Lc_metadata_transport_with_ttp_reframe_28;

84200f98 <Lc_metadata_transport_with_ttp_reframe_27>:
                {
                    /* Partial tag, so constrain the append to the copied amount */
                    append_length = opx_data->max_packet_len - (out_tagged_octets - octets_copied);
84200f98:	af f8 01 c0 	rMAC = r6 + r8;
84200f9c:	7f f1 08 c2 	r6 = rMAC - r5;
84200fa0:	01 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_28;

84200fa2 <Lc_metadata_transport_with_ttp_reframe_28>:
                else
                {
                    append_length = opx_data->max_packet_len;
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
84200fa2:	54 d8       	r2 = M[FP + 40];
84200fa4:	92 f0 10 88 	r0 = M[r7 + 64];
84200fa8:	45 08       	r3 = r6 + Null;
84200faa:	33 00       	r1 = r4 + Null;
84200fac:	ff fd 85 f0 	call (m) 0x11adc;
84200fb0:	31 e9 
                b4idx = 0;
84200fb2:	50 de       	M[FP + 40] = Null;
        else
        {
            b4idx = out_tagged_octets;

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
84200fb4:	af f7 00 c2 	Null = r5 - r8;
84200fb8:	bd 65       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_22;

84200fba <Lc_metadata_transport_with_ttp_reframe_30>:
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
                b4idx = 0;
            }
            opx_data->last_op_tag_octets = append_length;
84200fba:	98 f0 1a 8e 	M[r7 + 104] = r6;

84200fbe <Lc_metadata_transport_with_ttp_reframe_31>:
        }
    }
    buff_metadata_tag_list_delete(mtag_ip_list);
84200fbe:	42 d8       	r0 = M[FP + 32];
84200fc0:	ff fd 84 f0 	call (m) 0x11906;
84200fc4:	27 ea 

84200fc6 <Lc_metadata_transport_with_ttp_reframe_32>:
}
84200fc6:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200fc8:	d8 4c       	rts;

84200fca <Lc_metadata_transport_with_ttp_1>:
 * either adding time-to-play on existing tags or creating new ones if none are present
 * This is only used by the "TTP ONLY" mode with aptX, because it relies on
 * a known fixed compression ratio. This is not used in aptX HD
 */
static void metadata_transport_with_ttp(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84200fca:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200fcc:	11 09       	r7 = r0 + Null;
84200fce:	1e 00       	r4 = r1 + Null;
    metadata_tag *mtag = NULL;
    unsigned b4idx, afteridx;
    tCbuffer *buffer;
    PL_ASSERT(opx_data->codec_type == APTX);
84200fd0:	91 f0 11 80 	rMAC = MBS[r7 + 17];
84200fd4:	09 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_3;

84200fd6 <Lc_metadata_transport_with_ttp_2>:
84200fd6:	03 f0 39 48 	r1 = Null + 1081;
84200fda:	02 f0 13 60 	r0 = Null + 4115;
84200fde:	ff fd 97 f0 	call (m) 0x13f12;
84200fe2:	35 e9 
84200fe4:	70 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84200fe6 <Lc_metadata_transport_with_ttp_3>:

    if (opx_data->max_packet_len != 0)
84200fe6:	90 f0 17 88 	Null = M[r7 + 92];
84200fea:	03 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_5;

84200fec <Lc_metadata_transport_with_ttp_4>:
    {
        metadata_transport_with_ttp_reframe(opx_data, octets_copied);
84200fec:	24 4f       	call (m) Lc_metadata_transport_with_ttp_reframe_1;
        return;
84200fee:	6b 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84200ff0 <Lc_metadata_transport_with_ttp_5>:
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200ff0:	90 f0 1d 88 	Null = M[r7 + 116];
84200ff4:	04 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_7;

84200ff6 <Lc_metadata_transport_with_ttp_6>:
    {
        buffer = opx_data->u.pack.internal_buffer;
84200ff6:	9a f0 13 88 	r8 = M[r7 + 76];
84200ffa:	03 6e       	jump (m) Lc_metadata_transport_with_ttp_8;

84200ffc <Lc_metadata_transport_with_ttp_7>:
    }
    else
    {
        buffer = opx_data->op_buffer;
84200ffc:	9a f0 10 88 	r8 = M[r7 + 64];

84201000 <Lc_metadata_transport_with_ttp_8>:
    }

    if (BUFF_METADATA(opx_data->ip_buffer))
84201000:	92 f0 0f 88 	r0 = M[r7 + 60];
84201004:	51 89       	rMAC = M[r0 + 20];
84201006:	49 c6       	rMAC = rMAC AND 0x8000;
84201008:	14 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_12;

8420100a <Lc_metadata_transport_with_ttp_9>:
    {
        /* transport metadata, first (attempt to) consume tag associated with src */
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
8420100a:	05 12       	r3 = FP + 32;
8420100c:	c4 11       	r2 = FP + 28;
8420100e:	ff fd 86 f0 	call (m) 0x11d7a;
84201012:	2d eb 
84201014:	10 09       	r6 = r0 + Null;
        {
            mtag->length = octets_copied;
        }
    }

    if (mtag != NULL)
84201016:	16 62       	if NE jump (m) Lc_metadata_transport_with_ttp_14;

84201018 <Lc_metadata_transport_with_ttp_10>:
            list_samples += list_tag->length;
            list_tag = list_tag->next;
        }
    }

    if (BUFF_METADATA(buffer))
84201018:	a1 f0 05 88 	rMAC = M[r8 + 20];
8420101c:	49 c6       	rMAC = rMAC AND 0x8000;
8420101e:	4f 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_20;

84201020 <Lc_metadata_transport_with_ttp_11>:
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
84201020:	45 d8       	r3 = M[FP + 32];
84201022:	3c d8       	r2 = M[FP + 28];
84201024:	43 08       	r1 = r6 + Null;
84201026:	52 08       	r0 = r8 + Null;
84201028:	ff fd 85 f0 	call (m) 0x11adc;
8420102c:	35 e5 
8420102e:	4b 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84201030 <Lc_metadata_transport_with_ttp_12>:
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
    }
    else
    {
        /* Create a new tag for the output */
        b4idx = 0;
84201030:	38 de       	M[FP + 28] = Null;
        afteridx = octets_copied;
84201032:	46 de       	M[FP + 32] = r4;
        mtag = buff_metadata_new_tag();
84201034:	ff fd 84 f0 	call (m) 0x11862;
84201038:	2f e1 
8420103a:	10 09       	r6 = r0 + Null;
        if (mtag != NULL)
8420103c:	ee 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

8420103e <Lc_metadata_transport_with_ttp_13>:
        {
            mtag->length = octets_copied;
8420103e:	86 f0 03 8e 	M[r6 + 12] = r4;

84201042 <Lc_metadata_transport_with_ttp_14>:
    }

    if (mtag != NULL)
    {
        ttp_status status;
        metadata_tag *list_tag = mtag->next;
84201042:	87 f0 00 e8 	r5 = M[r6 + Null];
        unsigned list_samples = mtag->length;
84201046:	86 f0 03 88 	r4 = M[r6 + 12];
        unsigned time_of_arrival;

        time_of_arrival = get_time_of_arrival(mtag);
8420104a:	fd ff 3f eb 	call (m) Lc_get_time_of_arrival_1;
8420104e:	13 00       	r1 = r0 + Null;
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
84201050:	81 f0 01 88 	rMAC = M[r6 + 4];
84201054:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84201058:	81 f0 01 8e 	M[r6 + 4] = rMAC;

8420105c <Lc_metadata_transport_with_ttp_15>:

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
8420105c:	38 04       	Null = r5 - Null;
8420105e:	09 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_17;

84201060 <Lc_metadata_transport_with_ttp_16>:
        {
            METADATA_TIME_OF_ARRIVAL_UNSET(list_tag);
84201060:	79 88       	rMAC = M[r5 + 4];
84201062:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84201066:	79 8e       	M[r5 + 4] = rMAC;
            list_samples += list_tag->length;
84201068:	f9 88       	rMAC = M[r5 + 12];
8420106a:	8e 01       	r4 = rMAC + r4;
            list_tag = list_tag->next;
8420106c:	3f e8       	r5 = M[r5 + Null];
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
8420106e:	f7 6f       	jump (m) Lc_metadata_transport_with_ttp_15;

84201070 <Lc_metadata_transport_with_ttp_17>:
        }

        /* For aptX, each stereo pair of samples is encoded as one octet
         * This means the sample count for TTP is the same as the number of encoded octets
         */
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival, list_samples, &status);
84201070:	45 12       	r3 = FP + 36;
84201072:	92 f0 14 88 	r0 = M[r7 + 80];
84201076:	34 00       	r2 = r4 + Null;
84201078:	ff fd ab f0 	call (m) 0x16860;
8420107c:	29 ef 

        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
8420107e:	43 12       	r1 = FP + 36;
84201080:	42 08       	r0 = r6 + Null;
84201082:	ef fd fc ff 	call (m) 0x8d0;
84201086:	2f e2 

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84201088:	60 de       	M[FP + 48] = Null;

        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
8420108a:	86 f0 00 e8 	r4 = M[r6 + Null];
        list_samples = mtag->length;
8420108e:	87 f0 03 88 	r5 = M[r6 + 12];

84201092 <Lc_metadata_transport_with_ttp_18>:
        while (list_tag != NULL)
84201092:	30 04       	Null = r4 - Null;
84201094:	c2 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

84201096 <Lc_metadata_transport_with_ttp_19>:
        {
            status.ttp = ttp_get_next_timestamp(mtag->timestamp, list_samples, opx_data->sample_rate, status.sp_adjustment);
84201096:	55 d8       	r3 = M[FP + 40];
84201098:	94 f0 16 88 	r2 = M[r7 + 88];
8420109c:	82 f0 04 88 	r0 = M[r6 + 16];
842010a0:	3b 00       	r1 = r5 + Null;
842010a2:	ff fd ad f0 	call (m) 0x16aa2;
842010a6:	21 e0 
842010a8:	4a de       	M[FP + 36] = r0;
            ttp_utils_populate_tag(list_tag, &status);
842010aa:	43 12       	r1 = FP + 36;
842010ac:	32 00       	r0 = r4 + Null;
842010ae:	ef fd fc ff 	call (m) 0x8d0;
842010b2:	23 e1 
            list_samples += list_tag->length;
842010b4:	f1 88       	rMAC = M[r4 + 12];
842010b6:	cf 01       	r5 = rMAC + r5;
            list_tag = list_tag->next;
842010b8:	36 e8       	r4 = M[r4 + Null];
        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
        list_samples = mtag->length;
        while (list_tag != NULL)
842010ba:	ec 6f       	jump (m) Lc_metadata_transport_with_ttp_18;

842010bc <Lc_metadata_transport_with_ttp_20>:
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
    }
    else
    {
        buff_metadata_tag_list_delete(mtag);
842010bc:	42 08       	r0 = r6 + Null;
842010be:	ff fd 84 f0 	call (m) 0x11906;
842010c2:	29 e2 

842010c4 <Lc_metadata_transport_with_ttp_21>:
    }

}
842010c4:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
842010c6:	d8 4c       	rts;

842010c8 <Lc_rtp_decode_empty_internal_buffers_1>:
/**
 * Function which tries to empty the internal buffers of the RTP decode
 * by copying to output.
 */
static void rtp_decode_empty_internal_buffers(RTP_DECODE_OP_DATA *opx_data,TOUCHED_TERMINALS *touched)
{
842010c8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842010ca:	16 00       	r4 = r0 + Null;
842010cc:	1f 00       	r5 = r1 + Null;
    unsigned data;
    if (!opx_data->pack_latency_buffer)
842010ce:	70 b9       	Null = M[r4 + 116];
842010d0:	23 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

842010d2 <Lc_rtp_decode_empty_internal_buffers_2>:
    {
        return;
    }
    data = buff_metadata_available_octets(opx_data->u.pack.frame_buffer);
842010d2:	b2 a8       	r0 = M[r4 + 72];
842010d4:	ff fd 86 f0 	call (m) 0x11d04;
842010d8:	31 e1 
842010da:	14 00       	r2 = r0 + Null;
    if (data > 0)
842010dc:	0b 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_4;

842010de <Lc_rtp_decode_empty_internal_buffers_3>:
    {
        data = cbuffer_copy_ex(opx_data->u.pack.internal_buffer, opx_data->u.pack.frame_buffer, data);
842010de:	b3 a8       	r1 = M[r4 + 72];
842010e0:	f2 a8       	r0 = M[r4 + 76];
842010e2:	01 f0 37 e6 	call (m) $_cbuffer_copy_ex;
842010e6:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.frame_buffer, opx_data->u.pack.internal_buffer, data);
842010e8:	f3 a8       	r1 = M[r4 + 76];
842010ea:	b2 a8       	r0 = M[r4 + 72];
842010ec:	ff fd 87 f0 	call (m) 0x12076;
842010f0:	2b ec 

842010f2 <Lc_rtp_decode_empty_internal_buffers_4>:
    }
    data = buff_metadata_available_octets(opx_data->u.pack.internal_buffer);
842010f2:	f2 a8       	r0 = M[r4 + 76];
842010f4:	ff fd 86 f0 	call (m) 0x11d04;
842010f8:	31 e0 
842010fa:	14 00       	r2 = r0 + Null;
    if (data > 0)
842010fc:	0d 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

842010fe <Lc_rtp_decode_empty_internal_buffers_5>:
    {

        data = cbuffer_copy_ex(opx_data->op_buffer, opx_data->u.pack.internal_buffer, data);
842010fe:	f3 a8       	r1 = M[r4 + 76];
84201100:	32 a8       	r0 = M[r4 + 64];
84201102:	01 f0 37 e5 	call (m) $_cbuffer_copy_ex;
84201106:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.internal_buffer, opx_data->op_buffer, data);
84201108:	33 a8       	r1 = M[r4 + 64];
8420110a:	f2 a8       	r0 = M[r4 + 76];
8420110c:	ff fd 87 f0 	call (m) 0x12076;
84201110:	2b eb 
        /* Kick forward if there was any valid frames in the RTP packet. */
        touched->sources = TOUCHED_SOURCE_0;
84201112:	41 20       	rMAC = Null + 1;
84201114:	39 ee       	M[r5 + Null] = rMAC;

84201116 <Lc_rtp_decode_empty_internal_buffers_6>:
    }
}
84201116:	f2 48       	popm <FP, r4, r5, rLink>;
84201118:	d8 4c       	rts;

8420111a <Lc_get_AAC_codec_1>:
 *
 * \param ext_op_id Operator id.
 * \returns AAC codec needed to decode and AAC frame.
 */
static void* get_AAC_codec(unsigned ext_op_id)
{
8420111a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    OPERATOR_DATA *op_data = get_op_data_from_id(EXT_TO_INT_OPID(ext_op_id));
8420111c:	ff fd 07 f0 	call (m) 0x1f52;
84201120:	37 e1 
84201122:	ff fd 08 f0 	call (m) 0x217e;
84201126:	3d e2 
84201128:	16 00       	r4 = r0 + Null;
    if (op_data != NULL)
8420112a:	10 60       	if EQ jump (m) Lc_get_AAC_codec_5;

8420112c <Lc_get_AAC_codec_2>:
    {
        if ((base_op_get_cap_id(op_data) == CAP_ID_AAC_DECODER) || (base_op_get_cap_id(op_data) == CAP_ID_DOWNLOAD_AAC_DECODER))
8420112c:	01 f0 3b ef 	call (m) $_base_op_get_cap_id;
84201130:	10 2e       	Null = r0 - 24;
84201132:	08 60       	if EQ jump (m) Lc_get_AAC_codec_4;

84201134 <Lc_get_AAC_codec_3>:
84201134:	32 00       	r0 = r4 + Null;
84201136:	01 f0 31 ef 	call (m) $_base_op_get_cap_id;
8420113a:	01 f0 20 f0 	Null = r0 - 16463;
8420113e:	4f 24 
84201140:	05 62       	if NE jump (m) Lc_get_AAC_codec_5;

84201142 <Lc_get_AAC_codec_4>:
             * happens to be the extra op data because the decoder is the first field
             * in the structure. More details: AAC_DEC_OP_DATA first field is decoder_data
             * which first filed is codec of the type DECODER. The decoder is used to
             * decode the aac frame so if the hierarchy is not true any more this
             * function need changes. */
            return base_op_get_instance_data(op_data);
84201142:	32 00       	r0 = r4 + Null;
84201144:	01 f0 3f ee 	call (m) $_base_op_get_instance_data;
84201148:	02 6e       	jump (m) Lc_get_AAC_codec_6;

8420114a <Lc_get_AAC_codec_5>:
        }
        else
        {
            return NULL;
8420114a:	02 00       	r0 = Null + Null;

8420114c <Lc_get_AAC_codec_6>:
        }
    }
    return NULL;
}
8420114c:	f1 48       	popm <FP, r4, rLink>;
8420114e:	d8 4c       	rts;

84201150 <$_get_samples_in_packet>:
84201150:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
        fault_diatribe(FAULT_RTP_SBC_SYNC_LOST, sbc_header[0]);
    }
}

void get_samples_in_packet(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data)
{
84201152:	17 00       	r5 = r0 + Null;
84201154:	1e 00       	r4 = r1 + Null;
    tCbuffer *clone_buffer;
    unsigned payload_size;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201156:	78 b9       	Null = M[r5 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201158:	7a a8       	r0 = M[r5 + 68];
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
8420115a:	03 f0 23 e2 	call (m) $_cbuffer_calc_amount_data_ex;
    frame_data->valid = FALSE;
8420115e:	30 ee       	M[r4 + Null] = Null;

    switch (opx_data->codec_type)
84201160:	79 a0       	rMAC = MBS[r5 + 17];
84201162:	1c 60       	if EQ jump (m) Lc_get_samples_in_packet_11;

84201164 <Lc_get_samples_in_packet_2>:
84201164:	48 24       	Null = rMAC - 1;
84201166:	15 60       	if EQ jump (m) Lc_get_samples_in_packet_10;

84201168 <Lc_get_samples_in_packet_3>:
84201168:	88 24       	Null = rMAC - 2;
8420116a:	48 68       	if LT jump (m) Lc_get_samples_in_packet_21;

8420116c <Lc_get_samples_in_packet_4>:
8420116c:	c8 24       	Null = rMAC - 3;
8420116e:	4b 6c       	if LE jump (m) Lc_get_samples_in_packet_22;

84201170 <Lc_get_samples_in_packet_5>:
84201170:	08 25       	Null = rMAC - 4;
84201172:	06 62       	if NE jump (m) Lc_get_samples_in_packet_7;

84201174 <Lc_get_samples_in_packet_6>:
            frame_data->nr_of_frames = 1;
            break;
        }
        case AAC:
        {
            aac_sample_count(opx_data, payload_size, frame_data);
84201174:	34 00       	r2 = r4 + Null;
84201176:	13 00       	r1 = r0 + Null;
84201178:	3a 00       	r0 = r5 + Null;
8420117a:	47 4e       	call (m) Lc_aac_sample_count_1;
            break;
8420117c:	44 6e       	jump (m) Lc_get_samples_in_packet_22;

8420117e <Lc_get_samples_in_packet_7>:
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
    frame_data->valid = FALSE;

    switch (opx_data->codec_type)
8420117e:	48 25       	Null = rMAC - 5;
84201180:	22 60       	if EQ jump (m) Lc_get_samples_in_packet_16;

84201182 <Lc_get_samples_in_packet_8>:
84201182:	88 25       	Null = rMAC - 6;
84201184:	3b 62       	if NE jump (m) Lc_get_samples_in_packet_21;

84201186 <Lc_get_samples_in_packet_9>:
            }
            break;
        }
        case APTXADAPTIVE:
        {
            frame_data->valid = TRUE;
84201186:	41 20       	rMAC = Null + 1;
84201188:	31 ee       	M[r4 + Null] = rMAC;
            /* We don't know the number of samples yet. */
            frame_data->frame_samples = 0;
8420118a:	b0 8e       	M[r4 + 8] = Null;
            frame_data->frame_length = payload_size;
8420118c:	72 8e       	M[r4 + 4] = r0;
8420118e:	28 6e       	jump (m) Lc_get_samples_in_packet_18;

84201190 <Lc_get_samples_in_packet_10>:

    switch (opx_data->codec_type)
    {
        case SBC:
        {
            sbc_sample_count(opx_data, payload_size, frame_data);
84201190:	34 00       	r2 = r4 + Null;
84201192:	13 00       	r1 = r0 + Null;
84201194:	3a 00       	r0 = r5 + Null;
84201196:	55 4e       	call (m) Lc_sbc_sample_count_1;
            break;
84201198:	36 6e       	jump (m) Lc_get_samples_in_packet_22;

8420119a <Lc_get_samples_in_packet_11>:
        {
            break;
        }
        case APTX:
        {
            frame_data->valid = TRUE;
8420119a:	41 20       	rMAC = Null + 1;
8420119c:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptX, the generated samples is the same as the number of encoded octets,
             * as long as the input number of octets is a multiple of 4.
             * This is assumed to always be the case here. */
            payload_size = payload_size >> 2;
8420119e:	52 50       	r0 = r0 LSHIFT -2;
            payload_size = payload_size << 2;
            if (payload_size != 0)
842011a0:	52 54       	r0 = r0 LSHIFT 2;
842011a2:	05 60       	if EQ jump (m) Lc_get_samples_in_packet_13;

842011a4 <Lc_get_samples_in_packet_12>:
            {
                frame_data->frame_length = payload_size;
842011a4:	72 8e       	M[r4 + 4] = r0;
                frame_data->nr_of_frames = 1;
842011a6:	f1 8e       	M[r4 + 12] = rMAC;
                frame_data->frame_samples = payload_size;
842011a8:	b2 8e       	M[r4 + 8] = r0;
842011aa:	2d 6e       	jump (m) Lc_get_samples_in_packet_22;

842011ac <Lc_get_samples_in_packet_13>:
            }
            else
            {
                L4_DBG_MSG("RTP decode APTX classic: Not enough data to create a tag.");
842011ac:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842011b0:	08 25       	Null = rMAC - 4;
842011b2:	07 68       	if LT jump (m) Lc_get_samples_in_packet_15;

842011b4 <Lc_get_samples_in_packet_14>:
842011b4:	55 f1 02 f0 	r0 = Null + 357565331;
842011b8:	93 43 
842011ba:	ef fd fb ff 	call (m) 0x9a2;
842011be:	29 ef 

842011c0 <Lc_get_samples_in_packet_15>:
                frame_data->nr_of_frames = 0;
842011c0:	f0 8e       	M[r4 + 12] = Null;
842011c2:	21 6e       	jump (m) Lc_get_samples_in_packet_22;

842011c4 <Lc_get_samples_in_packet_16>:
            }
            break;
        }
        case APTXHD:
        {
            frame_data->valid = TRUE;
842011c4:	41 20       	rMAC = Null + 1;
842011c6:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptXHD, every 6 input octets generates 4 output samples. */
            frame_data->frame_samples = payload_size / 3;
842011c8:	c3 20       	r1 = Null + 3;
842011ca:	ff fd af f0 	call (m) 0x171b8;
842011ce:	2f ef 
            frame_data->frame_samples >>= 1;
842011d0:	12 50       	r0 = r0 LSHIFT -1;
            if (frame_data->frame_samples != 0)
842011d2:	b2 8e       	M[r4 + 8] = r0;
842011d4:	08 60       	if EQ jump (m) Lc_get_samples_in_packet_19;

842011d6 <Lc_get_samples_in_packet_17>:
            {
                frame_data->frame_length = frame_data->frame_samples * 6;
842011d6:	91 41       	rMAC = r0 * 6 (int);
842011d8:	71 8e       	M[r4 + 4] = rMAC;
                frame_data->frame_samples <<= 2;
842011da:	52 54       	r0 = r0 LSHIFT 2;
842011dc:	b2 8e       	M[r4 + 8] = r0;

842011de <Lc_get_samples_in_packet_18>:
        {
            frame_data->valid = TRUE;
            /* We don't know the number of samples yet. */
            frame_data->frame_samples = 0;
            frame_data->frame_length = payload_size;
            frame_data->nr_of_frames = 1;
842011de:	41 20       	rMAC = Null + 1;
842011e0:	f1 8e       	M[r4 + 12] = rMAC;
842011e2:	11 6e       	jump (m) Lc_get_samples_in_packet_22;

842011e4 <Lc_get_samples_in_packet_19>:
                /* If the size of the payload received is not a multiple of 6 the remaining
                 * octets will be part of the next payload. */
            }
            else
            {
                L4_DBG_MSG("RTP decode APTX hd: Not enough data to create a tag.");
842011e4:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842011e8:	08 25       	Null = rMAC - 4;
842011ea:	eb 69       	if LT jump (m) Lc_get_samples_in_packet_15;

842011ec <Lc_get_samples_in_packet_20>:
842011ec:	55 f1 02 f0 	r0 = Null + 357565389;
842011f0:	cd 43 
842011f2:	ef fd fb ff 	call (m) 0x9a2;
842011f6:	31 ed 
842011f8:	e4 6f       	jump (m) Lc_get_samples_in_packet_15;

842011fa <Lc_get_samples_in_packet_21>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
842011fa:	02 f0 7a 40 	r0 = Null + 122;
842011fe:	ff fd 96 f0 	call (m) 0x13f08;
84201202:	2b e8 

84201204 <Lc_get_samples_in_packet_22>:
            break;
        }
    }
}
84201204:	f2 48       	popm <FP, r4, r5, rLink>;
84201206:	d8 4c       	rts;

84201208 <Lc_aac_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void aac_sample_count(RTP_DECODE_OP_DATA *opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA *frame_decode_data)
{
84201208:	c8 1e       	pushm <FP(=SP), rLink>, SP = SP + 0x20;
    tCbuffer *clone_buffer;
    DECODER *aac_codec_struc = (DECODER *)opx_data->aac_codec;
8420120a:	55 89       	r3 = M[r0 + 20];
    dummy_decoder aac_decoder;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
8420120c:	50 b9       	Null = M[r0 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
8420120e:	51 a8       	rMAC = M[r0 + 68];
    }


    /* Initialise the input parameters for the codec.*/
    /* Set the  main decoder's structure.*/
    aac_decoder.codec_struc = aac_codec_struc;
84201210:	15 de       	M[FP + 8] = r3;
    /* Set the return structure. */
    aac_decoder.frame_dec_struc = frame_decode_data;
84201212:	2c de       	M[FP + 20] = r2;

    /* Set the payload size which is all the available data. */
    aac_decoder.payload_size = payload_size;
84201214:	23 de       	M[FP + 16] = r1;

    /* Set the input buffer. */
    aac_decoder.in_cbuffer = clone_buffer;
84201216:	19 de       	M[FP + 12] = rMAC;

    /* Set the bit position. */
    if ((((uintptr_t)(clone_buffer->read_ptr)) & 0x1) == 1)
    {
        /* Second octet from the word. */
        aac_decoder.bit_position = 8;
84201218:	49 88       	rMAC = M[rMAC + 4];
8420121a:	03 22       	r1 = Null + 8;
8420121c:	04 28       	r2 = Null + 16;
8420121e:	09 c0       	rMAC = rMAC AND 0x1;
84201220:	01 f3 04 c0 	if NE r2 = r1 + Null;
84201224:	34 de       	M[FP + 24] = r2;
    {
        /* First octet from the word. */
        aac_decoder.bit_position = 16;
    }

    if (opx_data->aac_utility_select == AAC_LC_OVER_LATM)
84201226:	11 b0       	rMAC = MBS[r0 + 24];
84201228:	06 62       	if NE jump (m) Lc_aac_sample_count_3;

8420122a <Lc_aac_sample_count_2>:
    {
        aacdec_samples_in_packet_lc(&aac_decoder);
8420122a:	82 10       	r0 = FP + 8;
8420122c:	ff fd f1 f2 	call 0x5f468;
84201230:	3c e1 
84201232:	05 6e       	jump (m) Lc_aac_sample_count_4;

84201234 <Lc_aac_sample_count_3>:
    }
    else
    {
        aacdec_samples_in_packet(&aac_decoder);
84201234:	82 10       	r0 = FP + 8;
84201236:	ff fd f2 f2 	call 0x5f670;
8420123a:	3a e1 

8420123c <Lc_aac_sample_count_4>:
    }

}
8420123c:	c8 4a       	SP = SP - 0x20, popm <FP, rLink>;
8420123e:	d8 4c       	rts;

84201240 <Lc_sbc_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void sbc_sample_count(RTP_DECODE_OP_DATA* opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA* frame_data)
{
84201240:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84201242:	1a 09       	r8 = r1 + Null;
84201244:	21 09       	r7 = r2 + Null;
    tCbuffer *clone_buffer;
    unsigned sbc_header[SBC_SAMPLE_COUNT_HEADER_SIZE];

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201246:	50 b9       	Null = M[r0 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201248:	53 a8       	r1 = M[r0 + 68];
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }
    /* Read and unpack the sbc header. */
    unpack_cbuff_to_array_from_offset((int*) &sbc_header, clone_buffer, 0,
            SBC_SAMPLE_COUNT_HEADER_SIZE);
8420124a:	c5 20       	r3 = Null + 3;
8420124c:	c2 11       	r0 = FP + 28;
8420124e:	04 00       	r2 = Null + Null;
84201250:	77 4e       	call (m) $_unpack_cbuff_to_array_from_offset;
    if (sbc_header[0] == SBC_HEADER0_SYNC)
84201252:	3b d8       	r1 = M[FP + 28];
84201254:	30 f0 9c 24 	Null = r1 - 156;
84201258:	4a 62       	if NE jump (m) Lc_sbc_sample_count_12;

8420125a <Lc_sbc_sample_count_2>:
    {
        unsigned mode = sbc_header[1] & SBC_HEADER1_CHANNEL_MASK;
8420125a:	42 d8       	r0 = M[FP + 32];
8420125c:	21 f0 0c 00 	rMAC = r0 AND 0xc;
        unsigned nrof_blocks = SBC_HEADER1_GET_NROF_BLOCKS(sbc_header[1]);
84201260:	d3 50       	r1 = r0 LSHIFT -4;
84201262:	9b c0       	r1 = r1 AND 0x3;
84201264:	5b 20       	r1 = r1 + 1;
84201266:	5f 54       	r5 = r1 LSHIFT 2;
        unsigned nrof_subbands = SBC_HEADER1_GET_NROF_SUBBANDS(sbc_header[1]);
84201268:	12 c0       	r0 = r0 AND 0x1;
8420126a:	52 20       	r0 = r0 + 1;
8420126c:	56 54       	r4 = r0 LSHIFT 2;
        unsigned bitpool = SBC_HEADER2_BITPOOL(sbc_header[2]);
8420126e:	4a d8       	r0 = M[FP + 36];
84201270:	92 c3       	r0 = r0 AND 0xff;
        unsigned frame_length = 0;
        unsigned sbc_frames_in_payload = 0;

        switch (mode)
84201272:	08 04       	Null = rMAC - Null;
84201274:	0d 60       	if EQ jump (m) Lc_sbc_sample_count_6;

84201276 <Lc_sbc_sample_count_3>:
84201276:	08 25       	Null = rMAC - 4;
84201278:	13 60       	if EQ jump (m) Lc_sbc_sample_count_7;

8420127a <Lc_sbc_sample_count_4>:
8420127a:	08 26       	Null = rMAC - 8;
8420127c:	19 60       	if EQ jump (m) Lc_sbc_sample_count_8;

8420127e <Lc_sbc_sample_count_5>:
            case SBC_HEADER1_CHANNEL_JOINT:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_subbands + nrof_blocks *  bitpool)) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_subbands + nrof_blocks * bitpool) + 7) / 8;
8420127e:	d1 1b       	rMAC = r0 * r5 (int);
84201280:	71 00       	rMAC = r4 + rMAC;
84201282:	ca 21       	r0 = rMAC + 7;
84201284:	92 50       	r0 = r0 LSHIFT -3;
84201286:	91 01       	rMAC = r0 + r4;
84201288:	18 f0 04 20 	r6 = rMAC + 4;
                break;
8420128c:	17 6e       	jump (m) Lc_sbc_sample_count_9;

8420128e <Lc_sbc_sample_count_6>:
            case SBC_HEADER1_CHANNEL_MONO:
            {
                /* nrof_channels = 1;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                frame_length = 4 + (nrof_subbands) / 2
                        + ((nrof_blocks * bitpool) + 7) / 8;
8420128e:	d1 1b       	rMAC = r0 * r5 (int);
84201290:	33 50       	r1 = r4 LSHIFT -1;
84201292:	ca 21       	r0 = rMAC + 7;
84201294:	92 50       	r0 = r0 LSHIFT -3;
84201296:	d1 00       	rMAC = r0 + r1;
84201298:	18 f0 04 20 	r6 = rMAC + 4;
                break;
8420129c:	0f 6e       	jump (m) Lc_sbc_sample_count_9;

8420129e <Lc_sbc_sample_count_7>:
            case SBC_HEADER1_CHANNEL_DUAL:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_blocks * 2 * bitpool) + 7) / 8;
8420129e:	3b 54       	r1 = r5 LSHIFT 1;
842012a0:	99 1a       	rMAC = r1 * r0 (int);
842012a2:	ca 21       	r0 = rMAC + 7;
842012a4:	92 50       	r0 = r0 LSHIFT -3;
842012a6:	91 01       	rMAC = r0 + r4;
842012a8:	18 f0 04 20 	r6 = rMAC + 4;
                break;
842012ac:	07 6e       	jump (m) Lc_sbc_sample_count_9;

842012ae <Lc_sbc_sample_count_8>:
            case SBC_HEADER1_CHANNEL_STEREO:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * bitpool) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_blocks * bitpool) + 7) / 8;
842012ae:	d1 1b       	rMAC = r0 * r5 (int);
842012b0:	ca 21       	r0 = rMAC + 7;
842012b2:	92 50       	r0 = r0 LSHIFT -3;
842012b4:	91 01       	rMAC = r0 + r4;
842012b6:	18 f0 04 20 	r6 = rMAC + 4;

842012ba <Lc_sbc_sample_count_9>:
                break;
            }
        }
        if (frame_length != 0)
        {
            if (payload_size % frame_length == 0)
842012ba:	52 08       	r0 = r8 + Null;
842012bc:	43 08       	r1 = r6 + Null;
842012be:	ff fd af f0 	call (m) 0x171d6;
842012c2:	39 e8 
842012c4:	10 04       	Null = r0 - Null;
842012c6:	18 62       	if NE jump (m) Lc_sbc_sample_count_13;

842012c8 <Lc_sbc_sample_count_10>:
            {
                frame_data->frame_length = frame_length;
842012c8:	98 f0 01 8e 	M[r7 + 4] = r6;
                sbc_frames_in_payload = payload_size / frame_length;
842012cc:	52 08       	r0 = r8 + Null;
842012ce:	43 08       	r1 = r6 + Null;
842012d0:	ff fd af f0 	call (m) 0x171b8;
842012d4:	29 e7 
                 * frames in the packet have different sizes. */
                sbc_frames_in_payload = 0;
            }
        }

        if (sbc_frames_in_payload != 0)
842012d6:	10 04       	Null = r0 - Null;
842012d8:	0f 60       	if EQ jump (m) Lc_sbc_sample_count_13;

842012da <Lc_sbc_sample_count_11>:
        {
            frame_data->valid = TRUE;
842012da:	41 20       	rMAC = Null + 1;
842012dc:	91 f0 00 ee 	M[r7 + Null] = rMAC;
            frame_data->nr_of_frames = sbc_frames_in_payload;
842012e0:	92 f0 03 8e 	M[r7 + 12] = r0;
            /* frame_samples =  nrof_subbands * nrof_blocks. */
            frame_data->frame_samples = nrof_subbands * nrof_blocks;
842012e4:	f1 1b       	rMAC = r4 * r5 (int);
842012e6:	91 f0 02 8e 	M[r7 + 8] = rMAC;
842012ea:	06 6e       	jump (m) Lc_sbc_sample_count_13;

842012ec <Lc_sbc_sample_count_12>:
        }
    }
    else
    {
        fault_diatribe(FAULT_RTP_SBC_SYNC_LOST, sbc_header[0]);
842012ec:	02 f0 4c 40 	r0 = Null + 76;
842012f0:	ff fd 94 f0 	call (m) 0x13bcc;
842012f4:	3d e6 

842012f6 <Lc_sbc_sample_count_13>:
    }
}
842012f6:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842012f8:	d8 4c       	rts;

842012fa <$_unpack_cbuff_to_array>:
842012fa:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
Private Function Definitions
*/

/* unpack_cbuff_to_array */
unsigned int unpack_cbuff_to_array(int *dest, tCbuffer *cbuffer_src, unsigned int amount_to_copy)
{
842012fc:	10 09       	r6 = r0 + Null;
842012fe:	1f 00       	r5 = r1 + Null;
84201300:	26 00       	r4 = r2 + Null;
    unsigned int available;
    unsigned int usable_octets;

    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
84201302:	3a 00       	r0 = r5 + Null;
84201304:	d9 4e       	call (m) $_cbuffer_get_usable_octets;
84201306:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
84201308:	3a 00       	r0 = r5 + Null;
8420130a:	02 f0 33 e4 	call (m) $_cbuffer_calc_amount_data_ex;
    if (available < amount_to_copy)
8420130e:	90 05       	Null = r0 - r4;
84201310:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_3;

84201314 <Lc_unpack_cbuff_to_array_2>:
    {
        amount_to_copy = available;
84201314:	16 00       	r4 = r0 + Null;

84201316 <Lc_unpack_cbuff_to_array_3>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
84201316:	30 04       	Null = r4 - Null;
84201318:	09 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_6;

8420131a <Lc_unpack_cbuff_to_array_4>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
8420131a:	90 f0 02 24 	Null = r7 - 2;
8420131e:	08 62       	if NE jump (m) Lc_unpack_cbuff_to_array_7;

84201320 <Lc_unpack_cbuff_to_array_5>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
84201320:	34 00       	r2 = r4 + Null;
84201322:	3b 00       	r1 = r5 + Null;
84201324:	42 08       	r0 = r6 + Null;
84201326:	01 f0 31 e0 	call (m) $_unpack_cbuff_to_array_16bit;

8420132a <Lc_unpack_cbuff_to_array_6>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
8420132a:	32 00       	r0 = r4 + Null;
8420132c:	07 6e       	jump (m) Lc_unpack_cbuff_to_array_8;

8420132e <Lc_unpack_cbuff_to_array_7>:
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_32bit(dest, cbuffer_src, amount_to_copy);
8420132e:	34 00       	r2 = r4 + Null;
84201330:	3b 00       	r1 = r5 + Null;
84201332:	42 08       	r0 = r6 + Null;
84201334:	01 f0 2f e8 	call (m) $_unpack_cbuff_to_array_32bit;
84201338:	f9 6f       	jump (m) Lc_unpack_cbuff_to_array_6;

8420133a <Lc_unpack_cbuff_to_array_8>:
    }


    return amount_to_copy;
}
8420133a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420133c:	d8 4c       	rts;

8420133e <$_unpack_cbuff_to_array_from_offset>:

/* unpack_cbuff_to_array_from_offset */
unsigned int unpack_cbuff_to_array_from_offset(int *dest, tCbuffer *cbuffer_src,
        unsigned int offset, unsigned int amount_to_copy)
{
8420133e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201340:	12 09       	r8 = r0 + Null;
84201342:	18 09       	r6 = r1 + Null;
84201344:	26 00       	r4 = r2 + Null;
84201346:	2f 00       	r5 = r3 + Null;
    unsigned int available;
    unsigned int usable_octets;

    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
84201348:	42 08       	r0 = r6 + Null;
8420134a:	b6 4e       	call (m) $_cbuffer_get_usable_octets;
8420134c:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
8420134e:	42 08       	r0 = r6 + Null;
84201350:	02 f0 2d e2 	call (m) $_cbuffer_calc_amount_data_ex;

    if (available <= offset)
84201354:	90 05       	Null = r0 - r4;
84201356:	08 f0 89 e0 	if HI jump (m) Lc_unpack_cbuff_to_array_from_offset_3;

8420135a <Lc_unpack_cbuff_to_array_from_offset_2>:
    {
        return 0;
8420135a:	02 00       	r0 = Null + Null;
8420135c:	1a 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

8420135e <Lc_unpack_cbuff_to_array_from_offset_3>:
    }

    if (available < amount_to_copy + offset)
8420135e:	b9 01       	rMAC = r5 + r4;
84201360:	50 04       	Null = r0 - rMAC;
84201362:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_from_offset_5;

84201366 <Lc_unpack_cbuff_to_array_from_offset_4>:
    {
        amount_to_copy = available - offset;
84201366:	97 05       	r5 = r0 - r4;

84201368 <Lc_unpack_cbuff_to_array_from_offset_5>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
84201368:	38 04       	Null = r5 - Null;
8420136a:	0a 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

8420136c <Lc_unpack_cbuff_to_array_from_offset_6>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
8420136c:	90 f0 02 24 	Null = r7 - 2;
84201370:	09 62       	if NE jump (m) Lc_unpack_cbuff_to_array_from_offset_9;

84201372 <Lc_unpack_cbuff_to_array_from_offset_7>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_from_offset_16bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
84201372:	35 00       	r3 = r4 + Null;
84201374:	3c 00       	r2 = r5 + Null;
84201376:	43 08       	r1 = r6 + Null;
84201378:	52 08       	r0 = r8 + Null;
8420137a:	01 f0 3d e1 	call (m) $_unpack_cbuff_to_array_from_offset_16bit;

8420137e <Lc_unpack_cbuff_to_array_from_offset_8>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
8420137e:	3a 00       	r0 = r5 + Null;
84201380:	08 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

84201382 <Lc_unpack_cbuff_to_array_from_offset_9>:
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_from_offset_32bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
84201382:	35 00       	r3 = r4 + Null;
84201384:	3c 00       	r2 = r5 + Null;
84201386:	43 08       	r1 = r6 + Null;
84201388:	52 08       	r0 = r8 + Null;
8420138a:	01 f0 3d e8 	call (m) $_unpack_cbuff_to_array_from_offset_32bit;
8420138e:	f8 6f       	jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

84201390 <Lc_unpack_cbuff_to_array_from_offset_10>:
    }
    return amount_to_copy;
}
84201390:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201392:	d8 4c       	rts;

84201394 <$_cbuffer_get_read_offset_ex>:
84201394:	c8 1c       	pushm <FP(=SP), rLink>;
 */
unsigned int cbuffer_get_read_offset_ex(tCbuffer *cbuffer)
{
    int *read_ptr;

    read_ptr = cbuffer->read_ptr;
84201396:	51 88       	rMAC = M[r0 + 4];

    PL_ASSERT(!BUF_DESC_IS_REMOTE_MMU(cbuffer->descriptor) &&
              !BUF_DESC_RD_PTR_TYPE_MMU(cbuffer->descriptor));
84201398:	53 89       	r1 = M[r0 + 20];
8420139a:	5c c0       	r2 = r1 AND 0x2;
8420139c:	06 62       	if NE jump (m) Lc_cbuffer_get_read_offset_ex_4;

8420139e <Lc_cbuffer_get_read_offset_ex_2>:
8420139e:	db c0       	r1 = r1 AND 0x4;
842013a0:	04 62       	if NE jump (m) Lc_cbuffer_get_read_offset_ex_4;

842013a2 <Lc_cbuffer_get_read_offset_ex_3>:

    return ((uintptr_t)read_ptr - (uintptr_t)cbuffer->base_addr);
842013a2:	d2 88       	r0 = M[r0 + 12];
842013a4:	8a 04       	r0 = rMAC - r0;
842013a6:	07 6e       	jump (m) Lc_cbuffer_get_read_offset_ex_5;

842013a8 <Lc_cbuffer_get_read_offset_ex_4>:
    int *read_ptr;

    read_ptr = cbuffer->read_ptr;

    PL_ASSERT(!BUF_DESC_IS_REMOTE_MMU(cbuffer->descriptor) &&
              !BUF_DESC_RD_PTR_TYPE_MMU(cbuffer->descriptor));
842013a8:	c3 3a       	r1 = Null + 59;
842013aa:	02 f0 13 60 	r0 = Null + 4115;
842013ae:	ff fd 95 f0 	call (m) 0x13f12;
842013b2:	25 eb 

842013b4 <Lc_cbuffer_get_read_offset_ex_5>:

    return ((uintptr_t)read_ptr - (uintptr_t)cbuffer->base_addr);
}
842013b4:	c8 48       	popm <FP, rLink>;
842013b6:	d8 4c       	rts;

842013b8 <$_cbuffer_copy_ex>:
 *      The number of copied octets. (NOTE: the ASM implementation does not
 *      return the copied octets)
 */
unsigned cbuffer_copy_ex(tCbuffer * dst, tCbuffer *src, unsigned num_octets);
unsigned cbuffer_copy_ex(tCbuffer * dst, tCbuffer *src, unsigned num_octets)
{
842013b8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842013ba:	11 09       	r7 = r0 + Null;
842013bc:	1f 00       	r5 = r1 + Null;
842013be:	22 09       	r8 = r2 + Null;
    unsigned src_data, dest_space, octets_to_copy, r_octet_offset, w_octet_offset;
    unsigned us_octets_source = cbuffer_get_usable_octets(src);
842013c0:	3a 00       	r0 = r5 + Null;
842013c2:	7a 4e       	call (m) $_cbuffer_get_usable_octets;
842013c4:	13 09       	r9 = r0 + Null;
    unsigned us_octets_dest = cbuffer_get_usable_octets(dst);
842013c6:	4a 08       	r0 = r7 + Null;
842013c8:	77 4e       	call (m) $_cbuffer_get_usable_octets;
842013ca:	10 09       	r6 = r0 + Null;

    /* Only 2 or 4 usable octets are supported. */
    PL_ASSERT((us_octets_source == 2) || (us_octets_source == 4));
842013cc:	b0 f0 02 24 	Null = r9 - 2;
842013d0:	04 60       	if EQ jump (m) Lc_cbuffer_copy_ex_3;

842013d2 <Lc_cbuffer_copy_ex_2>:
842013d2:	b0 f0 04 24 	Null = r9 - 4;
842013d6:	13 62       	if NE jump (m) Lc_cbuffer_copy_ex_7;

842013d8 <Lc_cbuffer_copy_ex_3>:
    PL_ASSERT((us_octets_dest == 2) || (us_octets_dest == 4));
842013d8:	80 f0 02 24 	Null = r6 - 2;
842013dc:	04 60       	if EQ jump (m) Lc_cbuffer_copy_ex_5;

842013de <Lc_cbuffer_copy_ex_4>:
842013de:	80 f0 04 24 	Null = r6 - 4;
842013e2:	15 62       	if NE jump (m) Lc_cbuffer_copy_ex_8;

842013e4 <Lc_cbuffer_copy_ex_5>:

    src_data = cbuffer_calc_amount_data_ex(src);
842013e4:	3a 00       	r0 = r5 + Null;
842013e6:	01 f0 37 ed 	call (m) $_cbuffer_calc_amount_data_ex;
842013ea:	16 00       	r4 = r0 + Null;
    dest_space = cbuffer_calc_amount_space_ex(dst);
842013ec:	4a 08       	r0 = r7 + Null;
842013ee:	01 f0 3f ef 	call (m) $_cbuffer_calc_amount_space_ex;

    octets_to_copy = MIN(src_data, num_octets);
842013f2:	af f6 00 c2 	Null = r4 - r8;
842013f6:	02 f0 a7 e0 	if C jump (m) Lc_cbuffer_copy_ex_9;

842013fa <Lc_cbuffer_copy_ex_6>:
842013fa:	12 6e       	jump (m) Lc_cbuffer_copy_ex_10;

842013fc <Lc_cbuffer_copy_ex_7>:
    unsigned src_data, dest_space, octets_to_copy, r_octet_offset, w_octet_offset;
    unsigned us_octets_source = cbuffer_get_usable_octets(src);
    unsigned us_octets_dest = cbuffer_get_usable_octets(dst);

    /* Only 2 or 4 usable octets are supported. */
    PL_ASSERT((us_octets_source == 2) || (us_octets_source == 4));
842013fc:	03 f0 94 40 	r1 = Null + 148;
84201400:	02 f0 13 60 	r0 = Null + 4115;
84201404:	ff fd 95 f0 	call (m) 0x13f12;
84201408:	2f e8 
8420140a:	4e 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420140c <Lc_cbuffer_copy_ex_8>:
    PL_ASSERT((us_octets_dest == 2) || (us_octets_dest == 4));
8420140c:	03 f0 95 40 	r1 = Null + 149;
84201410:	02 f0 13 60 	r0 = Null + 4115;
84201414:	ff fd 95 f0 	call (m) 0x13f12;
84201418:	3f e7 
8420141a:	46 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420141c <Lc_cbuffer_copy_ex_9>:

    src_data = cbuffer_calc_amount_data_ex(src);
    dest_space = cbuffer_calc_amount_space_ex(dst);

    octets_to_copy = MIN(src_data, num_octets);
8420141c:	56 08       	r4 = r8 + Null;

8420141e <Lc_cbuffer_copy_ex_10>:
    octets_to_copy = MIN(octets_to_copy, dest_space);
8420141e:	b0 04       	Null = r4 - r0;
84201420:	02 64       	if NC jump (m) Lc_cbuffer_copy_ex_12;

84201422 <Lc_cbuffer_copy_ex_11>:
84201422:	16 00       	r4 = r0 + Null;

84201424 <Lc_cbuffer_copy_ex_12>:

    if (octets_to_copy == 0)
84201424:	30 04       	Null = r4 - Null;
84201426:	03 62       	if NE jump (m) Lc_cbuffer_copy_ex_14;

84201428 <Lc_cbuffer_copy_ex_13>:
    {
        return 0;
84201428:	02 00       	r0 = Null + Null;
8420142a:	3e 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420142c <Lc_cbuffer_copy_ex_14>:
    }

    cbuffer_get_read_address_ex(src, &r_octet_offset);
8420142c:	03 12       	r1 = FP + 32;
8420142e:	3a 00       	r0 = r5 + Null;
84201430:	01 f0 25 e8 	call (m) $_cbuffer_get_read_address_ex;
    cbuffer_get_write_address_ex(dst, &w_octet_offset);
84201434:	43 12       	r1 = FP + 36;
84201436:	4a 08       	r0 = r7 + Null;
84201438:	01 f0 2f ea 	call (m) $_cbuffer_get_write_address_ex;

    if(us_octets_source == 2)
8420143c:	b0 f0 02 24 	Null = r9 - 2;
84201440:	1a 62       	if NE jump (m) Lc_cbuffer_copy_ex_20;

84201442 <Lc_cbuffer_copy_ex_15>:
    {
        if(us_octets_dest == 2)
84201442:	80 f0 02 24 	Null = r6 - 2;
84201446:	11 62       	if NE jump (m) Lc_cbuffer_copy_ex_19;

84201448 <Lc_cbuffer_copy_ex_16>:
        {
            /* the unaligned version is MIPS heavier, so keep the aligned variant separate */
           if (r_octet_offset == w_octet_offset)
84201448:	41 d8       	rMAC = M[FP + 32];
8420144a:	4a d8       	r0 = M[FP + 36];
8420144c:	88 04       	Null = rMAC - r0;
8420144e:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_18;

84201450 <Lc_cbuffer_copy_ex_17>:
           {
               cbuffer_copy_aligned_16bit_be_zero_shift_ex(dst, src, octets_to_copy);
84201450:	34 00       	r2 = r4 + Null;
84201452:	3b 00       	r1 = r5 + Null;
84201454:	4a 08       	r0 = r7 + Null;
84201456:	02 f0 25 e9 	call (m) $_cbuffer_copy_aligned_16bit_be_zero_shift_ex;
8420145a:	25 6e       	jump (m) Lc_cbuffer_copy_ex_25;

8420145c <Lc_cbuffer_copy_ex_18>:
           }
           else
           {
               cbuffer_copy_unaligned_16bit_be_zero_shift_ex(dst, src, octets_to_copy);
8420145c:	34 00       	r2 = r4 + Null;
8420145e:	3b 00       	r1 = r5 + Null;
84201460:	4a 08       	r0 = r7 + Null;
84201462:	02 f0 3d ed 	call (m) $_cbuffer_copy_unaligned_16bit_be_zero_shift_ex;
84201466:	1f 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201468 <Lc_cbuffer_copy_ex_19>:
           }
        }
        else
        {
            cbuffer_copy_unpacked_to_packed_ex(dst, src, octets_to_copy);
84201468:	34 00       	r2 = r4 + Null;
8420146a:	3b 00       	r1 = r5 + Null;
8420146c:	4a 08       	r0 = r7 + Null;
8420146e:	04 f0 2d e6 	call (m) $_cbuffer_copy_unpacked_to_packed_ex;
84201472:	19 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201474 <Lc_cbuffer_copy_ex_20>:
        }
    }
    else
    {
        if(us_octets_dest == 2)
84201474:	80 f0 02 24 	Null = r6 - 2;
84201478:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_22;

8420147a <Lc_cbuffer_copy_ex_21>:
        {
            cbuffer_copy_packed_to_unpacked_ex(dst, src, octets_to_copy);
8420147a:	34 00       	r2 = r4 + Null;
8420147c:	3b 00       	r1 = r5 + Null;
8420147e:	4a 08       	r0 = r7 + Null;
84201480:	04 f0 31 ed 	call (m) $_cbuffer_copy_packed_to_unpacked_ex;
84201484:	10 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201486 <Lc_cbuffer_copy_ex_22>:
        }
        else
        {
            /* the unaligned version is MIPS heavier, so keep the aligned variant separate */
            if (r_octet_offset == w_octet_offset)
84201486:	41 d8       	rMAC = M[FP + 32];
84201488:	4a d8       	r0 = M[FP + 36];
8420148a:	88 04       	Null = rMAC - r0;
8420148c:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_24;

8420148e <Lc_cbuffer_copy_ex_23>:
            {
                cbuffer_copy_aligned_32bit_be_zero_shift_ex(dst, src, octets_to_copy);
8420148e:	34 00       	r2 = r4 + Null;
84201490:	3b 00       	r1 = r5 + Null;
84201492:	4a 08       	r0 = r7 + Null;
84201494:	03 f0 37 e3 	call (m) $_cbuffer_copy_aligned_32bit_be_zero_shift_ex;
84201498:	06 6e       	jump (m) Lc_cbuffer_copy_ex_25;

8420149a <Lc_cbuffer_copy_ex_24>:
            }
            else
            {
                cbuffer_copy_unaligned_32bit_be_zero_shift_ex(dst, src, octets_to_copy);
8420149a:	34 00       	r2 = r4 + Null;
8420149c:	3b 00       	r1 = r5 + Null;
8420149e:	4a 08       	r0 = r7 + Null;
842014a0:	03 f0 3f ed 	call (m) $_cbuffer_copy_unaligned_32bit_be_zero_shift_ex;

842014a4 <Lc_cbuffer_copy_ex_25>:
            }
        }
    }

    /* TODO currently the asm implementation doesn't supply octets_copied */
    return octets_to_copy;
842014a4:	32 00       	r0 = r4 + Null;

842014a6 <Lc_cbuffer_copy_ex_26>:
}
842014a6:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842014a8:	d8 4c       	rts;

842014aa <$_cbuffer_set_usable_octets>:
    usable_octets = buff_metadata_get_usable_octets(buff);
    return (usable_octets == 0 ? 4 : usable_octets);
}

void cbuffer_set_usable_octets(tCbuffer *buff, unsigned usable_octets)
{
842014aa:	c8 1c       	pushm <FP(=SP), rLink>;
    buff_metadata_set_usable_octets(buff, usable_octets);
842014ac:	ff fd 83 f0 	call (m) 0x11c28;
842014b0:	3d eb 

842014b2 <Lc_cbuffer_set_usable_octets_2>:
}
842014b2:	c8 48       	popm <FP, rLink>;
842014b4:	d8 4c       	rts;

842014b6 <$_cbuffer_get_usable_octets>:

/****************************************************************************
Public Function Definitions
*/
unsigned cbuffer_get_usable_octets(tCbuffer *buff)
{
842014b6:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned usable_octets;
    usable_octets = buff_metadata_get_usable_octets(buff);
842014b8:	ff fd 83 f0 	call (m) 0x11c9a;
842014bc:	23 ef 
    return (usable_octets == 0 ? 4 : usable_octets);
842014be:	10 04       	Null = r0 - Null;
842014c0:	03 62       	if NE jump (m) Lc_cbuffer_get_usable_octets_3;

842014c2 <Lc_cbuffer_get_usable_octets_2>:
842014c2:	02 21       	r0 = Null + 4;
842014c4:	01 6e       	jump (m) Lc_cbuffer_get_usable_octets_3;

842014c6 <Lc_cbuffer_get_usable_octets_3>:
842014c6:	c8 48       	popm <FP, rLink>;
842014c8:	d8 4c       	rts;

842014ca <$_opmgr_op_is_running>:
842014ca:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
842014cc:	10 b0       	Null = MBS[r0 + 24];
842014ce:	20 f0 41 ce 	if EQ rMAC = Null + 1;
842014d2:	0a 00       	r0 = rMAC + Null;

842014d4 <Lc_opmgr_op_is_running_2>:
842014d4:	d8 4c       	rts;

842014d6 <$_base_op_get_sched_info_ex>:
{
    return op_data->cap_data->id;
}

OP_SCHED_INFO_RSP* base_op_get_sched_info_ex(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id)
{
842014d6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842014d8:	16 00       	r4 = r0 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = xzpnew(OP_SCHED_INFO_RSP);
842014da:	c3 20       	r1 = Null + 3;
842014dc:	02 29       	r0 = Null + 20;
842014de:	ff fd 1d f0 	call (m) 0x4f2a;
842014e2:	2d e2 
    if (resp == NULL)
842014e4:	10 04       	Null = r0 - Null;
842014e6:	03 62       	if NE jump (m) Lc_base_op_get_sched_info_ex_3;

842014e8 <Lc_base_op_get_sched_info_ex_2>:
    {
        return NULL;
842014e8:	02 00       	r0 = Null + Null;
842014ea:	04 6e       	jump (m) Lc_base_op_get_sched_info_ex_4;

842014ec <Lc_base_op_get_sched_info_ex_3>:
    }

    resp->op_id = op_data->id;
842014ec:	71 88       	rMAC = M[r4 + 4];
842014ee:	11 ee       	M[r0 + Null] = rMAC;
    resp->status = STATUS_OK;
842014f0:	50 8e       	M[r0 + 4] = Null;

842014f2 <Lc_base_op_get_sched_info_ex_4>:

    return resp;
842014f2:	f1 48       	popm <FP, r4, rLink>;
842014f4:	d8 4c       	rts;

842014f6 <$_base_op_build_std_response_ex>:
    return op_data->state == OP_RUNNING;
}

/* will allocate and create a success message, with zeroed error_code field */
bool base_op_build_std_response_ex(OPERATOR_DATA *op_data, STATUS_KYMERA status, void **response_data)
{
842014f6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842014f8:	16 00       	r4 = r0 + Null;
842014fa:	1f 00       	r5 = r1 + Null;
842014fc:	20 09       	r6 = r2 + Null;
    OP_STD_RSP* resp = xzpnew(OP_STD_RSP);
842014fe:	c3 20       	r1 = Null + 3;
84201500:	02 23       	r0 = Null + 12;
84201502:	ff fd 1d f0 	call (m) 0x4f2a;
84201506:	29 e1 

    if (resp == NULL)
84201508:	10 04       	Null = r0 - Null;
8420150a:	03 62       	if NE jump (m) Lc_base_op_build_std_response_ex_3;

8420150c <Lc_base_op_build_std_response_ex_2>:
    {
        return FALSE;
8420150c:	02 00       	r0 = Null + Null;
8420150e:	08 6e       	jump (m) Lc_base_op_build_std_response_ex_4;

84201510 <Lc_base_op_build_std_response_ex_3>:
    }

    resp->op_id = op_data->id;
84201510:	71 88       	rMAC = M[r4 + 4];
84201512:	11 ee       	M[r0 + Null] = rMAC;
    resp->resp_data.err_code = 0;
84201514:	90 8e       	M[r0 + 8] = Null;
    resp->status = status;
84201516:	57 8e       	M[r0 + 4] = r5;

    *response_data = resp;
84201518:	82 f0 00 ee 	M[r6 + Null] = r0;
    return TRUE;
8420151c:	42 20       	r0 = Null + 1;

8420151e <Lc_base_op_build_std_response_ex_4>:
}
8420151e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201520:	d8 4c       	rts;

84201522 <$_base_op_get_instance_data>:

void* base_op_get_instance_data(OPERATOR_DATA *op_data)
{
    return op_data->extra_op_data;
84201522:	12 99       	r0 = M[r0 + 48];

84201524 <Lc_base_op_get_instance_data_2>:
84201524:	d8 4c       	rts;

84201526 <$_base_op_get_cap_id>:
}

CAP_ID base_op_get_cap_id(OPERATOR_DATA *op_data)
{
    return op_data->cap_data->id;
84201526:	51 89       	rMAC = M[r0 + 20];
84201528:	0a e8       	r0 = M[rMAC + Null];

8420152a <Lc_base_op_get_cap_id_2>:
8420152a:	d8 4c       	rts;

8420152c <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_rtp_decode_cap_data;
8420152c:	07 f0 02 f0 	r0 = Null + 7340032;
84201530:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84201532:	20 f0 b0 41 	Null = Null + 16816;

84201536 <$_unpack_cbuff_to_array_16bit>:
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
84201536:	29 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
8420153a:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
8420153e:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
84201540:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
84201542:	26 0b       	L4 = r2 + Null;
   push r0;
84201544:	00 f0 32 cf 	push r0;
   pop B4;
84201548:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
8420154c:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
8420154e:	e4 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
84201550:	10 0a       	I0 = r0 + Null;
   L0 = r2;
84201552:	24 0b       	L0 = r2 + Null;
   push r3;
84201554:	00 f0 35 cf 	push r3;
   pop B0;
84201558:	00 f6 3a cf 	pop B0;

   r7 =  M[FP + 3*ADDR_PER_WORD];       // copy amount
8420155c:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                           // r1 is the read offset
84201560:	18 00       	Null = r1 + Null;

   if Z jump copy_unpacked_no_read_offset;
84201562:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
84201564:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
84201568:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
8420156a:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                         // one octet was read so subtract it
8420156e:	99 f0 01 24 	r7 = r7 - 1;

84201572 <$M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset>:

   copy_unpacked_no_read_offset:

   r10 = r7 LSHIFT -1;                  // translate to words
84201572:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                           // set r0 to a constant for masking the bottom octets
84201576:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                      // read the first word
8420157a:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_loop;
8420157e:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
84201580:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
84201582:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
84201586:	23 c8 
      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
84201588:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

8420158c <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop>:
   copy_unpack_loop:

   r1 = M[I0, M2];                       // compensate for the additional read
8420158c:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
84201590:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_copy_done;
84201594:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done;

   r2 = M[I0, 0];
84201596:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
8420159a:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4,ADDR_PER_WORD] = r2;
8420159c:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

842015a0 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done>:

   copy_unpack_copy_done:


   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
842015a0:	12 d8       	r0 = M[FP + 8];
   r1 = I0;
842015a2:	83 08       	r1 = I0 + Null;
   r2 = r7 AND 0x1;                             // offset
842015a4:	94 f0 01 00 	r2 = r7 AND 0x1;
   call $cbuffer.set_read_address_ex;
842015a8:	01 f0 2b e5 	call (m) $_cbuffer_set_read_address_ex;

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
842015ac:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r5, r7, rLink>;
842015b0:	29 f2 6d e0 	popm <FP, r0, r1, r2, r5, r7, rLink>;
   rts;
842015b4:	d8 4c       	rts;

842015b6 <$_unpack_cbuff_to_array_from_offset_16bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
842015b6:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
842015ba:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
842015be:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
842015c0:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
842015c2:	26 0b       	L4 = r2 + Null;
   push r0;
842015c4:	00 f0 32 cf 	push r0;
   pop B4;
842015c8:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
842015cc:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
842015ce:	a4 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
842015d0:	10 0a       	I0 = r0 + Null;
   L0 = r2;
842015d2:	24 0b       	L0 = r2 + Null;
   push r3;
842015d4:	00 f0 35 cf 	push r3;
   pop B0;
842015d8:	00 f6 3a cf 	pop B0;

   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];        // offset input
842015dc:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842015e0:	19 0d       	r7 = r1 + r7;
   r1 = r7 AND 0x1;                     // get the new offset
842015e2:	93 f0 01 00 	r1 = r7 AND 0x1;
   r7 = r7 LSHIFT -1;                   // get the words
842015e6:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
   r7 = r7 LSHIFT LOG2_ADDR_PER_WORD;   // get the octets from words - only 16bit unpacked
842015ea:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;
   M3 = r7;
842015ee:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];  // advancing the read pointer.
842015f0:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];


   r7 =  M[FP + 3*ADDR_PER_WORD];              // copy amount
842015f4:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                                  // r1 is the read offset
842015f8:	18 00       	Null = r1 + Null;

   if Z jump copy_unpack_from_offset_no_read_offset;
842015fa:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
842015fc:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
84201600:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
84201602:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                                 // one octet copied so subtract it
84201606:	99 f0 01 24 	r7 = r7 - 1;

8420160a <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset>:

   copy_unpack_from_offset_no_read_offset:

   r10 = r7 LSHIFT -1;                          // translate to words
8420160a:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                            // set r0 to a constant for masking the bottom octets
8420160e:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                       // read the first word
84201612:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_from_offset_loop;
84201616:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
84201618:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
8420161a:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
8420161e:	23 c8 

      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
84201620:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

84201624 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop>:
   copy_unpack_from_offset_loop:

   r1 = M[I0, M2];                      // compensate for the additional read
84201624:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
84201628:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_from_offset_copy_done;
8420162c:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done;

   r2 = M[I0, 0];
8420162e:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
84201632:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4, ADDR_PER_WORD] = r2;
84201634:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

84201638 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done>:

   copy_unpack_from_offset_copy_done:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
84201638:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
8420163c:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
84201640:	d8 4c       	rts;

84201642 <$_unpack_cbuff_to_array_32bit>:
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
84201642:	0b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
   pushm <I0, I4, L0, L4>;
84201646:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
8420164a:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
8420164c:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
8420164e:	26 0b       	L4 = r2 + Null;
   push r0;
84201650:	00 f0 32 cf 	push r0;
   pop B4;
84201654:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
84201658:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
8420165a:	5e 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
8420165c:	10 0a       	I0 = r0 + Null;
   L0 = r2;
8420165e:	24 0b       	L0 = r2 + Null;
   push r3;
84201660:	00 f0 35 cf 	push r3;
   pop B0;
84201664:	00 f6 3a cf 	pop B0;

   r3 = 0x3;
84201668:	c5 20       	r3 = Null + 3;
   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
8420166a:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
8420166e:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_loop_32bit;
84201672:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit;
       r5 = r3 - r1;
84201674:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
84201676:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
84201678:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
8420167a:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
8420167e:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
84201680:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
84201682:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking;
84201686:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking;
           r1 = 0;
84201688:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];            // advance one word
8420168a:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

8420168e <$M.unpack_cbuff_to_array_c_stubs.continue_masking>:

       continue_masking:
       r2 = r2 AND r0;
8420168e:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
84201690:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

84201694 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit>:

   copy_unpack_loop_32bit:

   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];      // cbuffer_src
84201694:	12 d8       	r0 = M[FP + 8];
   r2 = r1;                           // offset
84201696:	1c 00       	r2 = r1 + Null;
   r1 = I0;
84201698:	83 08       	r1 = I0 + Null;
   call $cbuffer.set_read_address_ex;
8420169a:	dc 4e       	call (m) $_cbuffer_set_read_address_ex;

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
8420169c:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, rLink>;
842016a0:	0b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, rLink>;
   rts;
842016a4:	d8 4c       	rts;

842016a6 <$_unpack_cbuff_to_array_from_offset_32bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
842016a6:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
842016aa:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
842016ae:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
842016b0:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
842016b2:	26 0b       	L4 = r2 + Null;
   push r0;
842016b4:	00 f0 32 cf 	push r0;
   pop B4;
842016b8:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                           // cbuffer_src
842016bc:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
842016be:	2c 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
842016c0:	10 0a       	I0 = r0 + Null;
   L0 = r2;
842016c2:	24 0b       	L0 = r2 + Null;
   push r3;
842016c4:	00 f0 35 cf 	push r3;
   pop B0;
842016c8:	00 f6 3a cf 	pop B0;


   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];      // offset input
842016cc:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842016d0:	19 0d       	r7 = r1 + r7;

   r3 = 0x3;
842016d2:	c5 20       	r3 = Null + 3;
   r1 = r7 AND r3;                    // get the new offset
842016d4:	5f f9 03 c8 	r1 = r7 AND r3;

   r7 = r7 AND 0xFFFFFFFC;            // remove the offset from the octets
842016d8:	99 ff fc 1f 	r7 = r7 AND 0xfffffffc;
   M3 = r7;
842016dc:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];                    // advancing the read pointer.
842016de:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];

   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
842016e2:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
842016e6:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_from_offset_loop_32bit;
842016ea:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit;
       r5 = r3 - r1;
842016ec:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
842016ee:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
842016f0:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
842016f2:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
842016f6:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
842016f8:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
842016fa:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking_from_offset;
842016fe:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset;
           r1 = 0;
84201700:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];
84201702:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

84201706 <$M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset>:

       continue_masking_from_offset:
       r2 = r2 AND r0;
84201706:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
84201708:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

8420170c <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit>:

   copy_unpack_from_offset_loop_32bit:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
8420170c:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
84201710:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
84201714:	d8 4c       	rts;

84201716 <$cbuffer.get_read_address_ex>:
//     r1 octet offset
//     r2 size in addresses
//     r3 buffer start address
// trashed - none
$cbuffer.get_read_address_ex:
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201716:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.BUFFER_TYPE_MASK;
84201718:	18 c0       	Null = r1 AND 0x1;
    if Z jump its_a_sw_rd_ptr;
8420171a:	06 60       	if EQ jump (m) $M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr;
        Null = r1 AND $cbuffer.READ_PTR_TYPE_MASK;
8420171c:	d8 c0       	Null = r1 AND 0x4;
    if Z jump its_a_sw_rd_ptr;
8420171e:	04 60       	if EQ jump (m) $M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr;
        jump $mmu.get_read_address_local_buff_ex;
84201720:	7c ff cf f5 	jump (m) 0x2f880;
84201724:	e1 e2 

84201726 <$M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr>:

    its_a_sw_rd_ptr:
    r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
84201726:	d5 88       	r3 = M[r0 + 12];
    BUFFER_GET_SIZE_IN_ADDRS_ASM(r2, r0);
84201728:	14 88       	r2 = M[r0 + 0];
    r0 = M[r0 + $cbuffer.READ_ADDR_FIELD];
8420172a:	52 88       	r0 = M[r0 + 4];
    r1 = r0 AND BUFFER_EX_OFFSET_MASK;
8420172c:	93 c0       	r1 = r0 AND 0x3;
    BUFFER_MASK_READ_ADDR(r0);
8420172e:	22 ff fc 1f 	r0 = r0 AND 0xfffffffc;
    rts;
84201732:	d8 4c       	rts;

84201734 <$_cbuffer_get_read_address_ex>:
//in r0 cbuffer address
//in r1 pointer to octet offset
//out r0 read address
//trashed r2, r3
$_cbuffer_get_read_address_ex:
    push rLink;
84201734:	00 f0 3d cf 	push rLink;
    push r1;
84201738:	00 f0 33 cf 	push r1;
    call $cbuffer.get_read_address_ex;
8420173c:	ed 4f       	call (m) $cbuffer.get_read_address_ex;
    pop r2;
8420173e:	00 f4 34 cf 	pop r2;
    M[r2] = r1;
84201742:	03 ef       	M[Null + r2] = r1;
    pop rLink;
84201744:	00 f4 3d cf 	pop rLink;
    rts;
84201748:	d8 4c       	rts;

8420174a <$cbuffer.get_write_address_ex>:
// out r1 write octet offset
// out r2 size in locations
// out r3 base address
// trashed B0
$cbuffer.get_write_address_ex:
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
8420174a:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.BUFFER_TYPE_MASK;
8420174c:	18 c0       	Null = r1 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
8420174e:	06 60       	if EQ jump (m) $M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr;
        // mmu only if it's not a SW pointer
        Null = r1 AND $cbuffer.WRITE_PTR_TYPE_MASK;
84201750:	58 c1       	Null = r1 AND 0x8;
    if Z jump its_a_sw_wr_ptr;
84201752:	04 60       	if EQ jump (m) $M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr;
        // write address is an MMU buffer
        jump $mmu.get_write_address_local_buff_ex;
84201754:	7c ff cf f5 	jump (m) 0x2f8b0;
84201758:	dd e2 

8420175a <$M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr>:
    its_a_sw_wr_ptr:
    r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420175a:	d5 88       	r3 = M[r0 + 12];
    BUFFER_GET_SIZE_IN_ADDRS_ASM(r2, r0);
8420175c:	14 88       	r2 = M[r0 + 0];
    r0 = M[r0 + $cbuffer.WRITE_ADDR_FIELD];
8420175e:	92 88       	r0 = M[r0 + 8];
    r1 = r0 AND BUFFER_EX_OFFSET_MASK;
84201760:	93 c0       	r1 = r0 AND 0x3;
    if Z rts;
84201762:	00 fd c0 cd 	if EQ rts;
        BUFFER_MASK_WRITE_ADDR(r0);     // returns word aligned no offset
84201766:	22 ff fc 1f 	r0 = r0 AND 0xfffffffc;
        pushm <I0, L0>;
8420176a:	00 f1 41 e4 	pushm <I0, L0>;
        I0 = r0;
8420176e:	10 0a       	I0 = r0 + Null;
        L0 = r2;
84201770:	24 0b       	L0 = r2 + Null;
        push r3;
84201772:	00 f0 35 cf 	push r3;
        pop B0;
84201776:	00 f6 3a cf 	pop B0;
        r0 = M[I0, -ADDR_PER_WORD];
8420177a:	23 f0 30 c0 	Null = Null + Null, r0 = M[I0,-4];
        r0 = I0;                        // go back one word
8420177e:	82 08       	r0 = I0 + Null;
        popm <I0, L0>;
84201780:	00 f1 61 e4 	popm <I0, L0>;
        rts;
84201784:	d8 4c       	rts;

84201786 <$_cbuffer_get_write_address_ex>:
//in r0 cbuffer address
//in r1 pointer to octet offset
//out r0 true write address
//trashed r2, r3, B0
$_cbuffer_get_write_address_ex:
    push rLink;
84201786:	00 f0 3d cf 	push rLink;
    push r1;
8420178a:	00 f0 33 cf 	push r1;
    call $cbuffer.get_write_address_ex;
8420178e:	de 4f       	call (m) $cbuffer.get_write_address_ex;
    pop r2;
84201790:	00 f4 34 cf 	pop r2;
    M[r2] = r1;
84201794:	03 ef       	M[Null + r2] = r1;
    pop rLink;
84201796:	00 f4 3d cf 	pop rLink;
    rts;
8420179a:	d8 4c       	rts;

8420179c <$_cbuffer_calc_amount_data_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer.calc_amount_data_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.calc_amount_data_ex:
$_cbuffer_calc_amount_data_ex:
    pushm <r4, r5, r6, rLink>;
8420179c:	b3 1c       	pushm <r4, r5, r6, rLink>;

    BUFFER_GET_USABLE_OCTETS(r6, r0);
8420179e:	14 1c       	pushm <r0, r1, r2, r3>;
842017a0:	82 00       	r0 = Null + r0;
842017a2:	fe ff 35 e8 	call (m) $_cbuffer_get_usable_octets;
842017a6:	10 09       	r6 = r0 + Null;
842017a8:	14 48       	popm <r0, r1, r2, r3>;
    Null = r6 - ADDR_PER_WORD;         // usable_octets
842017aa:	80 f0 04 24 	Null = r6 - 4;
    if Z r6 = 0;// this function relies on 0 when usable octets is 4. Diff between stre rom and stre dev
842017ae:	00 f0 08 c0 	if EQ r6 = Null + Null;

    push r0;
842017b2:	00 f0 32 cf 	push r0;
    call $cbuffer.get_write_address_ex;
842017b6:	ca 4f       	call (m) $cbuffer.get_write_address_ex;
    r4 = r0;
842017b8:	16 00       	r4 = r0 + Null;
    r5 = r1;
842017ba:	1f 00       	r5 = r1 + Null;
    pop r0;
842017bc:	00 f4 32 cf 	pop r0;
    call $cbuffer.get_read_address_ex;
842017c0:	ab 4f       	call (m) $cbuffer.get_read_address_ex;
    // side-effect returns r2 = buffer_size
    r3 = r4 - r0;       // data = wrp - rdp
842017c2:	b5 04       	r3 = r4 - r0;
    if NEG r3 = r3 + r2;
842017c4:	44 f5 05 c0 	if NEG r3 = r3 + r2;

    r4 = -1;
842017c8:	46 24       	r4 = Null - 1;
    Null = r6;
842017ca:	40 08       	Null = r6 + Null;
    if Z jump check_if_rd_eq_wr;
842017cc:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.check_if_rd_eq_wr;
        r3 = r3 LSHIFT r4;
842017ce:	ad 17       	r3 = r3 LSHIFT r4;

842017d0 <$M.cbuffer.calc_amount_data_ex.check_if_rd_eq_wr>:

    check_if_rd_eq_wr:
    Null = r3;
842017d0:	28 00       	Null = r3 + Null;
    if Z jump rd_equals_wr;
842017d2:	04 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.rd_equals_wr;
        r0 = r3 - r1;   // subtract read octets
842017d4:	ea 04       	r0 = r3 - r1;
        r0 = r0 + r5;   // add written octets
842017d6:	ba 00       	r0 = r5 + r0;
        jump end;
842017d8:	08 6e       	jump (m) $M.cbuffer.calc_amount_data_ex.end;

842017da <$M.cbuffer.calc_amount_data_ex.rd_equals_wr>:
    rd_equals_wr:
    r0 = r5 - r1;
842017da:	fa 04       	r0 = r5 - r1;
    if POS jump end;
842017dc:	05 f0 8d e0 	if POS jump (m) $M.cbuffer.calc_amount_data_ex.end;
        // This is expected only if the buffer has an MMU write/read handle
        // For normal software buffers there will always be a gap of at least 2 octets.
        // This is because how much we allow to write into the buffer is completely
        //  under the control of SW running on the DSP.
        // For MMU buffers written to or read by other sub-systems this gap can be just 1 octet.
        Null = r6;
842017e0:	40 08       	Null = r6 + Null;
        if Z jump subtract_mmu_gap;
842017e2:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.subtract_mmu_gap;
            r2 = r2 LSHIFT r4;  // divide by ADDR_PER_WORD - transform in usable_octets size
842017e4:	a4 17       	r2 = r2 LSHIFT r4;

842017e6 <$M.cbuffer.calc_amount_data_ex.subtract_mmu_gap>:
        subtract_mmu_gap:
        r0 = r2 + r4;
842017e6:	a2 01       	r0 = r2 + r4;

842017e8 <$M.cbuffer.calc_amount_data_ex.end>:
    end:
    popm <r4, r5, r6, rLink>;
842017e8:	b3 48       	popm <r4, r5, r6, rLink>;
    rts;
842017ea:	d8 4c       	rts;

842017ec <$_cbuffer_calc_amount_space_ex>:
// only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer.calc_amount_space_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.calc_amount_space_ex:
$_cbuffer_calc_amount_space_ex:
    pushm <r4, r5, r6, rLink>;
842017ec:	b3 1c       	pushm <r4, r5, r6, rLink>;

    BUFFER_GET_USABLE_OCTETS(r6, r0);
842017ee:	14 1c       	pushm <r0, r1, r2, r3>;
842017f0:	82 00       	r0 = Null + r0;
842017f2:	fe ff 25 e6 	call (m) $_cbuffer_get_usable_octets;
842017f6:	10 09       	r6 = r0 + Null;
842017f8:	14 48       	popm <r0, r1, r2, r3>;
    Null = r6 - ADDR_PER_WORD;         // usable_octets
842017fa:	80 f0 04 24 	Null = r6 - 4;
    if Z r6 = 0;
842017fe:	00 f0 08 c0 	if EQ r6 = Null + Null;

    push r0;
84201802:	00 f0 32 cf 	push r0;
    call $cbuffer.get_write_address_ex;
84201806:	a2 4f       	call (m) $cbuffer.get_write_address_ex;
    r4 = r0;
84201808:	16 00       	r4 = r0 + Null;
    r5 = r1;
8420180a:	1f 00       	r5 = r1 + Null;

    // check if the buffer is part of an in-place chain.
    pop r0;
8420180c:	00 f4 32 cf 	pop r0;
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201810:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.IN_PLACE_MASK;
84201812:	d8 c6       	Null = r1 AND 0x10000;
    if Z jump get_rd_addr;
84201814:	04 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.get_rd_addr;
        // its_in_place
        r2 = M[r0 + $cbuffer.AUX_ADDR_FIELD];
84201816:	14 89       	r2 = M[r0 + 16];
        if NZ r0 = r2;  // use the rdp of the head of the in-place chain
84201818:	01 f4 02 c0 	if NE r0 = r2 + Null;

8420181c <$M.cbuffer.calc_amount_space_ex.get_rd_addr>:
    get_rd_addr:
    call $cbuffer.get_read_address_ex;
8420181c:	7d 4f       	call (m) $cbuffer.get_read_address_ex;
    // side-effect, the asm API returns r2 = buffer_size
    r0 = r0 - r4;               // space = rdp - wrp
8420181e:	92 05       	r0 = r0 - r4;
    if Z jump rd_equals_wr;
84201820:	09 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.rd_equals_wr;
        if NEG r0 = r0 + r2;
84201822:	44 f2 02 c0 	if NEG r0 = r0 + r2;

        Null = r6;
84201826:	40 08       	Null = r6 + Null;
        if Z jump account_for_offsets;
84201828:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.account_for_offsets;
            r0 = r0 LSHIFT -1;
8420182a:	12 50       	r0 = r0 LSHIFT -1;

8420182c <$M.cbuffer.calc_amount_space_ex.account_for_offsets>:
        account_for_offsets:
        r0 = r0 + r1;           // add read octets
8420182c:	9a 00       	r0 = r1 + r0;
        r0 = r0 - r5;           // subtract written octets
8420182e:	d2 05       	r0 = r0 - r5;
        jump end;
84201830:	08 6e       	jump (m) $M.cbuffer.calc_amount_space_ex.end;

84201832 <$M.cbuffer.calc_amount_space_ex.rd_equals_wr>:

    rd_equals_wr:
        r0 = r1 - r5;
84201832:	da 05       	r0 = r1 - r5;
        if GT r0 = -1;          /* Buffer_empty:
84201834:	3c f0 42 ce 	if GT r0 = Null - 1;
            2 octets.
            This is because how much we allow to write into the buffer is
            completely under the control of SW running on the DSP.
            For MMU buffers written to or read by hardware this gap can be
            just 1 octet. */
        Null = r6;
84201838:	40 08       	Null = r6 + Null;
        if Z jump add_octets;
8420183a:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.add_octets;
            r2 = r2 LSHIFT -1;
8420183c:	24 50       	r2 = r2 LSHIFT -1;

8420183e <$M.cbuffer.calc_amount_space_ex.add_octets>:
        add_octets:
        r0 = r0 + r2;
8420183e:	a2 00       	r0 = r2 + r0;

84201840 <$M.cbuffer.calc_amount_space_ex.end>:

    end:
    Null = r6;
84201840:	40 08       	Null = r6 + Null;
    if Z r6 = ADDR_PER_WORD;
84201842:	b0 f0 48 ce 	if EQ r6 = Null + 4;
    // space in octets -2/4, clipped to zero
    r0 = r0 - r6;
84201846:	00 f8 32 c2 	r0 = r0 - r6;
    if NEG r0 = 0;
8420184a:	04 f0 02 c0 	if NEG r0 = Null + Null;
    // it is possible that at this point r0 is zero. See note
    // in cbuffer.calc_amount_data_ex. Therefore we need to clip
    // the return value to zero so we don't return a negative value, ie: -1.


    popm <r4, r5, r6, rLink>;
8420184e:	b3 48       	popm <r4, r5, r6, rLink>;
    rts;
84201850:	d8 4c       	rts;

84201852 <$_cbuffer_set_read_address_ex>:
//trashed r3, (r10 if mmu buffer)
.MODULE $M.cbuffer.set_read_address_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.set_read_address_ex:
$_cbuffer_set_read_address_ex:
    r3 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201852:	55 89       	r3 = M[r0 + 20];
    Null = r3 AND $cbuffer.BUFFER_TYPE_MASK;
84201854:	28 c0       	Null = r3 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
84201856:	09 60       	if EQ jump (m) $M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr;
        Null = r3 AND $cbuffer.READ_PTR_TYPE_MASK;
84201858:	e8 c0       	Null = r3 AND 0x4;
        if Z jump its_a_sw_wr_ptr;
8420185a:	07 60       	if EQ jump (m) $M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr;
            r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420185c:	d5 88       	r3 = M[r0 + 12];
            r1 = r1 - r3;
8420185e:	5b 05       	r1 = r1 - r3;
            r0 = M[r0 + $cbuffer.READ_ADDR_FIELD];
84201860:	52 88       	r0 = M[r0 + 4];
            jump $mmu.set_byte_offset_from_address_ex;
84201862:	7c ff cf f5 	jump (m) 0x2f8e0;
84201866:	ff e0 

84201868 <$M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr>:

    its_a_sw_wr_ptr:
    r1 = r1 OR r2;
84201868:	1b 13       	r1 = r1 OR r2;
    M[r0 + $cbuffer.READ_ADDR_FIELD] = r1;
8420186a:	53 8e       	M[r0 + 4] = r1;
    rts;
8420186c:	d8 4c       	rts;

8420186e <$_cbuffer_set_write_address_ex>:
//trashed r3, B0, (r10 if mmu buffer)
.MODULE $M.cbuffer.set_write_address_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.set_write_address_ex:
$_cbuffer_set_write_address_ex:
    r3 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
8420186e:	55 89       	r3 = M[r0 + 20];
    Null = r3 AND $cbuffer.BUFFER_TYPE_MASK;
84201870:	28 c0       	Null = r3 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
84201872:	09 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr;
        Null = r3 AND $cbuffer.WRITE_PTR_TYPE_MASK;
84201874:	68 c1       	Null = r3 AND 0x8;
        if Z jump its_a_sw_wr_ptr;
84201876:	07 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr;
            r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
84201878:	d5 88       	r3 = M[r0 + 12];
            r1 = r1 - r3;
8420187a:	5b 05       	r1 = r1 - r3;
            r0 = M[r0 + $cbuffer.WRITE_ADDR_FIELD];
8420187c:	92 88       	r0 = M[r0 + 8];
            jump $mmu.set_byte_offset_from_address_ex;
8420187e:	7c ff cf f5 	jump (m) 0x2f8e0;
84201882:	e3 e0 

84201884 <$M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr>:

    its_a_sw_wr_ptr:
    Null = r2 AND BUFFER_EX_OFFSET_MASK;
84201884:	a0 c0       	Null = r2 AND 0x3;
    if Z jump no_round_up;
84201886:	11 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.no_round_up;
        pushm <I0, L0>;
84201888:	00 f1 41 e4 	pushm <I0, L0>;
        I0 = r1;
8420188c:	18 0a       	I0 = r1 + Null;
        BUFFER_GET_SIZE_IN_ADDRS_ASM(L0, r0);
8420188e:	2c f8 00 88 	L0 = M[r0 + 0];
        r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
84201892:	d5 88       	r3 = M[r0 + 12];
        push r3;
84201894:	00 f0 35 cf 	push r3;
        pop B0;
84201898:	00 f6 3a cf 	pop B0;
        r3 = M[I0, ADDR_PER_WORD];
8420189c:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];
        r1 = I0;
842018a0:	83 08       	r1 = I0 + Null;
        r1 = r1 OR r2;
842018a2:	1b 13       	r1 = r1 OR r2;
        popm <I0, L0>;
842018a4:	00 f1 61 e4 	popm <I0, L0>;

842018a8 <$M.cbuffer.set_write_address_ex.no_round_up>:
    no_round_up:
    M[r0 + $cbuffer.WRITE_ADDR_FIELD] = r1;
842018a8:	93 8e       	M[r0 + 8] = r1;
    rts;
842018aa:	d8 4c       	rts;

842018ac <$_cbuffer_advance_write_ptr_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer_advance_write_ptr_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.advance_write_ptr_ex:
$_cbuffer_advance_write_ptr_ex:
    push rLink;
842018ac:	00 f0 3d cf 	push rLink;
    push M0;
842018b0:	00 f1 38 cf 	push M0;
    push r4;
842018b4:	00 f0 36 cf 	push r4;
    pushm <I0, L0>;
842018b8:	00 f1 41 e4 	pushm <I0, L0>;
    pushm <r0, r1>;
842018bc:	12 1c       	pushm <r0, r1>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
842018be:	14 1c       	pushm <r0, r1, r2, r3>;
842018c0:	82 00       	r0 = Null + r0;
842018c2:	fd ff 35 ef 	call (m) $_cbuffer_get_usable_octets;
842018c6:	16 00       	r4 = r0 + Null;
842018c8:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4;         // usable_octets
842018ca:	30 00       	Null = r4 + Null;
    if Z r4 = ADDR_PER_WORD;
842018cc:	b0 f0 46 ce 	if EQ r4 = Null + 4;

    call $cbuffer.get_write_address_ex;
842018d0:	3d 4f       	call (m) $cbuffer.get_write_address_ex;
    L0 = r2;
842018d2:	24 0b       	L0 = r2 + Null;

    push r3;
842018d4:	00 f0 35 cf 	push r3;
    pop B0;
842018d8:	00 f6 3a cf 	pop B0;
    I0 = r0;
842018dc:	10 0a       	I0 = r0 + Null;
    r2 = r1;            // existing octet offset
842018de:	1c 00       	r2 = r1 + Null;
    popm <r0, r1>;      // get cbuffer address and octets to advance by
842018e0:	12 48       	popm <r0, r1>;
    r1 = r1 + r2;       // add existing octet offset and octets to advance by
842018e2:	e3 00       	r1 = r2 + r1;
    r3 = -1;
842018e4:	45 24       	r3 = Null - 1;
    r2 = r1 LSHIFT r3;  // get samples (for 16-bit unpacked)
842018e6:	5c 17       	r2 = r1 LSHIFT r3;
    Null = ADDR_PER_WORD - r4;
842018e8:	02 f6 50 c6 	Null = 4 - r4;
    if NZ jump prepare_offset_index;
842018ec:	02 62       	if NE jump (m) $M.cbuffer_advance_write_ptr_ex.prepare_offset_index;
        r2 = r2 LSHIFT r3;      // further divide by 2 for 32-bit packed
842018ee:	64 17       	r2 = r2 LSHIFT r3;

842018f0 <$M.cbuffer_advance_write_ptr_ex.prepare_offset_index>:

    prepare_offset_index:
    r2 = r2 ASHIFT LOG2_ADDR_PER_WORD;  // *4 to restore the initial write ptr without offset
842018f0:	64 5c       	r2 = r2 ASHIFT 2;
    M0 = r2;
842018f2:	20 0b       	M0 = r2 + Null;
    r4 = r4 + r3;    // mask for offset: max 1 for 16-bit and max 3 for 32-bit
842018f4:	ae 01       	r4 = r3 + r4;

    r2 = r1 AND r4; // get the offset
842018f6:	9c 11       	r2 = r1 AND r4;
    r1 = M[I0, M0];
842018f8:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

    r1 = I0;
842018fc:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_write_address_ex;
842018fe:	b8 4f       	call (m) $_cbuffer_set_write_address_ex;
    popm <I0, L0>;
84201900:	00 f1 61 e4 	popm <I0, L0>;
    pop r4;
84201904:	00 f4 36 cf 	pop r4;
    pop M0;
84201908:	00 f5 38 cf 	pop M0;
    pop rLink;
8420190c:	00 f4 3d cf 	pop rLink;
    rts;
84201910:	d8 4c       	rts;

84201912 <$_cbuffer_advance_read_ptr_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer_advance_read_ptr_ex;
   .CODESEGMENT BUFFER_PM;
$cbuffer.advance_read_ptr_ex:
$_cbuffer_advance_read_ptr_ex:
    push rLink;
84201912:	00 f0 3d cf 	push rLink;
    push r4;
84201916:	00 f0 36 cf 	push r4;
    push M0;
8420191a:	00 f1 38 cf 	push M0;
    pushm <I0, L0>;
8420191e:	00 f1 41 e4 	pushm <I0, L0>;
    pushm <r0, r1>;
84201922:	12 1c       	pushm <r0, r1>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
84201924:	14 1c       	pushm <r0, r1, r2, r3>;
84201926:	82 00       	r0 = Null + r0;
84201928:	fd ff 2f ec 	call (m) $_cbuffer_get_usable_octets;
8420192c:	16 00       	r4 = r0 + Null;
8420192e:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4;         // usable_octets
84201930:	30 00       	Null = r4 + Null;
    if Z r4 = ADDR_PER_WORD;
84201932:	b0 f0 46 ce 	if EQ r4 = Null + 4;

    call $cbuffer.get_read_address_ex;
84201936:	fe ff 21 ef 	call (m) $cbuffer.get_read_address_ex;
    L0 = r2;
8420193a:	24 0b       	L0 = r2 + Null;

    push r3;
8420193c:	00 f0 35 cf 	push r3;
    pop B0;
84201940:	00 f6 3a cf 	pop B0;
    I0 = r0;
84201944:	10 0a       	I0 = r0 + Null;
    r2 = r1;            // existing octet offset
84201946:	1c 00       	r2 = r1 + Null;
    popm <r0, r1>;      // get cbuffer address and octets to advance by
84201948:	12 48       	popm <r0, r1>;
    r1 = r1 + r2;       // add existing octet offset and octets to advance by
8420194a:	e3 00       	r1 = r2 + r1;
    r3 = -1;
8420194c:	45 24       	r3 = Null - 1;
    r2 = r4 + r3;
8420194e:	74 01       	r2 = r4 + r3;
    r2 = r1 AND r2;
84201950:	1c 11       	r2 = r1 AND r2;

    r1 = r1 LSHIFT r3;
84201952:	5b 17       	r1 = r1 LSHIFT r3;
    Null = ADDR_PER_WORD - r4;
84201954:	02 f6 50 c6 	Null = 4 - r4;
    if NZ jump set_mod_reg;
84201958:	02 62       	if NE jump (m) $M.cbuffer_advance_read_ptr_ex.set_mod_reg;
        r1 = r1 LSHIFT r3;
8420195a:	5b 17       	r1 = r1 LSHIFT r3;

8420195c <$M.cbuffer_advance_read_ptr_ex.set_mod_reg>:

    set_mod_reg:
    r1 = r1 ASHIFT LOG2_ADDR_PER_WORD;
8420195c:	5b 5c       	r1 = r1 ASHIFT 2;
    M0 = r1;
8420195e:	18 0b       	M0 = r1 + Null;
    r1 = M[I0, M0];
84201960:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];
    r1 = I0;
84201964:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201966:	76 4f       	call (m) $_cbuffer_set_read_address_ex;
    popm <I0, L0>;
84201968:	00 f1 61 e4 	popm <I0, L0>;
    pop M0;
8420196c:	00 f5 38 cf 	pop M0;
    pop r4;
84201970:	00 f4 36 cf 	pop r4;
    pop rLink;
84201974:	00 f4 3d cf 	pop rLink;
    rts;
84201978:	d8 4c       	rts;

8420197a <$_cbuffer_copy_aligned_16bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_aligned_16bit_be_zero_shift_ex:
$_cbuffer_copy_aligned_16bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, rLink>;
8420197a:	09 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, rLink>;
    pushm <I0, I4, L0, L4>;
8420197e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201982:	fe ff 29 ee 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201986:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201988:	26 0b       	L4 = r2 + Null;
    push r3;
8420198a:	00 f0 35 cf 	push r3;
    pop B4;
8420198e:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201992:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201994:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201996:	fe ff 21 ec 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
8420199a:	10 0a       	I0 = r0 + Null;
    L0 = r2;
8420199c:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
8420199e:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
842019a0:	09 62       	if NE jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
842019a2:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
842019a4:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
842019a6:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
842019a8:	82 4f       	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
842019aa:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
842019ac:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
842019ae:	b2 4f       	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
842019b0:	32 6e       	jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.cp_pop_and_exit;

842019b2 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
842019b2:	00 f0 35 cf 	push r3;
    pop B0;
842019b6:	00 f6 3a cf 	pop B0;

    r5 =  M[FP + 3*ADDR_PER_WORD];               // copy amount
842019ba:	1f d8       	r5 = M[FP + 12];
    Null = r1;                                   // r1 is the octet offset
842019bc:	18 00       	Null = r1 + Null;

    if Z jump no_offset;
842019be:	0c 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.no_offset;
        // read the second part of the word, combine it with the first one.
        r1 = M[I0, ADDR_PER_WORD];
842019c0:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        r1 = r1 AND 0xff;                        // The new octet is the LSB.
842019c4:	9b c3       	r1 = r1 AND 0xff;
        r2 = M[I4, 0];                           // Read the msb
842019c6:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND 0xff00;                      // Mask the lsb
842019ca:	44 f7 00 1f 	r2 = r2 AND 0xff00;
        r1 = r1 + r2;                            // combine it
842019ce:	e3 00       	r1 = r2 + r1;
        M[I4, ADDR_PER_WORD] = r1;               // write it to the buffer
842019d0:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;
        r5 = r5 - 1;                             // one octet already written, decrement
842019d4:	7f 24       	r5 = r5 - 1;

842019d6 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.no_offset>:
                                                 // the copy amount
    no_offset:
    r10 = r5 LSHIFT -1;                          // convert the copy amount to words
842019d6:	7f f7 dc d8 	r10 = r5 LSHIFT -1;
    if Z jump copy_aligned_write_last_octet;     // could be that only one octet we need to copy.
842019da:	0a 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_write_last_octet;
        r10 = r10 - 1;                    // decrement the amount due to the initial read and last write
842019dc:	cc f0 01 24 	r10 = r10 - 1;
        r1 = M[I0,ADDR_PER_WORD];         // initial read
842019e0:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        do copy_aligned_loop;
842019e4:	03 4c       	do (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_loop;
            r1 = M[I0,ADDR_PER_WORD],
             M[I4,ADDR_PER_WORD] = r1;    // read and write
842019e6:	b1 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], M[I4,4] = r1;

842019ea <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_loop>:
        copy_aligned_loop:
        M[I4,ADDR_PER_WORD] = r1;         // last write
842019ea:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

842019ee <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_write_last_octet>:

    copy_aligned_write_last_octet:

    Null = r5 AND 0x1;
842019ee:	38 c0       	Null = r5 AND 0x1;
    if Z jump copy_aligned_done;
842019f0:	0b 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_done;
        //read last word.
        r1 = M[I0, 0];
842019f2:	30 f0 30 c0 	Null = Null + Null, r1 = M[I0,0];
        r1 = r1 AND 0xff00;
842019f6:	33 f7 00 1f 	r1 = r1 AND 0xff00;
        r2 = M[I4,0];
842019fa:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND 0xff;
842019fe:	a4 c3       	r2 = r2 AND 0xff;
        r1 = r1 + r2;
84201a00:	e3 00       	r1 = r2 + r1;
        M[I4,0] = r1;
84201a02:	b0 f0 30 d0 	Null = Null + Null, M[I4,0] = r1;

84201a06 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_done>:

    copy_aligned_done:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201a06:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201a08:	a3 08       	r1 = I4 + Null;
    r2 = r5 AND 0x1;
84201a0a:	3c c0       	r2 = r5 AND 0x1;
    call $cbuffer.set_write_address_ex;
84201a0c:	31 4f       	call (m) $_cbuffer_set_write_address_ex;

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201a0e:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201a10:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201a12:	20 4f       	call (m) $_cbuffer_set_read_address_ex;

84201a14 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201a14:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, rLink>;
84201a18:	09 f2 6d e0 	popm <FP, r0, r1, r2, r5, rLink>;
    rts;
84201a1c:	d8 4c       	rts;

84201a1e <$_cbuffer_copy_unaligned_16bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unaligned_16bit_be_zero_shift_ex:
$_cbuffer_copy_unaligned_16bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, r6, r8, rLink>;
84201a1e:	59 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r6, r8, rLink>;
    pushm <I0, I4, L0, L4>;
84201a22:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201a26:	fe ff 25 e9 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201a2a:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201a2c:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201a2e:	18 09       	r6 = r1 + Null;
    push r3;
84201a30:	00 f0 35 cf 	push r3;
    pop B4;
84201a34:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201a38:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201a3a:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201a3c:	fe ff 3b e6 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201a40:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201a42:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201a44:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201a46:	09 62       	if NE jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201a48:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201a4a:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201a4c:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201a4e:	2f 4f       	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201a50:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201a52:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201a54:	5f 4f       	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201a56:	55 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_pop_and_exit;

84201a58 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201a58:	00 f0 35 cf 	push r3;
    pop B0;
84201a5c:	00 f6 3a cf 	pop B0;

    r3 = 0xFF;                         // mask for keeping LSByte
84201a60:	05 f0 ff 40 	r3 = Null + 255;
    r8 = 8;                            // shift value for faster access
84201a64:	42 71       	r8 = Null + 8;
    push r1;                           // save read octet offset
84201a66:	00 f0 33 cf 	push r1;
    r5 =  M[FP + 3*ADDR_PER_WORD];     // copy amount
84201a6a:	1f d8       	r5 = M[FP + 12];
    Null = r1;                         // read octet offset
84201a6c:	18 00       	Null = r1 + Null;
    if Z jump check_wr_offset;
84201a6e:	12 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.check_wr_offset;
        // unaligned: rd offset
        Null = r6;                     // check write octet offset
84201a70:	40 08       	Null = r6 + Null;
        if NZ call $error;  // same_offset should be captured by the caller
84201a72:	f1 fd 58 f1 	if NE call (m) 0x2cb9c;
84201a76:	2b e9 
                            // TODO grace fail, return octets_copied and make the caller check
        // unaligned, different offsets, rd offset (no wr offset)
        r1 = M[I0, ADDR_PER_WORD];      // read word to be copied
84201a78:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        r1 = r1 AND r3;                 // LSByte only to be mixed
84201a7c:	5b 11       	r1 = r1 AND r3;
        r1 = r1 LSHIFT r8,               // on the MSByte position
         r0 = M[I0, ADDR_PER_WORD];      // read in advance next word to be copied
84201a7e:	21 fa f3 c8 	r1 = r1 LSHIFT r8, r0 = M[I0,4];
        r2 = r0 AND r3;                 // keep LSByte to be mixed to next word
84201a82:	54 11       	r2 = r0 AND r3;
        r0 = r0 LSHIFT -8;              // on the LSByte position
84201a84:	d2 51       	r0 = r0 LSHIFT -8;
        r1 = r1 OR r0;                  // mix it
84201a86:	9b 12       	r1 = r1 OR r0;
        r2 = r2 LSHIFT r8,              // value to be mixed next on the MSByte position
         M[I4, ADDR_PER_WORD] = r1,      // write a whole word back
         r0 = M[I0, ADDR_PER_WORD];      // read next word to be copied
84201a88:	21 f0 b1 fa 	r2 = r2 LSHIFT r8, r0 = M[I0,4], M[I4,4] = r1;
84201a8c:	f4 c8 
        r5 = r5 - 2;                    // two octets already written
84201a8e:	bf 24       	r5 = r5 - 2;
        // keep in mind src buffer (rdp) runs ahead one word
        jump copy_unaligned_loop;
84201a90:	10 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.copy_unaligned_loop;

84201a92 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.check_wr_offset>:

    check_wr_offset:
        // no rd offset
        Null = r6;                           // write octet offset
84201a92:	40 08       	Null = r6 + Null;
        if Z call $error;   // same_offset should be captured by the caller TODO
84201a94:	f0 fd 58 f1 	if EQ call (m) 0x2cb9c;
84201a98:	29 e8 
            // unaligned, different offsets, no rd but wr
            r1 = M[I0, ADDR_PER_WORD],       // read word to be copied
             r0 = M[I4, 0];                   // read what's currently written
84201a9a:	20 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], r0 = M[I4,0];
            r2 = r1 AND r3;                  // keep LSByte to be mixed to next word
84201a9e:	5c 11       	r2 = r1 AND r3;
            r0 = r0 AND 0xFF00;              // mask out the LSByte of what's there
84201aa0:	22 f7 00 1f 	r0 = r0 AND 0xff00;
            r1 = r1 LSHIFT -8;               // octet to be written on LSByte position
84201aa4:	db 51       	r1 = r1 LSHIFT -8;
            r1 = r1 OR r0;                   // mix it
84201aa6:	9b 12       	r1 = r1 OR r0;
            r2 = r2 LSHIFT r8,               // value to be mixed next on the MSByte position
             M[I4, ADDR_PER_WORD] = r1,       // write it back
             r0 = M[I0, ADDR_PER_WORD];       // read next word to be copied
84201aa8:	21 f0 b1 fa 	r2 = r2 LSHIFT r8, r0 = M[I0,4], M[I4,4] = r1;
84201aac:	f4 c8 
            r5 = r5 - 1;                     // one octet already written
84201aae:	7f 24       	r5 = r5 - 1;

84201ab0 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.copy_unaligned_loop>:

        copy_unaligned_loop:
        r10 = r5 LSHIFT -1;              // convert the copy amount to words
84201ab0:	7f f7 dc d8 	r10 = r5 LSHIFT -1;
        if Z jump write_last_octet;      // could be that only one octet we need to copy.
84201ab4:	09 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop;

        // next octet to be mixed in r2 on MSByte position
        do cp_unld_loop;
84201ab6:	08 4c       	do (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop;
            r1 = r0 AND r3;              // keep LSByte to be mixed to next word
84201ab8:	53 11       	r1 = r0 AND r3;
            r0 = r0 LSHIFT -8;           // octet to be written on LSByte position
84201aba:	d2 51       	r0 = r0 LSHIFT -8;
            r0 = r0 OR r2;               // mix with octet stored in previous iteration
84201abc:	12 13       	r0 = r0 OR r2;
            r2 = r1 LSHIFT r8;            // on the MSByte position
84201abe:	af f3 c4 c8 	r2 = r1 LSHIFT r8;
            M[I4, ADDR_PER_WORD] = r0,   // write a whole word back
             r0 = M[I0, ADDR_PER_WORD];  // read next word to be copied
84201ac2:	a1 f1 32 d0 	Null = Null + Null, r0 = M[I0,4], M[I4,4] = r0;

84201ac6 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop>:
        cp_unld_loop:

    write_last_octet:
        r1 = M[I0, -ADDR_PER_WORD]; // adjust back src buffer incremented in the last loop
84201ac6:	33 f0 30 c0 	Null = Null + Null, r1 = M[I0,-4];

    Null = r5 AND 0x01;         // check if doloop has copied even number of octets
84201aca:	38 c0       	Null = r5 AND 0x1;
    if Z jump adj_src_ptr;
84201acc:	08 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.adj_src_ptr;
        r0 = M[I4, 0];          // read what's currently written
84201ace:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
        // mix with LSByte stored in last doloop iteration
        r0 = r0 AND r3;         // keep only LSByte of what's there
84201ad2:	52 11       	r0 = r0 AND r3;
        r0 = r0 OR r2;          // mix
84201ad4:	12 13       	r0 = r0 OR r2;
        M[I4,0] = r0;           // and write a whole word back
84201ad6:	a0 f0 30 d0 	Null = Null + Null, M[I4,0] = r0;
        jump upd_ptrs;
84201ada:	03 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.upd_ptrs;

84201adc <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.adj_src_ptr>:

    adj_src_ptr:
        r1 = M[I0, -ADDR_PER_WORD];   // adjust back src buffer when rdp was running ahead
84201adc:	33 f0 30 c0 	Null = Null + Null, r1 = M[I0,-4];

84201ae0 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.upd_ptrs>:

    upd_ptrs:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201ae0:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201ae2:	a3 08       	r1 = I4 + Null;
    r5 = M[FP + 3*ADDR_PER_WORD];                // copy amount
84201ae4:	1f d8       	r5 = M[FP + 12];
    r2 = r5 XOR r6;     // new offset is a combination of old one and amt_copied
84201ae6:	8f f7 84 c8 	r2 = r5 XOR r6;
    r2 = r2 AND 0x01;   // play safe, only lsb
84201aea:	24 c0       	r2 = r2 AND 0x1;
    call $cbuffer.set_write_address_ex;
84201aec:	fe ff 23 ec 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201af0:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201af2:	83 08       	r1 = I0 + Null;
    pop r2;             // restore read offset
84201af4:	00 f4 34 cf 	pop r2;
    r2 = r2 XOR r5;     // new offset is a combination of old one and amt_copied
84201af8:	e4 15       	r2 = r2 XOR r5;
    r2 = r2 AND 0x01;   // play safe, only lsb
84201afa:	24 c0       	r2 = r2 AND 0x1;
    call $cbuffer.set_read_address_ex;
84201afc:	fe ff 37 ea 	call (m) $_cbuffer_set_read_address_ex;

84201b00 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201b00:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, r6, r8, rLink>;
84201b04:	59 f2 6d e0 	popm <FP, r0, r1, r2, r5, r6, r8, rLink>;
    rts;
84201b08:	d8 4c       	rts;

84201b0a <$_cbuffer_copy_aligned_32bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_aligned_32bit_be_zero_shift_ex:
$_cbuffer_copy_aligned_32bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
84201b0a:	f9 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201b0e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r8, r0);
84201b12:	14 1c       	pushm <r0, r1, r2, r3>;
84201b14:	82 00       	r0 = Null + r0;
84201b16:	fc ff 21 ed 	call (m) $_cbuffer_get_usable_octets;
84201b1a:	12 09       	r8 = r0 + Null;
84201b1c:	14 48       	popm <r0, r1, r2, r3>;
    Null = r8 - ADDR_PER_WORD;
84201b1e:	a0 f0 04 24 	Null = r8 - 4;
    if NZ call $error;      // usable octets must be 4
84201b22:	f1 fd 58 f1 	if NE call (m) 0x2cb9c;
84201b26:	3b e3 

    // r8 = ADDR_PER_WORD;     // usable_octets
    r9 = 0xFFFFFFFF;
84201b28:	0b f0 01 24 	r9 = Null - 1;

    call $cbuffer.get_write_address_ex;
84201b2c:	fe ff 3f e0 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201b30:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201b32:	26 0b       	L4 = r2 + Null;
    push r3;
84201b34:	00 f0 35 cf 	push r3;
    pop B4;
84201b38:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201b3c:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201b3e:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201b40:	fd ff 37 ee 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201b44:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201b46:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201b48:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201b4a:	0b 62       	if NE jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201b4c:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201b4e:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201b50:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201b52:	fe ff 3b ea 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201b56:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201b58:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201b5a:	fe ff 39 ed 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201b5e:	7b 6e       	jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.cp_pop_and_exit;

84201b60 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201b60:	00 f0 35 cf 	push r3;
    pop B0;
84201b64:	00 f6 3a cf 	pop B0;

    r5 =  M[FP + 3*ADDR_PER_WORD];               // copy amount
84201b68:	1f d8       	r5 = M[FP + 12];
    Null = r1;                                   // r1 is the octet offset
84201b6a:	18 00       	Null = r1 + Null;

    if Z jump no_offset;
84201b6c:	44 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.no_offset;
        r6 = r8 - r1;
84201b6e:	3f fa 08 c2 	r6 = r8 - r1;
        Null = r5 - r6;     // check if amount of data is smaller than the space in the current word
84201b72:	8f f7 00 c2 	Null = r5 - r6;
        if POS jump amount_data_greater;
84201b76:	05 f0 cd e0 	if POS jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.amount_data_greater;
            // less data to be copied than space
            r6 = r8 - r5;
84201b7a:	7f fa 08 c2 	r6 = r8 - r5;
            r6 = r6 LSHIFT 3;
84201b7e:	01 f8 d8 d8 	r6 = r6 LSHIFT 3;
            r6 = r9 LSHIFT r6;      // mask for source in the LSB
84201b82:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

            r7 = r1 LSHIFT 3;
84201b86:	01 f3 d9 d8 	r7 = r1 LSHIFT 3;
            r7 = -r7;
84201b8a:	9f f0 09 c2 	r7 = Null - r7;
            r6 = r6 LSHIFT r7;      // mask source in the right position
84201b8e:	00 f9 f8 c8 	r6 = r6 LSHIFT r7;

            r2 = M[I0, 0];          // read the source word
84201b92:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
            r2 = r2 AND r6;
84201b96:	00 f8 34 c8 	r2 = r2 AND r6;

            r3 = M[I4, 0];          // Read the dest
84201b9a:	50 f0 30 d0 	Null = Null + Null, r3 = M[I4,0];
            r6 = r6 XOR r9;         // invert r6
84201b9e:	00 fb b8 c8 	r6 = r6 XOR r9;
            r3 = r3 AND r6;         // zero only the bits that need to be copied
84201ba2:	00 f8 35 c8 	r3 = r3 AND r6;

            r2 = r3 + r2;
84201ba6:	2c 01       	r2 = r3 + r2;

            M[I4, 0] = r2;
84201ba8:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

            r7 = r1 + r5;
84201bac:	7f f3 09 c0 	r7 = r1 + r5;
            Null = ADDR_PER_WORD - r7;
84201bb0:	02 f9 50 c6 	Null = 4 - r7;
            if NZ jump copy_aligned_done;
84201bb4:	47 62       	if NE jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;
                r7 = 0;
84201bb6:	01 09       	r7 = Null + Null;
                r3 = M[I4, ADDR_PER_WORD];
84201bb8:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];
                r3 = M[I0, ADDR_PER_WORD];
84201bbc:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];
                jump copy_aligned_done;
84201bc0:	41 6e       	jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;

84201bc2 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.amount_data_greater>:

        amount_data_greater:
        r5 = r5 - r6;               // decrement the copy amount
84201bc2:	00 f8 37 c2 	r5 = r5 - r6;
        r6 = r1 LSHIFT 3;
84201bc6:	01 f3 d8 d8 	r6 = r1 LSHIFT 3;
        r6 = -r6;
84201bca:	8f f0 08 c2 	r6 = Null - r6;
        r6 = r9 LSHIFT r6;          // mask for source
84201bce:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

        r7 = r8 - r1;
84201bd2:	3f fa 09 c2 	r7 = r8 - r1;
        r7 = r7 LSHIFT 3;
84201bd6:	01 f9 d9 d8 	r7 = r7 LSHIFT 3;
        r7 = r9 LSHIFT r7;          // mask for destination
84201bda:	9f fb c9 c8 	r7 = r9 LSHIFT r7;

        // read the second part of the word, combine it with the first one.
        r2 = M[I0, ADDR_PER_WORD];
84201bde:	41 f0 30 c0 	Null = Null + Null, r2 = M[I0,4];
        r2 = r2 AND r6;                        // The new octets are in the LSBs.
84201be2:	00 f8 34 c8 	r2 = r2 AND r6;

        r1 = M[I4, 0];                         // Read the msb
84201be6:	30 f0 30 d0 	Null = Null + Null, r1 = M[I4,0];
        r1 = r1 AND r7;                        // Mask the lsb
84201bea:	00 f9 33 c8 	r1 = r1 AND r7;
        r1 = r1 + r2;                          // combine it
84201bee:	e3 00       	r1 = r2 + r1;
        M[I4, ADDR_PER_WORD] = r1;             // write it to the buffer
84201bf0:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

84201bf4 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.no_offset>:

    no_offset:
    r7 = r5 AND 0x3;
84201bf4:	79 f0 03 00 	r7 = r5 AND 0x3;

    r10 = r5 LSHIFT -LOG2_ADDR_PER_WORD;         // convert the copy amount to words
84201bf8:	7f f7 dc c8 	r10 = r5 LSHIFT -2;
    if Z jump copy_aligned_write_last_octet;     // maybe the copy amount is less than a word
84201bfc:	0a 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_write_last_octet;
        r10 = r10 - 1;                    // decrement the amount due to the initial read and last write
84201bfe:	cc f0 01 24 	r10 = r10 - 1;
        r1 = M[I0, ADDR_PER_WORD];         // initial read
84201c02:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        do copy_aligned_loop;
84201c06:	03 4c       	do (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_loop;
            r1 = M[I0, ADDR_PER_WORD],
             M[I4, ADDR_PER_WORD] = r1;    // read and write
84201c08:	b1 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], M[I4,4] = r1;

84201c0c <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_loop>:
        copy_aligned_loop:
        M[I4, ADDR_PER_WORD] = r1;         // last write
84201c0c:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

84201c10 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_write_last_octet>:

    copy_aligned_write_last_octet:

    Null = r7;
84201c10:	48 08       	Null = r7 + Null;
    if Z jump copy_aligned_done;
84201c12:	18 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;
        r6 = r8 - r7;           // us_octets - amount_data left
84201c14:	9f fa 08 c2 	r6 = r8 - r7;
        r6 = r6 LSHIFT 3;
84201c18:	01 f8 d8 d8 	r6 = r6 LSHIFT 3;
        r6 = r9 LSHIFT r6;      // mask for source
84201c1c:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

        r8 = r7 LSHIFT 3;
84201c20:	01 f9 da d8 	r8 = r7 LSHIFT 3;
        r8 = -r8;
84201c24:	af f0 0a c2 	r8 = Null - r8;
        r8 = r9 LSHIFT r8;      // mask for destination
84201c28:	af fb ca c8 	r8 = r9 LSHIFT r8;

        r1 = M[I0, 0];
84201c2c:	30 f0 30 c0 	Null = Null + Null, r1 = M[I0,0];
        r1 = r1 AND r6;
84201c30:	00 f8 33 c8 	r1 = r1 AND r6;
        r2 = M[I4, 0];
84201c34:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r8;
84201c38:	00 fa 34 c8 	r2 = r2 AND r8;

        r1 = r1 + r2;
84201c3c:	e3 00       	r1 = r2 + r1;
        M[I4, 0] = r1;
84201c3e:	b0 f0 30 d0 	Null = Null + Null, M[I4,0] = r1;

84201c42 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done>:

    copy_aligned_done:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201c42:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201c44:	a3 08       	r1 = I4 + Null;
    r2 = r7;
84201c46:	4c 08       	r2 = r7 + Null;
    call $cbuffer.set_write_address_ex;
84201c48:	fe ff 27 e1 	call (m) $_cbuffer_set_write_address_ex;

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201c4c:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201c4e:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201c50:	fe ff 23 e0 	call (m) $_cbuffer_set_read_address_ex;

84201c54 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201c54:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
84201c58:	f9 f2 6d e0 	popm <FP, r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
    rts;
84201c5c:	d8 4c       	rts;

84201c5e <$_cbuffer_copy_unaligned_32bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_unaligned_32bit_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unaligned_32bit_be_zero_shift_ex:
$_cbuffer_copy_unaligned_32bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
84201c5e:	7d f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
    pushm <I0, I4, L0, L4>;
84201c62:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
84201c66:	14 1c       	pushm <r0, r1, r2, r3>;
84201c68:	82 00       	r0 = Null + r0;
84201c6a:	fc ff 2d e2 	call (m) $_cbuffer_get_usable_octets;
84201c6e:	16 00       	r4 = r0 + Null;
84201c70:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - ADDR_PER_WORD;
84201c72:	30 25       	Null = r4 - 4;
    if NZ call $error;
84201c74:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201c78:	29 e9 
    // r4 = ADDR_PER_WORD;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201c7a:	fd ff 31 e6 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201c7e:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201c80:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201c82:	18 09       	r6 = r1 + Null;
    push r3;
84201c84:	00 f0 35 cf 	push r3;
    pop B4;
84201c88:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201c8c:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201c8e:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201c90:	fd ff 27 e4 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201c94:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201c96:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201c98:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201c9a:	0b 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201c9c:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201c9e:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201ca0:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201ca2:	fe ff 2b e0 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201ca6:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201ca8:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201caa:	fe ff 29 e3 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201cae:	41 6e       	jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.cp_pop_and_exit;

84201cb0 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201cb0:	00 f0 35 cf 	push r3;
    pop B0;
84201cb4:	00 f6 3a cf 	pop B0;
    //push r1;                            // save read octet offset
    r7 = 0xFF; // mask for destination
84201cb8:	09 f0 ff 40 	r7 = Null + 255;
    r8 = 0xFFFFFFFF;
84201cbc:	0a f0 01 24 	r8 = Null - 1;
    r10 = M[FP + 3*ADDR_PER_WORD];        // amount of data to be copied
84201cc0:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201cc4:	2b 4c       	do (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.copy_loop;

        r2 = r4 - r1;                     // source
84201cc6:	f4 04       	r2 = r4 - r1;
        r2 = r2 - 1;
84201cc8:	64 24       	r2 = r2 - 1;
        r2 = r2 LSHIFT 3;
84201cca:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = r7 LSHIFT r2;
84201ccc:	4f f9 c4 c8 	r2 = r7 LSHIFT r2;
        r5 = M[I0, 0];
84201cd0:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;                   // octet read
84201cd4:	3f 11       	r5 = r5 AND r2;

        r2 = r1 LSHIFT 3;
84201cd6:	9c 54       	r2 = r1 LSHIFT 3;
        r5 = r5 LSHIFT r2;                // move octet read into the LSB - shift right
84201cd8:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201cda:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201cde:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;                //source octet in the right position for source
84201ce0:	7f 17       	r5 = r5 LSHIFT r3;

        r3 = r4 - r6;                     // us_octets dest
84201ce2:	8f f6 05 c2 	r3 = r4 - r6;
        r3 = r3 - 1;
84201ce6:	6d 24       	r3 = r3 - 1;
        r3 = r3 LSHIFT 3;
84201ce8:	ad 54       	r3 = r3 LSHIFT 3;
        r3 = r7 LSHIFT r3;
84201cea:	5f f9 c5 c8 	r3 = r7 LSHIFT r3;

        r3 = r3 XOR r8;                   // mask for source
84201cee:	00 fa b5 c8 	r3 = r3 XOR r8;

        r2 = M[I4, 0];
84201cf2:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;                   // protect the bits that aren't to be changed
84201cf6:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;
84201cf8:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201cfa:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201cfe:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201d00:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201d02:	04 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.check_dest_offset;
            r1 = 0;
84201d04:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201d06:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201d0a <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201d0a:	08 75       	r6 = r6 + 1;
        Null = r4 - r6;
84201d0c:	8f f6 00 c2 	Null = r4 - r6;
        if NZ jump loop_end;
84201d10:	04 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.loop_end;
            r6 = 0;
84201d12:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201d14:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201d18 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.loop_end>:
	...

84201d1a <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201d1a:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201d1c:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201d1e:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201d20:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201d22:	fd ff 2d ea 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201d26:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201d28:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201d2a:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201d2c:	fd ff 27 e9 	call (m) $_cbuffer_set_read_address_ex;

84201d30 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201d30:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
84201d34:	7d f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
    rts;
84201d38:	d8 4c       	rts;

84201d3a <$_cbuffer_copy_unpacked_to_packed_ex>:
.MODULE $M.cbuffer_copy_unpacked_to_packed_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unpacked_to_packed_ex:
$_cbuffer_copy_unpacked_to_packed_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201d3a:	fd f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201d3e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r9, r0);           // destination
84201d42:	14 1c       	pushm <r0, r1, r2, r3>;
84201d44:	82 00       	r0 = Null + r0;
84201d46:	fb ff 31 eb 	call (m) $_cbuffer_get_usable_octets;
84201d4a:	13 09       	r9 = r0 + Null;
84201d4c:	14 48       	popm <r0, r1, r2, r3>;
    Null = r9 - ADDR_PER_WORD;         // usable_octets destination
84201d4e:	b0 f0 04 24 	Null = r9 - 4;
    if NZ call $error;
84201d52:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201d56:	2b e2 
    // r9 = ADDR_PER_WORD;

    BUFFER_GET_USABLE_OCTETS(r4, r1);           //source
84201d58:	14 1c       	pushm <r0, r1, r2, r3>;
84201d5a:	1a 00       	r0 = r1 + Null;
84201d5c:	fb ff 3b ea 	call (m) $_cbuffer_get_usable_octets;
84201d60:	16 00       	r4 = r0 + Null;
84201d62:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - US_OCTETS_16BIT;
84201d64:	b0 24       	Null = r4 - 2;
    if NZ call $error;
84201d66:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201d6a:	37 e1 


    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201d6c:	fc ff 3f ee 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201d70:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201d72:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201d74:	18 09       	r6 = r1 + Null;
    push r3;
84201d76:	00 f0 35 cf 	push r3;
    pop B4;
84201d7a:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201d7e:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201d80:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201d82:	fc ff 35 ec 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201d86:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201d88:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201d8a:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201d8c:	0b 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201d8e:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201d90:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201d92:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201d94:	fd ff 39 e8 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201d98:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201d9a:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201d9c:	fd ff 37 eb 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201da0:	43 6e       	jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.cp_pop_and_exit;

84201da2 <$M.cbuffer_copy_unpacked_to_packed_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201da2:	00 f0 35 cf 	push r3;
    pop B0;
84201da6:	00 f6 3a cf 	pop B0;
    r7 = 0xFFFFFFFF;                // mask for destination
84201daa:	09 f0 01 24 	r7 = Null - 1;
    r8 = r9 - r4;                   // us_octets_dest - us_octets_source
84201dae:	6f fb 0a c2 	r8 = r9 - r4;
    r10 = M[FP + 3*ADDR_PER_WORD];  // amount of data to be copied
84201db2:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201db6:	2d 4c       	do (m) $M.cbuffer_copy_unpacked_to_packed_ex.copy_loop;

        r2 = r4 - 1;           // source
84201db8:	74 24       	r2 = r4 - 1;
        r2 = r2 - r1;
84201dba:	e4 04       	r2 = r2 - r1;
        r2 = r2 LSHIFT 3;
84201dbc:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = 0xFF LSHIFT r2;
84201dbe:	7f f4 94 de 	r2 = 0xff LSHIFT r2;
        r5 = M[I0, 0];
84201dc2:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;        // octet read
84201dc6:	3f 11       	r5 = r5 AND r2;

        r2 = r8 + r1;
84201dc8:	3f fa 04 c0 	r2 = r8 + r1;
        r2 = r2 LSHIFT 3;
84201dcc:	a4 54       	r2 = r2 LSHIFT 3;
        r5 = r5 LSHIFT r2;     // move octet read into the LSB - shift left
84201dce:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201dd0:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201dd4:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;     //source octet in the right position for source
84201dd6:	7f 17       	r5 = r5 LSHIFT r3;


        r3 = r9 - r6;          // us_octets dest
84201dd8:	8f fb 05 c2 	r3 = r9 - r6;
        r3 = r3 - 1;
84201ddc:	6d 24       	r3 = r3 - 1;
        r3 = r3 LSHIFT 3;
84201dde:	ad 54       	r3 = r3 LSHIFT 3;
        r3 = 0xFF LSHIFT r3;   // mask for octets before
84201de0:	7f f5 95 de 	r3 = 0xff LSHIFT r3;

        r3 = r3 XOR r7;
84201de4:	00 f9 b5 c8 	r3 = r3 XOR r7;

        r2 = M[I4, 0];
84201de8:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;        // mask the source
84201dec:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;          // combine octet read with the source word partially masked
84201dee:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201df0:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201df4:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201df6:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201df8:	04 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.check_dest_offset;
            r1 = 0;
84201dfa:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201dfc:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201e00 <$M.cbuffer_copy_unpacked_to_packed_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201e00:	08 75       	r6 = r6 + 1;
        Null = r9 - r6;
84201e02:	8f fb 00 c2 	Null = r9 - r6;
        if NZ jump loop_end;
84201e06:	04 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.loop_end;
            r6 = 0;
84201e08:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201e0a:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201e0e <$M.cbuffer_copy_unpacked_to_packed_ex.loop_end>:
	...

84201e10 <$M.cbuffer_copy_unpacked_to_packed_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201e10:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201e12:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201e14:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201e16:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201e18:	fd ff 37 e2 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201e1c:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201e1e:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201e20:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201e22:	fd ff 31 e1 	call (m) $_cbuffer_set_read_address_ex;

84201e26 <$M.cbuffer_copy_unpacked_to_packed_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201e26:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201e2a:	fd f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    rts;
84201e2e:	d8 4c       	rts;

84201e30 <$_cbuffer_copy_packed_to_unpacked_ex>:
.MODULE $M.cbuffer_copy_packed_to_unpacked_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_packed_to_unpacked_ex:
$_cbuffer_copy_packed_to_unpacked_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201e30:	fd f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201e34:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r9, r0);           // destination
84201e38:	14 1c       	pushm <r0, r1, r2, r3>;
84201e3a:	82 00       	r0 = Null + r0;
84201e3c:	fb ff 3b e3 	call (m) $_cbuffer_get_usable_octets;
84201e40:	13 09       	r9 = r0 + Null;
84201e42:	14 48       	popm <r0, r1, r2, r3>;
    Null = r9 - US_OCTETS_16BIT;
84201e44:	b0 f0 02 24 	Null = r9 - 2;
    if NZ call $error;
84201e48:	f1 fd 56 f1 	if NE call (m) 0x2cb9c;
84201e4c:	35 ea 

    BUFFER_GET_USABLE_OCTETS(r4, r1);           // source
84201e4e:	14 1c       	pushm <r0, r1, r2, r3>;
84201e50:	1a 00       	r0 = r1 + Null;
84201e52:	fb ff 25 e3 	call (m) $_cbuffer_get_usable_octets;
84201e56:	16 00       	r4 = r0 + Null;
84201e58:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - ADDR_PER_WORD;                                  // usable_octets destination
84201e5a:	30 25       	Null = r4 - 4;
    if NZ call $error;
84201e5c:	f1 fd 56 f1 	if NE call (m) 0x2cb9c;
84201e60:	21 ea 
    //r4 = ADDR_PER_WORD;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201e62:	fc ff 29 e7 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201e66:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201e68:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201e6a:	18 09       	r6 = r1 + Null;
    push r3;
84201e6c:	00 f0 35 cf 	push r3;
    pop B4;
84201e70:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201e74:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201e76:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201e78:	fc ff 3f e4 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201e7c:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201e7e:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201e80:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201e82:	0b 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201e84:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201e86:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201e88:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201e8a:	fd ff 23 e1 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201e8e:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201e90:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201e92:	fd ff 21 e4 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201e96:	3f 6e       	jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.cp_pop_and_exit;

84201e98 <$M.cbuffer_copy_packed_to_unpacked_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201e98:	00 f0 35 cf 	push r3;
    pop B0;
84201e9c:	00 f6 3a cf 	pop B0;
    r7 = 0xFF;
84201ea0:	09 f0 ff 40 	r7 = Null + 255;
    r8 = r9 - r4; // us_octets_dest - us_octets_source
84201ea4:	6f fb 0a c2 	r8 = r9 - r4;

    r10 = M[FP + 3*ADDR_PER_WORD];  // amount of data to be copied
84201ea8:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201eac:	29 4c       	do (m) $M.cbuffer_copy_packed_to_unpacked_ex.copy_loop;
        r2 = ADDR_PER_WORD - r1;    // source
84201eae:	02 f3 54 c6 	r2 = 4 - r1;
        r2 = r2 - 1;
84201eb2:	64 24       	r2 = r2 - 1;
        r2 = r2 LSHIFT 3;
84201eb4:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = r7 LSHIFT r2;
84201eb6:	4f f9 c4 c8 	r2 = r7 LSHIFT r2;
        r5 = M[I0, 0];
84201eba:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;             // octet read
84201ebe:	3f 11       	r5 = r5 AND r2;

        r2 = r8 + r1;               // overwritten
84201ec0:	3f fa 04 c0 	r2 = r8 + r1;
        r2 = r2 LSHIFT 3;
84201ec4:	a4 54       	r2 = r2 LSHIFT 3;
        r5 = r5 LSHIFT r2;          // move octet read into the LSB - shift left
84201ec6:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201ec8:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201ecc:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;          //source octet in the right position for source
84201ece:	7f 17       	r5 = r5 LSHIFT r3;

        r3 = -r3;
84201ed0:	45 05       	r3 = Null - r3;
        r3 = r7 LSHIFT r3;          // mask dest
84201ed2:	5f f9 c5 c8 	r3 = r7 LSHIFT r3;

        r2 = M[I4, 0];
84201ed6:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;
84201eda:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;
84201edc:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201ede:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201ee2:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201ee4:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201ee6:	04 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.check_dest_offset;
            r1 = 0;
84201ee8:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201eea:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201eee <$M.cbuffer_copy_packed_to_unpacked_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201eee:	08 75       	r6 = r6 + 1;
        Null = r9 - r6;
84201ef0:	8f fb 00 c2 	Null = r9 - r6;
        if NZ jump loop_end;
84201ef4:	04 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.loop_end;
            r6 = 0;
84201ef6:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201ef8:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201efc <$M.cbuffer_copy_packed_to_unpacked_ex.loop_end>:
	...

84201efe <$M.cbuffer_copy_packed_to_unpacked_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201efe:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201f00:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201f02:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201f04:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201f06:	fc ff 29 eb 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201f0a:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201f0c:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201f0e:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201f10:	fc ff 23 ea 	call (m) $_cbuffer_set_read_address_ex;

84201f14 <$M.cbuffer_copy_packed_to_unpacked_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201f14:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201f18:	fd f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    rts;
84201f1c:	d8 4c       	rts;
