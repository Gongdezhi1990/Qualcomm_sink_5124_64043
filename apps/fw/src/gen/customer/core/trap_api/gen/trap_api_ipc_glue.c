/*
 * This file is autogenerated from api.xml by api_codegen.py
 *
 * Copyright (c) 2019 Qualcomm Technologies International, Ltd.
 */
#include "ipc/ipc.h" 
#include "assert.h" 

#include "trap_api/boot.h" 
#include "trap_api/message.h" 
#include "trap_api/pio.h" 
#include "trap_api/os.h" 
#include "trap_api/feature.h" 
#include "trap_api/csb.h" 
#include "trap_api/status.h" 
#include "trap_api/util.h" 
#include "trap_api/led.h" 
#include "trap_api/audio_power.h" 
#include "trap_api/test.h" 
#include "trap_api/transform.h" 
#include "trap_api/audio_pwm.h" 
#include "trap_api/crypto.h" 
#include "trap_api/dormant.h" 
#include "trap_api/usb_hub.h" 
#include "trap_api/sdmmc.h" 
#include "trap_api/sram.h" 
#include "trap_api/font.h" 
#include "trap_api/operator.h" 
#include "trap_api/ps.h" 
#include "trap_api/nfc.h" 
#include "trap_api/stream.h" 
#include "trap_api/i2c.h" 
#include "trap_api/source.h" 
#include "trap_api/psu.h" 
#include "trap_api/inquiry.h" 
#include "trap_api/adc.h" 
#include "trap_api/audio_anc.h" 
#include "trap_api/bitserial_api.h" 
#include "trap_api/charger.h" 
#include "trap_api/otp.h" 
#include "trap_api/kalimba.h" 
#include "trap_api/infrared.h" 
#include "trap_api/imageupgrade.h" 
#include "trap_api/sink.h" 
#include "trap_api/native.h" 
#include "trap_api/vm.h" 
#include "trap_api/panic.h" 
#include "trap_api/capacitivesensor.h" 
#include "trap_api/file.h" 
#include "trap_api/audio_clock.h" 
#include "trap_api/codec_.h" 
#include "trap_api/voltsense.h" 
#include "trap_api/micbias.h" 
#include "trap_api/usb.h" 
#include "trap_api/lcd.h" 
#include "trap_api/partition.h" 
#include "trap_api/audio_mclk.h" 
#include "trap_api/host.h" 
#include "trap_api/energy.h" 
#include "trap_api/loader.h" 
#include "trap_api/ps.h" 
#include "trap_api/usb.h" 
#include "trap_api/micbias.h" 
#include "trap_api/audio_power.h" 
#include "trap_api/boot.h" 
#include "trap_api/transform.h" 
#include "trap_api/csb.h" 
#include "trap_api/source.h" 
#include "trap_api/inquiry.h" 
#include "trap_api/adc.h" 
#include "trap_api/test.h" 
#include "trap_api/audio_pwm.h" 
#include "trap_api/codec_.h" 
#include "trap_api/crypto.h" 
#include "trap_api/status.h" 
#include "trap_api/usb_hub.h" 
#include "trap_api/sram.h" 
#include "trap_api/lcd.h" 
#include "trap_api/util.h" 
#include "trap_api/host.h" 
#include "trap_api/bitserial_api.h" 
#include "trap_api/sink.h" 
#include "trap_api/otp.h" 
#include "trap_api/psu.h" 
#include "trap_api/dormant.h" 
#include "trap_api/charger.h" 
#include "trap_api/partition.h" 
#include "trap_api/sdmmc.h" 
#include "trap_api/audio_clock.h" 
#include "trap_api/feature.h" 
#include "trap_api/imageupgrade.h" 
#include "trap_api/i2c.h" 
#include "trap_api/capacitivesensor.h" 
#include "trap_api/voltsense.h" 
#include "trap_api/nfc.h" 
#include "trap_api/audio_anc.h" 
#include "trap_api/stream.h" 
#include "trap_api/pio.h" 
#include "trap_api/audio_mclk.h" 
#include "trap_api/energy.h" 
#include "trap_api/vm.h" 
#include "trap_api/infrared.h" 
#include "trap_api/file.h" 
#include "trap_api/operator.h" 
#include "trap_api/message.h" 
#include "trap_api/font.h" 
#include "trap_api/native.h" 

#if TRAPSET_MICBIAS
bool MicbiasConfigure(mic_bias_id mic, mic_bias_config_key key, uint16 value)
{
    IPC_MICBIAS_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.mic = mic;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_MICBIAS_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_MICBIAS_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_MICBIAS */


#if TRAPSET_USB
usb_attached_status UsbAttachedStatus(void )
{
    IPC_USB_ATTACHED_STATUS ipc_send_prim;
    IPC_USB_ATTACHED_STATUS_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_USB_ATTACHED_STATUS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ATTACHED_STATUS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


UsbInterface UsbAddInterface(const UsbCodes * codes, uint16 type, const uint8 * if_descriptor, uint16 descriptor_length)
{
    IPC_USB_ADD_INTERFACE ipc_send_prim;
    IPC_USBINTERFACE_RSP ipc_recv_prim;
    ipc_send_prim.codes = codes;
    ipc_send_prim.type = type;
    ipc_send_prim.if_descriptor = if_descriptor;
    ipc_send_prim.descriptor_length = descriptor_length;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_INTERFACE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_INTERFACE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbAddEndPoints(UsbInterface interface, uint16 num_end_points, const EndPointInfo * end_point_info)
{
    IPC_USB_ADD_END_POINTS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.interface = interface;
    ipc_send_prim.num_end_points = num_end_points;
    ipc_send_prim.end_point_info = end_point_info;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_END_POINTS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_END_POINTS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbAddDescriptor(UsbInterface interface, uint16 type, const uint8 * descriptor, uint16 descriptor_length)
{
    IPC_USB_ADD_DESCRIPTOR ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.interface = interface;
    ipc_send_prim.type = type;
    ipc_send_prim.descriptor = descriptor;
    ipc_send_prim.descriptor_length = descriptor_length;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_DESCRIPTOR, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_DESCRIPTOR_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbAddStringDescriptor(uint8 string_index, const uint16 * string_descriptor)
{
    IPC_USB_ADD_STRING_DESCRIPTOR ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.string_index = string_index;
    ipc_send_prim.string_descriptor = string_descriptor;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_STRING_DESCRIPTOR, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_STRING_DESCRIPTOR_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbAddInterfaceAssociationDescriptor(uint16 if_num, const uint8 * ia_descriptor, uint16 descriptor_length)
{
    IPC_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.if_num = if_num;
    ipc_send_prim.ia_descriptor = ia_descriptor;
    ipc_send_prim.descriptor_length = descriptor_length;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_INTERFACE_ASSOCIATION_DESCRIPTOR_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Sink StreamUsbClassSink(UsbInterface interface)
{
    IPC_STREAM_USB_CLASS_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.interface = interface;
    ipc_send(IPC_SIGNAL_ID_STREAM_USB_CLASS_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_USB_CLASS_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamUsbEndPointSink(uint16 end_point)
{
    IPC_STREAM_USB_END_POINT_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.end_point = end_point;
    ipc_send(IPC_SIGNAL_ID_STREAM_USB_END_POINT_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_USB_END_POINT_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamUsbVendorSink(void )
{
    IPC_STREAM_USB_VENDOR_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_STREAM_USB_VENDOR_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_USB_VENDOR_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


uint16 UsbAddConfiguration(const ConfigDescriptorInfo * desc_info)
{
    IPC_USB_ADD_CONFIGURATION ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.desc_info = desc_info;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_CONFIGURATION, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_CONFIGURATION_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


usb_device_state UsbDeviceState(void )
{
    IPC_USB_DEVICE_STATE ipc_send_prim;
    IPC_USB_DEVICE_STATE_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_USB_DEVICE_STATE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_DEVICE_STATE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


UsbAltInterface UsbAddAltInterface(UsbInterface interface, const uint8 * if_descriptor, uint16 descriptor_length)
{
    IPC_USB_ADD_ALT_INTERFACE ipc_send_prim;
    IPC_USBALTINTERFACE_RSP ipc_recv_prim;
    ipc_send_prim.interface = interface;
    ipc_send_prim.if_descriptor = if_descriptor;
    ipc_send_prim.descriptor_length = descriptor_length;
    ipc_send(IPC_SIGNAL_ID_USB_ADD_ALT_INTERFACE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_ADD_ALT_INTERFACE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void UsbDebugAllow(bool flag)
{
    IPC_USB_DEBUG_ALLOW ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send_prim.flag = flag;
    ipc_send(IPC_SIGNAL_ID_USB_DEBUG_ALLOW, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_DEBUG_ALLOW_RSP, &ipc_recv_prim);
}


#endif /* TRAPSET_USB */


#if TRAPSET_RFCOMM
Sink StreamRfcommSink(uint16 conn_id)
{
    IPC_STREAM_RFCOMM_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.conn_id = conn_id;
    ipc_send(IPC_SIGNAL_ID_STREAM_RFCOMM_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_RFCOMM_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


uint16 SinkGetRfcommConnId(Sink sink)
{
    IPC_SINK_GET_RFCOMM_CONN_ID ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_GET_RFCOMM_CONN_ID, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_GET_RFCOMM_CONN_ID_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_RFCOMM */


#if TRAPSET_AUDIO_MCLK
bool AudioMasterClockConfigure(bool use_external, uint32 frequency)
{
    IPC_AUDIO_MASTER_CLOCK_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.use_external = use_external;
    ipc_send_prim.frequency = frequency;
    ipc_send(IPC_SIGNAL_ID_AUDIO_MASTER_CLOCK_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_MASTER_CLOCK_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SourceMasterClockEnable(Source source, vm_mclk_enable enable)
{
    IPC_SOURCE_MASTER_CLOCK_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_SOURCE_MASTER_CLOCK_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_MASTER_CLOCK_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkMasterClockEnable(Sink sink, vm_mclk_enable enable)
{
    IPC_SINK_MASTER_CLOCK_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_SINK_MASTER_CLOCK_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_MASTER_CLOCK_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_AUDIO_MCLK */


#if TRAPSET_CHARGER
bool ChargerConfigure(charger_config_key key, uint16 value)
{
    IPC_CHARGER_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_CHARGER_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CHARGER_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


charger_status ChargerStatus(void )
{
    IPC_CHARGER_STATUS ipc_send_prim;
    IPC_CHARGER_STATUS_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_CHARGER_STATUS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CHARGER_STATUS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_CHARGER */


#if TRAPSET_INFRARED
bool InfraredConfigure(infrared_config_key key, uint32 value)
{
    IPC_INFRARED_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_INFRARED_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_INFRARED_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_INFRARED */


#if TRAPSET_CHARGER2
charger_battery_status ChargerGetBatteryStatusAtBoot(void )
{
    IPC_CHARGER_GET_BATTERY_STATUS_AT_BOOT ipc_send_prim;
    IPC_CHARGER_BATTERY_STATUS_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_CHARGER_GET_BATTERY_STATUS_AT_BOOT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CHARGER_GET_BATTERY_STATUS_AT_BOOT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_CHARGER2 */


#if TRAPSET_ATT
Source StreamAttSource(uint16 cid, uint16 handle)
{
    IPC_STREAM_ATT_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


bool VmClearAdvertisingReportFilter(void )
{
    IPC_VM_CLEAR_ADVERTISING_REPORT_FILTER ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_CLEAR_ADVERTISING_REPORT_FILTER, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_CLEAR_ADVERTISING_REPORT_FILTER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmAddAdvertisingReportFilter(uint16 operation, uint16 ad_type, uint16 interval, uint16 pattern_length, uint8 * pattern_addr)
{
    IPC_VM_ADD_ADVERTISING_REPORT_FILTER ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.operation = operation;
    ipc_send_prim.ad_type = ad_type;
    ipc_send_prim.interval = interval;
    ipc_send_prim.pattern_length = pattern_length;
    ipc_send_prim.pattern_addr = pattern_addr;
    ipc_send(IPC_SIGNAL_ID_VM_ADD_ADVERTISING_REPORT_FILTER, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_ADD_ADVERTISING_REPORT_FILTER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source StreamAttSourceAddHandle(uint16 cid, uint16 handle)
{
    IPC_STREAM_ATT_SOURCE_ADD_HANDLE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_ADD_HANDLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_ADD_HANDLE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


bool StreamAttSourceRemoveAllHandles(uint16 cid)
{
    IPC_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SOURCE_REMOVE_ALL_HANDLES_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Sink StreamAttSink(uint16 cid)
{
    IPC_STREAM_ATT_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Source StreamAttServerSource(uint16 cid)
{
    IPC_STREAM_ATT_SERVER_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SERVER_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SERVER_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Source StreamAttClientSource(uint16 cid)
{
    IPC_STREAM_ATT_CLIENT_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_CLIENT_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_CLIENT_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


bool StreamAttAddHandle(Source source, uint16 handle)
{
    IPC_STREAM_ATT_ADD_HANDLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_ADD_HANDLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_ADD_HANDLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool StreamAttRemoveAllHandles(Source source)
{
    IPC_STREAM_ATT_REMOVE_ALL_HANDLES ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_REMOVE_ALL_HANDLES, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_REMOVE_ALL_HANDLES_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Sink StreamAttClientSink(uint16 cid)
{
    IPC_STREAM_ATT_CLIENT_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_CLIENT_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_CLIENT_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamAttServerSink(uint16 cid)
{
    IPC_STREAM_ATT_SERVER_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_ATT_SERVER_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_ATT_SERVER_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_ATT */


#if TRAPSET_REFORMATSQIF
Sink StreamReformatSerialFlashSink(partition_filesystem_devices device)
{
    IPC_STREAM_REFORMAT_SERIAL_FLASH_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send(IPC_SIGNAL_ID_STREAM_REFORMAT_SERIAL_FLASH_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_REFORMAT_SERIAL_FLASH_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_REFORMATSQIF */


#if TRAPSET_FILE
FILE_INDEX FileFind(FILE_INDEX start, const char * name, uint16 length)
{
    IPC_FILE_FIND ipc_send_prim;
    IPC_FILE_INDEX_RSP ipc_recv_prim;
    ipc_send_prim.start = start;
    ipc_send_prim.name = name;
    ipc_send_prim.length = length;
    ipc_send(IPC_SIGNAL_ID_FILE_FIND, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_FIND_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


FILE_TYPE FileType(FILE_INDEX index)
{
    IPC_FILE_TYPE ipc_send_prim;
    IPC_FILE_TYPE_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send(IPC_SIGNAL_ID_FILE_TYPE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_TYPE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


FILE_INDEX FileParent(FILE_INDEX item)
{
    IPC_FILE_PARENT ipc_send_prim;
    IPC_FILE_INDEX_RSP ipc_recv_prim;
    ipc_send_prim.item = item;
    ipc_send(IPC_SIGNAL_ID_FILE_PARENT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_PARENT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source StreamFileSource(FILE_INDEX index)
{
    IPC_STREAM_FILE_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send(IPC_SIGNAL_ID_STREAM_FILE_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_FILE_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


FILE_INDEX FileCreate(const char * name, uint16 length)
{
    IPC_FILE_CREATE ipc_send_prim;
    IPC_FILE_INDEX_RSP ipc_recv_prim;
    ipc_send_prim.name = name;
    ipc_send_prim.length = length;
    ipc_send(IPC_SIGNAL_ID_FILE_CREATE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_CREATE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Sink StreamFileSink(FILE_INDEX index)
{
    IPC_STREAM_FILE_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send(IPC_SIGNAL_ID_STREAM_FILE_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_FILE_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool FileDelete(FILE_INDEX index)
{
    IPC_FILE_DELETE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send(IPC_SIGNAL_ID_FILE_DELETE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_DELETE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool FileRename(const char * old_path, uint16 old_path_len, const char * new_path, uint16 new_path_len)
{
    IPC_FILE_RENAME ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.old_path = old_path;
    ipc_send_prim.old_path_len = old_path_len;
    ipc_send_prim.new_path = new_path;
    ipc_send_prim.new_path_len = new_path_len;
    ipc_send(IPC_SIGNAL_ID_FILE_RENAME, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_RENAME_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source StreamFilesystemSource(FILESYSTEM_ID filesystem_id)
{
    IPC_STREAM_FILESYSTEM_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.filesystem_id = filesystem_id;
    ipc_send(IPC_SIGNAL_ID_STREAM_FILESYSTEM_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_FILESYSTEM_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamFilesystemSink(FILESYSTEM_ID filesystem_id)
{
    IPC_STREAM_FILESYSTEM_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.filesystem_id = filesystem_id;
    ipc_send(IPC_SIGNAL_ID_STREAM_FILESYSTEM_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_FILESYSTEM_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool FileSystemUnmount(const char * mount_path)
{
    IPC_FILE_SYSTEM_UNMOUNT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.mount_path = mount_path;
    ipc_send(IPC_SIGNAL_ID_FILE_SYSTEM_UNMOUNT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_SYSTEM_UNMOUNT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


const void * FileMap(FILE_INDEX index, uint32 offset, uint32 size)
{
    IPC_FILE_MAP ipc_send_prim;
    IPC_CONST_VOID__PTR_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send_prim.offset = offset;
    ipc_send_prim.size = size;
    ipc_send(IPC_SIGNAL_ID_FILE_MAP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FILE_MAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_FILE */


#if TRAPSET_IMAGEUPGRADE
bool ImageUpgradeGetInfo(uint16 qspi, image_section_id image_section, image_info_key key, uint32 * value)
{
    IPC_IMAGE_UPGRADE_GET_INFO ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.qspi = qspi;
    ipc_send_prim.image_section = image_section;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_GET_INFO, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_GET_INFO_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Sink ImageUpgradeStreamGetSink(uint16 qspi, image_section_id image_section, uint32 first_word)
{
    IPC_IMAGE_UPGRADE_STREAM_GET_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.qspi = qspi;
    ipc_send_prim.image_section = image_section;
    ipc_send_prim.first_word = first_word;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool ImageUpgradeSinkGetPosition(Sink sink, uint32 * offset)
{
    IPC_IMAGE_UPGRADE_SINK_GET_POSITION ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.offset = offset;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_SINK_GET_POSITION, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_SINK_GET_POSITION_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void ImageUpgradeErase(void )
{
    IPC_IMAGE_UPGRADE_ERASE ipc_send_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_ERASE, &ipc_send_prim, sizeof(ipc_send_prim));
}


void ImageUpgradeSwapTry(void )
{
    IPC_IMAGE_UPGRADE_SWAP_TRY ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY_RSP, &ipc_recv_prim);
}


bool ImageUpgradeSwapTryStatus(void )
{
    IPC_IMAGE_UPGRADE_SWAP_TRY_STATUS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY_STATUS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_TRY_STATUS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool ImageUpgradeSwapCommit(void )
{
    IPC_IMAGE_UPGRADE_SWAP_COMMIT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_COMMIT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_SWAP_COMMIT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


hash_context_t ImageUpgradeHashInitialise(hash_algo_t algo)
{
    IPC_IMAGE_UPGRADE_HASH_INITIALISE ipc_send_prim;
    IPC_HASH_CONTEXT_T_RSP ipc_recv_prim;
    ipc_send_prim.algo = algo;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_INITIALISE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_INITIALISE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool ImageUpgradeHashSectionUpdate(hash_context_t context, image_section_id image_section)
{
    IPC_IMAGE_UPGRADE_HASH_SECTION_UPDATE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.context = context;
    ipc_send_prim.image_section = image_section;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_SECTION_UPDATE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_SECTION_UPDATE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool ImageUpgradeHashMsgUpdate(hash_context_t context, const uint8 * msg, uint16 msg_len_bytes)
{
    IPC_IMAGE_UPGRADE_HASH_MSG_UPDATE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.context = context;
    ipc_send_prim.msg = msg;
    ipc_send_prim.msg_len_bytes = msg_len_bytes;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_MSG_UPDATE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_MSG_UPDATE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool ImageUpgradeHashFinalise(hash_context_t context, uint8 * hash, uint16 hash_len_bytes)
{
    IPC_IMAGE_UPGRADE_HASH_FINALISE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.context = context;
    ipc_send_prim.hash = hash;
    ipc_send_prim.hash_len_bytes = hash_len_bytes;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_FINALISE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_FINALISE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void ImageUpgradeCopy(void )
{
    IPC_IMAGE_UPGRADE_COPY ipc_send_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_COPY, &ipc_send_prim, sizeof(ipc_send_prim));
}


bool ImageUpgradeAbortCommand(void )
{
    IPC_IMAGE_UPGRADE_ABORT_COMMAND ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_ABORT_COMMAND, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_ABORT_COMMAND_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void ImageUpgradeAudio(void )
{
    IPC_IMAGE_UPGRADE_AUDIO ipc_send_prim;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_AUDIO, &ipc_send_prim, sizeof(ipc_send_prim));
}


void ImageUpgradeHashAllSectionsUpdate(hash_context_t context)
{
    IPC_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE ipc_send_prim;
    ipc_send_prim.context = context;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_HASH_ALL_SECTIONS_UPDATE, &ipc_send_prim, sizeof(ipc_send_prim));
}


Source ImageUpgradeStreamGetSource(uint16 qspi, image_section_id image_section)
{
    IPC_IMAGE_UPGRADE_STREAM_GET_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.qspi = qspi;
    ipc_send_prim.image_section = image_section;
    ipc_send(IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_IMAGE_UPGRADE_STREAM_GET_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_IMAGEUPGRADE */


#if TRAPSET_SHUNT
Sink StreamShuntSink(uint16 acl, uint16 cid)
{
    IPC_STREAM_SHUNT_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.acl = acl;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_SHUNT_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SHUNT_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_SHUNT */


#if TRAPSET_HIDDONGLE
Transform TransformHid(Source source, Sink sink)
{
    IPC_TRANSFORM_HID ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_HID, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_HID_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_HIDDONGLE */


#if TRAPSET_FONT
FontId FontInit(void )
{
    IPC_FONT_INIT ipc_send_prim;
    IPC_FONTID_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_FONT_INIT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FONT_INIT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


size_t FontGetGlyph(FontId font, ucs2char c, uint16 * glyph, size_t max_glyph_wid)
{
    IPC_FONT_GET_GLYPH ipc_send_prim;
    IPC_SIZE_T_RSP ipc_recv_prim;
    ipc_send_prim.font = font;
    ipc_send_prim.c = c;
    ipc_send_prim.glyph = glyph;
    ipc_send_prim.max_glyph_wid = max_glyph_wid;
    ipc_send(IPC_SIGNAL_ID_FONT_GET_GLYPH, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FONT_GET_GLYPH_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_FONT */


#if TRAPSET_IICSTREAM
Source StreamI2cSource(uint16 slave_addr, uint16 array_addr, uint16 size)
{
    IPC_STREAM_I2C_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.slave_addr = slave_addr;
    ipc_send_prim.array_addr = array_addr;
    ipc_send_prim.size = size;
    ipc_send(IPC_SIGNAL_ID_STREAM_I2C_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_I2C_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_IICSTREAM */


#if TRAPSET_CSB
Sink StreamCsbSink(uint16 lt_addr)
{
    IPC_STREAM_CSB_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.lt_addr = lt_addr;
    ipc_send(IPC_SIGNAL_ID_STREAM_CSB_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_CSB_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool CsbTransmitterSetAfhMap(uint16 lt_addr, AfhMap * afh_map, uint32 afh_instant)
{
    IPC_CSB_TRANSMITTER_SET_AFH_MAP ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.lt_addr = lt_addr;
    ipc_send_prim.afh_map = afh_map;
    ipc_send_prim.afh_instant = afh_instant;
    ipc_send(IPC_SIGNAL_ID_CSB_TRANSMITTER_SET_AFH_MAP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CSB_TRANSMITTER_SET_AFH_MAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void CsbEnableNewAfhMapEvent(bool enable)
{
    IPC_CSB_ENABLE_NEW_AFH_MAP_EVENT ipc_send_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_CSB_ENABLE_NEW_AFH_MAP_EVENT, &ipc_send_prim, sizeof(ipc_send_prim));
}


#endif /* TRAPSET_CSB */


#if TRAPSET_NATIVE
void NativePauseForDebug(void )
{
    IPC_NATIVE_PAUSE_FOR_DEBUG ipc_send_prim;
    ipc_send(IPC_SIGNAL_ID_NATIVE_PAUSE_FOR_DEBUG, &ipc_send_prim, sizeof(ipc_send_prim));
}


#endif /* TRAPSET_NATIVE */


#if TRAPSET_STREAM
uint16 SinkSlack(Sink sink)
{
    IPC_SINK_SLACK ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_SLACK, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_SLACK_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 SinkClaim(Sink sink, uint16 extra)
{
    IPC_SINK_CLAIM ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.extra = extra;
    ipc_send(IPC_SIGNAL_ID_SINK_CLAIM, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_CLAIM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint8 * SinkMap(Sink sink)
{
    IPC_SINK_MAP ipc_send_prim;
    IPC_UINT8__PTR_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_MAP, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_MAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkFlush(Sink sink, uint16 amount)
{
    IPC_SINK_FLUSH ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.amount = amount;
    ipc_send(IPC_SIGNAL_ID_SINK_FLUSH, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_FLUSH_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkFlushHeader(Sink sink, uint16 amount, const void * header, uint16 length)
{
    IPC_SINK_FLUSH_HEADER ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.amount = amount;
    ipc_send_prim.header_ = header;
    ipc_send_prim.length = length;
    ipc_send(IPC_SIGNAL_ID_SINK_FLUSH_HEADER, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_FLUSH_HEADER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 SourceSize(Source source)
{
    IPC_SOURCE_SIZE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_SIZE, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_SIZE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 SourceSizeHeader(Source source)
{
    IPC_SOURCE_SIZE_HEADER ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_SIZE_HEADER, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_SIZE_HEADER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


const uint8 * SourceMap(Source source)
{
    IPC_SOURCE_MAP ipc_send_prim;
    IPC_CONST_UINT8__PTR_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_MAP, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_MAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


const void * SourceMapHeader(Source source)
{
    IPC_SOURCE_MAP_HEADER ipc_send_prim;
    IPC_CONST_VOID__PTR_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_MAP_HEADER, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_MAP_HEADER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void SourceDrop(Source source, uint16 amount)
{
    IPC_SOURCE_DROP ipc_send_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.amount = amount;
    ipc_send(IPC_SIGNAL_ID_SOURCE_DROP, &ipc_send_prim, sizeof(ipc_send_prim));
}


uint16 SourceBoundary(Source source)
{
    IPC_SOURCE_BOUNDARY ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_BOUNDARY, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_BOUNDARY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 SourceSizeBlocking(Source source)
{
    IPC_SOURCE_SIZE_BLOCKING ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_SIZE_BLOCKING, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_SIZE_BLOCKING_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 StreamMove(Sink sink, Source source, uint16 count)
{
    IPC_STREAM_MOVE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.count = count;
    ipc_send(IPC_SIGNAL_ID_STREAM_MOVE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_MOVE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Transform StreamConnect(Source source, Sink sink)
{
    IPC_STREAM_CONNECT ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_STREAM_CONNECT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_CONNECT_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


bool StreamConnectDispose(Source source)
{
    IPC_STREAM_CONNECT_DISPOSE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_STREAM_CONNECT_DISPOSE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_CONNECT_DISPOSE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void StreamDisconnect(Source source, Sink sink)
{
    IPC_STREAM_DISCONNECT ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_STREAM_DISCONNECT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_DISCONNECT_RSP, &ipc_recv_prim);
}


bool SourceIsValid(Source source)
{
    IPC_SOURCE_IS_VALID ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_IS_VALID, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SOURCE_IS_VALID_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkIsValid(Sink sink)
{
    IPC_SINK_IS_VALID ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_IS_VALID, &ipc_send_prim, sizeof(ipc_send_prim));
    (void)ipc_recv_atomic(IPC_SIGNAL_ID_SINK_IS_VALID_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool StreamConfigure(vm_stream_config_key key, uint16 value)
{
    IPC_STREAM_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_STREAM_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SourceConfigure(Source source, stream_config_key key, uint32 value)
{
    IPC_SOURCE_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_SOURCE_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkConfigure(Sink sink, stream_config_key key, uint32 value)
{
    IPC_SINK_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_SINK_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source StreamSourceFromSink(Sink sink)
{
    IPC_STREAM_SOURCE_FROM_SINK ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_STREAM_SOURCE_FROM_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SOURCE_FROM_SINK_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamSinkFromSource(Source source)
{
    IPC_STREAM_SINK_FROM_SOURCE ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_STREAM_SINK_FROM_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SINK_FROM_SOURCE_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool SourceClose(Source source)
{
    IPC_SOURCE_CLOSE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_CLOSE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_CLOSE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkClose(Sink sink)
{
    IPC_SINK_CLOSE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_CLOSE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_CLOSE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkAlias(Sink sink1, Sink sink2)
{
    IPC_SINK_ALIAS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink1 = SINK_TO_ID(sink1);
    ipc_send_prim.sink2 = SINK_TO_ID(sink2);
    ipc_send(IPC_SIGNAL_ID_SINK_ALIAS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_ALIAS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkSynchronise(Sink sink1, Sink sink2)
{
    IPC_SINK_SYNCHRONISE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink1 = SINK_TO_ID(sink1);
    ipc_send_prim.sink2 = SINK_TO_ID(sink2);
    ipc_send(IPC_SIGNAL_ID_SINK_SYNCHRONISE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_SYNCHRONISE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SourceSynchronise(Source source1, Source source2)
{
    IPC_SOURCE_SYNCHRONISE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source1 = SOURCE_TO_ID(source1);
    ipc_send_prim.source2 = SOURCE_TO_ID(source2);
    ipc_send(IPC_SIGNAL_ID_SOURCE_SYNCHRONISE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_SYNCHRONISE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool TransformStart(Transform transform)
{
    IPC_TRANSFORM_START ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.transform = TRANSFORM_TO_ID(transform);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_START, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_START_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool TransformStop(Transform transform)
{
    IPC_TRANSFORM_STOP ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.transform = TRANSFORM_TO_ID(transform);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_STOP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_STOP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool TransformDisconnect(Transform transform)
{
    IPC_TRANSFORM_DISCONNECT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.transform = TRANSFORM_TO_ID(transform);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_DISCONNECT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_DISCONNECT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool TransformPollTraffic(Transform transform)
{
    IPC_TRANSFORM_POLL_TRAFFIC ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.transform = TRANSFORM_TO_ID(transform);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_POLL_TRAFFIC, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_POLL_TRAFFIC_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Transform TransformFromSource(Source source)
{
    IPC_TRANSFORM_FROM_SOURCE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_FROM_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_FROM_SOURCE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


Transform TransformFromSink(Sink sink)
{
    IPC_TRANSFORM_FROM_SINK ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_FROM_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_FROM_SINK_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


bool TransformConfigure(Transform transform, vm_transform_config_key key, uint16 value)
{
    IPC_TRANSFORM_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.transform = TRANSFORM_TO_ID(transform);
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source StreamRegionSource(const uint8 * data, uint16 length)
{
    IPC_STREAM_REGION_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.data = data;
    ipc_send_prim.length = length;
    ipc_send(IPC_SIGNAL_ID_STREAM_REGION_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_REGION_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Transform TransformChunk(Source source, Sink sink)
{
    IPC_TRANSFORM_CHUNK ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_CHUNK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_CHUNK_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


Transform TransformSlice(Source source, Sink sink)
{
    IPC_TRANSFORM_SLICE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_SLICE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_SLICE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


Transform TransformAdpcmDecode(Source source, Sink sink)
{
    IPC_TRANSFORM_ADPCM_DECODE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_ADPCM_DECODE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_ADPCM_DECODE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


bool SinkMapInit(Sink sink, stream_device device, uint16 header_len)
{
    IPC_SINK_MAP_INIT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.device = device;
    ipc_send_prim.header_len = header_len;
    ipc_send(IPC_SIGNAL_ID_SINK_MAP_INIT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_MAP_INIT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SourceMapInit(Source source, stream_device device, uint16 header_len)
{
    IPC_SOURCE_MAP_INIT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.device = device;
    ipc_send_prim.header_len = header_len;
    ipc_send(IPC_SIGNAL_ID_SOURCE_MAP_INIT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_MAP_INIT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkUnmap(Sink sink)
{
    IPC_SINK_UNMAP ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_UNMAP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_UNMAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SourceUnmap(Source source)
{
    IPC_SOURCE_UNMAP ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_UNMAP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_UNMAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkFlushBlocking(Sink sink, uint16 amount)
{
    IPC_SINK_FLUSH_BLOCKING ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.amount = amount;
    ipc_send(IPC_SIGNAL_ID_SINK_FLUSH_BLOCKING, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_FLUSH_BLOCKING_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Transform TransformPacketise(Source source, Sink sink)
{
    IPC_TRANSFORM_PACKETISE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_PACKETISE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_PACKETISE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


bool SinkGetRssi(Sink sink, int16 * rssi)
{
    IPC_SINK_GET_RSSI ipc_send_prim;
    IPC_SINK_GET_RSSI_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_GET_RSSI, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_GET_RSSI_RSP, &ipc_recv_prim);
    if (rssi != NULL)
    {
      *rssi = ipc_recv_prim.rssi;
    }
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_STREAM */


#if TRAPSET_AUDIO_ANC
bool AudioAncStreamEnable(uint16 anc_enable_0, uint16 anc_enable_1)
{
    IPC_AUDIO_ANC_STREAM_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.anc_enable_0 = anc_enable_0;
    ipc_send_prim.anc_enable_1 = anc_enable_1;
    ipc_send(IPC_SIGNAL_ID_AUDIO_ANC_STREAM_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_ANC_STREAM_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool AudioAncFilterLpfSet(audio_anc_instance anc_instance, audio_anc_path_id path_id, uint16 shift1, uint16 shift2)
{
    IPC_AUDIO_ANC_FILTER_LPF_SET ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.anc_instance = anc_instance;
    ipc_send_prim.path_id = path_id;
    ipc_send_prim.shift1 = shift1;
    ipc_send_prim.shift2 = shift2;
    ipc_send(IPC_SIGNAL_ID_AUDIO_ANC_FILTER_LPF_SET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_ANC_FILTER_LPF_SET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool AudioAncFilterIirSet(audio_anc_instance anc_instance, audio_anc_path_id path_id, uint16 num_coeffs, const uint16 * coeffs)
{
    IPC_AUDIO_ANC_FILTER_IIR_SET ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.anc_instance = anc_instance;
    ipc_send_prim.path_id = path_id;
    ipc_send_prim.num_coeffs = num_coeffs;
    ipc_send_prim.coeffs = coeffs;
    ipc_send(IPC_SIGNAL_ID_AUDIO_ANC_FILTER_IIR_SET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_ANC_FILTER_IIR_SET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_AUDIO_ANC */


#if TRAPSET_IIR
bool CodecSetIirFilter(audio_instance instance, audio_channel channel, bool enable, uint16 * coefficients)
{
    IPC_CODEC_SET_IIR_FILTER ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.instance = instance;
    ipc_send_prim.channel = channel;
    ipc_send_prim.enable = enable;
    ipc_send_prim.coefficients = coefficients;
    ipc_send(IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_IIR */


#if TRAPSET_UART
void StreamUartConfigure(vm_uart_rate rate, vm_uart_stop stop, vm_uart_parity parity)
{
    IPC_STREAM_UART_CONFIGURE ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send_prim.rate = rate;
    ipc_send_prim.stop = stop;
    ipc_send_prim.parity = parity;
    ipc_send(IPC_SIGNAL_ID_STREAM_UART_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_UART_CONFIGURE_RSP, &ipc_recv_prim);
}


#endif /* TRAPSET_UART */


#if TRAPSET_FASTPIPE
Sink StreamFastPipeSink(uint16 id)
{
    IPC_STREAM_FAST_PIPE_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.id = id;
    ipc_send(IPC_SIGNAL_ID_STREAM_FAST_PIPE_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_FAST_PIPE_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_FASTPIPE */


#if TRAPSET_LCD
bool LcdConfigure(uint16 key, uint16 value)
{
    IPC_LCD_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_LCD_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_LCD_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint32 LcdSet(uint32 mask, uint32 value)
{
    IPC_LCD_SET ipc_send_prim;
    IPC_UINT32_RSP ipc_recv_prim;
    ipc_send_prim.mask = mask;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_LCD_SET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_LCD_SET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_LCD */


#if TRAPSET_SD_MMC
Source StreamSdMmcSource(uint8 slot, uint32 start_block, uint32 blocks_count)
{
    IPC_STREAM_SD_MMC_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.slot = slot;
    ipc_send_prim.start_block = start_block;
    ipc_send_prim.blocks_count = blocks_count;
    ipc_send(IPC_SIGNAL_ID_STREAM_SD_MMC_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SD_MMC_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamSdMmcSink(uint8 slot, uint32 start_block, uint32 blocks_count)
{
    IPC_STREAM_SD_MMC_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.slot = slot;
    ipc_send_prim.start_block = start_block;
    ipc_send_prim.blocks_count = blocks_count;
    ipc_send(IPC_SIGNAL_ID_STREAM_SD_MMC_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SD_MMC_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool SdMmcDeviceInfo(uint8 slot, sd_mmc_dev_info * device_info)
{
    IPC_SD_MMC_DEVICE_INFO ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.slot = slot;
    ipc_send_prim.device_info = device_info;
    ipc_send(IPC_SIGNAL_ID_SD_MMC_DEVICE_INFO, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SD_MMC_DEVICE_INFO_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_SD_MMC */


#if TRAPSET_HOSTSTREAM
Sink StreamHostSink(uint16 channel)
{
    IPC_STREAM_HOST_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.channel = channel;
    ipc_send(IPC_SIGNAL_ID_STREAM_HOST_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_HOST_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_HOSTSTREAM */


#if TRAPSET_IIC
uint16 I2cTransfer(uint16 address, const uint8 * tx, uint16 tx_len, uint8 * rx, uint16 rx_len)
{
    IPC_I2C_TRANSFER ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.address = address;
    ipc_send_prim.tx = tx;
    ipc_send_prim.tx_len = tx_len;
    ipc_send_prim.rx = rx;
    ipc_send_prim.rx_len = rx_len;
    ipc_send(IPC_SIGNAL_ID_I2C_TRANSFER, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_I2C_TRANSFER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_IIC */


#if TRAPSET_SRAM
uint16 * SramMap(uint32 sram_addr, uint16 size)
{
    IPC_SRAM_MAP ipc_send_prim;
    IPC_UINT16__PTR_RSP ipc_recv_prim;
    ipc_send_prim.sram_addr = sram_addr;
    ipc_send_prim.size = size;
    ipc_send(IPC_SIGNAL_ID_SRAM_MAP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SRAM_MAP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_SRAM */


#if TRAPSET_CAPACITIVE_SENSOR
bool CapacitiveSensorPadQuery(uint16 count, const uint16* pads, capacitive_sensor_pad_state * results)
{
    IPC_CAPACITIVE_SENSOR_PAD_QUERY ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.count = count;
    ipc_send_prim.pads = pads;
    ipc_send_prim.results = results;
    ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_PAD_QUERY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_PAD_QUERY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool CapacitiveSensorConfigureMultiPad(uint16 count, const uint16 * pads, const CAPACITIVE_SENSOR_PAD_CONFIG * common_config)
{
    IPC_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.count = count;
    ipc_send_prim.pads = pads;
    ipc_send_prim.common_config = common_config;
    ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_MULTI_PAD_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool CapacitiveSensorEnablePads(uint16 count, const uint16 * pads, const CAPACITIVE_SENSOR_PAD_LEVELS * pad_levels)
{
    IPC_CAPACITIVE_SENSOR_ENABLE_PADS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.count = count;
    ipc_send_prim.pads = pads;
    ipc_send_prim.pad_levels = pad_levels;
    ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_ENABLE_PADS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_ENABLE_PADS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool CapacitiveSensorConfigureTouchOffset(uint16 pad, uint32 touch_offset)
{
    IPC_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.pad = pad;
    ipc_send_prim.touch_offset = touch_offset;
    ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_CONFIGURE_TOUCH_OFFSET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void CapacitiveSensorShieldEnable(bool enable)
{
    IPC_CAPACITIVE_SENSOR_SHIELD_ENABLE ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_SHIELD_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CAPACITIVE_SENSOR_SHIELD_ENABLE_RSP, &ipc_recv_prim);
}


#endif /* TRAPSET_CAPACITIVE_SENSOR */


#if TRAPSET_STATUS
void StatusQuery(uint16 count, const status_field * fields, uint16 * results)
{
    IPC_STATUS_QUERY ipc_send_prim;
    ipc_send_prim.count = count;
    ipc_send_prim.fields = fields;
    ipc_send_prim.results = results;
    ipc_send(IPC_SIGNAL_ID_STATUS_QUERY, &ipc_send_prim, sizeof(ipc_send_prim));
}


#endif /* TRAPSET_STATUS */


#if TRAPSET_CORE
uint16 UtilRandom(void )
{
    IPC_UTIL_RANDOM ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_UTIL_RANDOM, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_UTIL_RANDOM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 PsStore(uint16 key, const void * buff, uint16 words)
{
    IPC_PS_STORE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.buff = buff;
    ipc_send_prim.words = words;
    ipc_send(IPC_SIGNAL_ID_PS_STORE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_STORE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 PsRetrieve(uint16 key, void * buff, uint16 words)
{
    IPC_PS_RETRIEVE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.buff = buff;
    ipc_send_prim.words = words;
    ipc_send(IPC_SIGNAL_ID_PS_RETRIEVE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_RETRIEVE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void PsDefrag(void )
{
    IPC_PS_DEFRAG ipc_send_prim;
    ipc_send(IPC_SIGNAL_ID_PS_DEFRAG, &ipc_send_prim, sizeof(ipc_send_prim));
}


uint16 PsFreeCount(uint16 words)
{
    IPC_PS_FREE_COUNT ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.words = words;
    ipc_send(IPC_SIGNAL_ID_PS_FREE_COUNT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_FREE_COUNT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 PsFullRetrieve(uint16 key, void * buff, uint16 words)
{
    IPC_PS_FULL_RETRIEVE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.buff = buff;
    ipc_send_prim.words = words;
    ipc_send(IPC_SIGNAL_ID_PS_FULL_RETRIEVE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_FULL_RETRIEVE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 BootGetMode(void )
{
    IPC_BOOT_GET_MODE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_BOOT_GET_MODE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BOOT_GET_MODE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void BootSetMode(uint16 newBootmode)
{
    IPC_BOOT_SET_MODE ipc_send_prim;
    ipc_send_prim.newBootmode = newBootmode;
    ipc_send(IPC_SIGNAL_ID_BOOT_SET_MODE, &ipc_send_prim, sizeof(ipc_send_prim));
}


bool VmDeepSleepEnable(bool en)
{
    IPC_VM_DEEP_SLEEP_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.en = en;
    ipc_send(IPC_SIGNAL_ID_VM_DEEP_SLEEP_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_DEEP_SLEEP_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmTransmitEnable(bool enabled)
{
    IPC_VM_TRANSMIT_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.enabled = enabled;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_TRANSMIT_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmTransmitPowerSetDefault(int16 power)
{
    IPC_VM_TRANSMIT_POWER_SET_DEFAULT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.power = power;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_DEFAULT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_DEFAULT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmTransmitPowerSetMaximum(int16 power)
{
    IPC_VM_TRANSMIT_POWER_SET_MAXIMUM ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.power = power;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_MAXIMUM, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_SET_MAXIMUM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


int16 VmTransmitPowerGetDefault(void )
{
    IPC_VM_TRANSMIT_POWER_GET_DEFAULT ipc_send_prim;
    IPC_INT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_DEFAULT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_DEFAULT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


int16 VmTransmitPowerGetMaximum(void )
{
    IPC_VM_TRANSMIT_POWER_GET_MAXIMUM ipc_send_prim;
    IPC_INT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_MAXIMUM, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_GET_MAXIMUM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


int16 VmGetTemperature(void )
{
    IPC_VM_GET_TEMPERATURE ipc_send_prim;
    IPC_INT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_GET_TEMPERATURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_GET_TEMPERATURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 VmReadVrefConstant(void )
{
    IPC_VM_READ_VREF_CONSTANT ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_READ_VREF_CONSTANT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_READ_VREF_CONSTANT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool AdcReadRequest(Task task, vm_adc_source_type adc_source, vm_adc_extra_flag extra_flag, uint16 delay)
{
    IPC_ADC_READ_REQUEST ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.task = task;
    ipc_send_prim.adc_source = adc_source;
    ipc_send_prim.extra_flag = extra_flag;
    ipc_send_prim.delay = delay;
    ipc_send(IPC_SIGNAL_ID_ADC_READ_REQUEST, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_ADC_READ_REQUEST_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 PsUpdateAudioKey(uint32 key, const uint16 * buffer, uint16 words, uint16 offset, uint16 key_length)
{
    IPC_PS_UPDATE_AUDIO_KEY ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.buffer = buffer;
    ipc_send_prim.words = words;
    ipc_send_prim.offset = offset;
    ipc_send_prim.key_length = key_length;
    ipc_send(IPC_SIGNAL_ID_PS_UPDATE_AUDIO_KEY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_UPDATE_AUDIO_KEY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 PsReadAudioKey(uint32 key, uint16 * buffer, uint16 words, uint16 offset, uint16 * key_length_addr)
{
    IPC_PS_READ_AUDIO_KEY ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.buffer = buffer;
    ipc_send_prim.words = words;
    ipc_send_prim.offset = offset;
    ipc_send_prim.key_length_addr = key_length_addr;
    ipc_send(IPC_SIGNAL_ID_PS_READ_AUDIO_KEY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_READ_AUDIO_KEY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


int16 VmGetTemperatureBySensor(vm_temp_sensor sensor)
{
    IPC_VM_GET_TEMPERATURE_BY_SENSOR ipc_send_prim;
    IPC_INT16_RSP ipc_recv_prim;
    ipc_send_prim.sensor = sensor;
    ipc_send(IPC_SIGNAL_ID_VM_GET_TEMPERATURE_BY_SENSOR, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_GET_TEMPERATURE_BY_SENSOR_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void VmTransmitPowerMessagesEnable(bool enable)
{
    IPC_VM_TRANSMIT_POWER_MESSAGES_ENABLE ipc_send_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_VM_TRANSMIT_POWER_MESSAGES_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
}


vm_reset_source VmGetResetSource(void )
{
    IPC_VM_GET_RESET_SOURCE ipc_send_prim;
    IPC_VM_RESET_SOURCE_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_GET_RESET_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_GET_RESET_SOURCE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmSoftwareWdKick(uint16 timeout)
{
    IPC_VM_SOFTWARE_WD_KICK ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.timeout = timeout;
    ipc_send(IPC_SIGNAL_ID_VM_SOFTWARE_WD_KICK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_SOFTWARE_WD_KICK_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool FeatureVerifyLicense(feature_id feature)
{
    IPC_FEATURE_VERIFY_LICENSE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.feature = feature;
    ipc_send(IPC_SIGNAL_ID_FEATURE_VERIFY_LICENSE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_FEATURE_VERIFY_LICENSE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void PsSetStore(PsStores store)
{
    IPC_PS_SET_STORE ipc_send_prim;
    ipc_send_prim.store = store;
    ipc_send(IPC_SIGNAL_ID_PS_SET_STORE, &ipc_send_prim, sizeof(ipc_send_prim));
}


PsStores PsGetStore(void )
{
    IPC_PS_GET_STORE ipc_send_prim;
    IPC_PSSTORES_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_PS_GET_STORE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_GET_STORE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void PioSetWakeupStateBank(uint16 bank, uint32 mask, uint32 value)
{
    IPC_PIO_SET_WAKEUP_STATE_BANK ipc_send_prim;
    ipc_send_prim.bank = bank;
    ipc_send_prim.mask = mask;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_PIO_SET_WAKEUP_STATE_BANK, &ipc_send_prim, sizeof(ipc_send_prim));
}


void PioSetDeepSleepEitherLevelBank(uint16 bank, uint32 mask, uint32 value)
{
    IPC_PIO_SET_DEEP_SLEEP_EITHER_LEVEL_BANK ipc_send_prim;
    ipc_send_prim.bank = bank;
    ipc_send_prim.mask = mask;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_PIO_SET_DEEP_SLEEP_EITHER_LEVEL_BANK, &ipc_send_prim, sizeof(ipc_send_prim));
}


bool VmDeepSleepWakeSourcesEnable(vm_wake_source_type wake_source, bool en)
{
    IPC_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.wake_source = wake_source;
    ipc_send_prim.en = en;
    ipc_send(IPC_SIGNAL_ID_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_DEEP_SLEEP_WAKE_SOURCES_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool DormantConfigure(dormant_config_key key, uint32 value)
{
    IPC_DORMANT_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_DORMANT_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_DORMANT_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_CORE */


#if TRAPSET_NFC
void NfcSendPrim(void * msg)
{
    IPC_NFC_SEND_PRIM ipc_send_prim;
    ipc_send_prim.msg = msg;
    ipc_send(IPC_SIGNAL_ID_NFC_SEND_PRIM, &ipc_send_prim, sizeof(ipc_send_prim));
}


Sink StreamNfcSink(void )
{
    IPC_STREAM_NFC_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_STREAM_NFC_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_NFC_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_NFC */


#if TRAPSET_BLUESTACK
Sink StreamL2capSink(uint16 cid)
{
    IPC_STREAM_L2CAP_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.cid = cid;
    ipc_send(IPC_SIGNAL_ID_STREAM_L2CAP_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_L2CAP_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


uint16 SinkGetL2capCid(Sink sink)
{
    IPC_SINK_GET_L2CAP_CID ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_GET_L2CAP_CID, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_GET_L2CAP_CID_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool SinkPollAwayTime(Sink sink, uint16 * msec)
{
    IPC_SINK_POLL_AWAY_TIME ipc_send_prim;
    IPC_SINK_POLL_AWAY_TIME_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_POLL_AWAY_TIME, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_POLL_AWAY_TIME_RSP, &ipc_recv_prim);
    if (msec != NULL)
    {
      *msec = ipc_recv_prim.msec;
    }
    return ipc_recv_prim.ret;
}


bool InquirySetPriority(InquiryPriority priority)
{
    IPC_INQUIRY_SET_PRIORITY ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.priority = priority;
    ipc_send(IPC_SIGNAL_ID_INQUIRY_SET_PRIORITY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_INQUIRY_SET_PRIORITY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


InquiryPriority InquiryGetPriority(void )
{
    IPC_INQUIRY_GET_PRIORITY ipc_send_prim;
    IPC_INQUIRYPRIORITY_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_INQUIRY_GET_PRIORITY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_INQUIRY_GET_PRIORITY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool VmUpdateRootKeys(packed_root_keys * root_keys)
{
    IPC_VM_UPDATE_ROOT_KEYS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.root_keys = root_keys;
    ipc_send(IPC_SIGNAL_ID_VM_UPDATE_ROOT_KEYS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_UPDATE_ROOT_KEYS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_BLUESTACK */


#if TRAPSET_ENERGY
bool EnergyEstimationSetBounds(Sink sco, uint16 lower, uint16 upper)
{
    IPC_ENERGY_ESTIMATION_SET_BOUNDS ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sco = SINK_TO_ID(sco);
    ipc_send_prim.lower = lower;
    ipc_send_prim.upper = upper;
    ipc_send(IPC_SIGNAL_ID_ENERGY_ESTIMATION_SET_BOUNDS, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_ENERGY_ESTIMATION_SET_BOUNDS_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool EnergyEstimationOff(Sink sco)
{
    IPC_ENERGY_ESTIMATION_OFF ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sco = SINK_TO_ID(sco);
    ipc_send(IPC_SIGNAL_ID_ENERGY_ESTIMATION_OFF, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_ENERGY_ESTIMATION_OFF_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_ENERGY */


#if TRAPSET_PARTITION
Sink StreamPartitionOverwriteSink(partition_filesystem_devices device, uint16 partition)
{
    IPC_STREAM_PARTITION_OVERWRITE_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send_prim.partition = partition;
    ipc_send(IPC_SIGNAL_ID_STREAM_PARTITION_OVERWRITE_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_PARTITION_OVERWRITE_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


bool PartitionMountFilesystem(partition_filesystem_devices device, uint16 partition, partition_filesystem_priority priority)
{
    IPC_PARTITION_MOUNT_FILESYSTEM ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send_prim.partition = partition;
    ipc_send_prim.priority = priority;
    ipc_send(IPC_SIGNAL_ID_PARTITION_MOUNT_FILESYSTEM, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PARTITION_MOUNT_FILESYSTEM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool PartitionGetInfo(partition_filesystem_devices device, uint16 partition, partition_info_key key, uint32 * value)
{
    IPC_PARTITION_GET_INFO ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send_prim.partition = partition;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_PARTITION_GET_INFO, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PARTITION_GET_INFO_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool PartitionSetMessageDigest(Sink sink, partition_message_digest_type md_type, uint16 * data, uint16 len)
{
    IPC_PARTITION_SET_MESSAGE_DIGEST ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send_prim.md_type = md_type;
    ipc_send_prim.data = data;
    ipc_send_prim.len = len;
    ipc_send(IPC_SIGNAL_ID_PARTITION_SET_MESSAGE_DIGEST, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PARTITION_SET_MESSAGE_DIGEST_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Source PartitionGetRawSerialSource(uint16 device, uint16 partition)
{
    IPC_PARTITION_GET_RAW_SERIAL_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send_prim.partition = partition;
    ipc_send(IPC_SIGNAL_ID_PARTITION_GET_RAW_SERIAL_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PARTITION_GET_RAW_SERIAL_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamPartitionResumeSink(partition_filesystem_devices device, uint16 partition_no, uint16 first_word)
{
    IPC_STREAM_PARTITION_RESUME_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.device = device;
    ipc_send_prim.partition_no = partition_no;
    ipc_send_prim.first_word = first_word;
    ipc_send(IPC_SIGNAL_ID_STREAM_PARTITION_RESUME_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_PARTITION_RESUME_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


uint32 PartitionSinkGetPosition(Sink sink)
{
    IPC_PARTITION_SINK_GET_POSITION ipc_send_prim;
    IPC_UINT32_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_PARTITION_SINK_GET_POSITION, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PARTITION_SINK_GET_POSITION_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool PsStoreFsTab(const void * buff, uint16 words, bool commit)
{
    IPC_PS_STORE_FS_TAB ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.buff = buff;
    ipc_send_prim.words = words;
    ipc_send_prim.commit = commit;
    ipc_send(IPC_SIGNAL_ID_PS_STORE_FS_TAB, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PS_STORE_FS_TAB_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_PARTITION */


#if TRAPSET_USB_HUB
bool UsbHubAttach(void )
{
    IPC_USB_HUB_ATTACH ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_USB_HUB_ATTACH, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_HUB_ATTACH_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbHubDetach(void )
{
    IPC_USB_HUB_DETACH ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_USB_HUB_DETACH, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_HUB_DETACH_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbHubConfigure(const usb_device_parameters * device_params)
{
    IPC_USB_HUB_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.device_params = device_params;
    ipc_send(IPC_SIGNAL_ID_USB_HUB_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_HUB_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool UsbHubConfigKey(usb_device_cfg_key key, uint32 value)
{
    IPC_USB_HUB_CONFIG_KEY ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_USB_HUB_CONFIG_KEY, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_USB_HUB_CONFIG_KEY_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_USB_HUB */


#if TRAPSET_XIO
trap_voltsense_result XioMeasureVoltage(Task task, xio_source first_xio, xio_source second_xio, vga_gain voltage_gain)
{
    IPC_XIO_MEASURE_VOLTAGE ipc_send_prim;
    IPC_TRAP_VOLTSENSE_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.task = task;
    ipc_send_prim.first_xio = first_xio;
    ipc_send_prim.second_xio = second_xio;
    ipc_send_prim.voltage_gain = voltage_gain;
    ipc_send(IPC_SIGNAL_ID_XIO_MEASURE_VOLTAGE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_XIO_MEASURE_VOLTAGE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool DacEnable(bool enable)
{
    IPC_DAC_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_DAC_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_DAC_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


trap_voltsense_result DacSetGain(dac_buffer_gain gain)
{
    IPC_DAC_SET_GAIN ipc_send_prim;
    IPC_TRAP_VOLTSENSE_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.gain = gain;
    ipc_send(IPC_SIGNAL_ID_DAC_SET_GAIN, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_DAC_SET_GAIN_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


trap_voltsense_result DacSetLevel(uint16 level)
{
    IPC_DAC_SET_LEVEL ipc_send_prim;
    IPC_TRAP_VOLTSENSE_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.level = level;
    ipc_send(IPC_SIGNAL_ID_DAC_SET_LEVEL, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_DAC_SET_LEVEL_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_XIO */


#if TRAPSET_AMUXCLOCK
void VmAmuxClockEnable(bool enabled)
{
    IPC_VM_AMUX_CLOCK_ENABLE ipc_send_prim;
    ipc_send_prim.enabled = enabled;
    ipc_send(IPC_SIGNAL_ID_VM_AMUX_CLOCK_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
}


#endif /* TRAPSET_AMUXCLOCK */


#if TRAPSET_OTP
bool OtpReadData(uint16 * read_value, uint16 start_word, uint16 length_words)
{
    IPC_OTP_READ_DATA ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.read_value = read_value;
    ipc_send_prim.start_word = start_word;
    ipc_send_prim.length_words = length_words;
    ipc_send(IPC_SIGNAL_ID_OTP_READ_DATA, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OTP_READ_DATA_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OtpWriteData(const uint16 * write_value, uint16 start_word, uint16 length_words)
{
    IPC_OTP_WRITE_DATA ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.write_value = write_value;
    ipc_send_prim.start_word = start_word;
    ipc_send_prim.length_words = length_words;
    ipc_send(IPC_SIGNAL_ID_OTP_WRITE_DATA, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OTP_WRITE_DATA_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_OTP */


#if TRAPSET_HOST
uint16 HostSendMessage(uint16 * msg)
{
    IPC_HOST_SEND_MESSAGE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.msg = msg;
    ipc_send(IPC_SIGNAL_ID_HOST_SEND_MESSAGE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_HOST_SEND_MESSAGE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Task MessageHostCommsTask(Task task)
{
    IPC_MESSAGE_HOST_COMMS_TASK ipc_send_prim;
    IPC_TASK_RSP ipc_recv_prim;
    ipc_send_prim.task = task;
    ipc_send(IPC_SIGNAL_ID_MESSAGE_HOST_COMMS_TASK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_MESSAGE_HOST_COMMS_TASK_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_HOST */


#if TRAPSET_OPERATOR
Operator OperatorCreate(uint16 cap_id, uint16 num_keys, OperatorCreateKeys * info)
{
    IPC_OPERATOR_CREATE ipc_send_prim;
    IPC_OPERATOR_RSP ipc_recv_prim;
    ipc_send_prim.cap_id = cap_id;
    ipc_send_prim.num_keys = num_keys;
    ipc_send_prim.info = info;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_CREATE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_CREATE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorDestroyMultiple(uint16 n_ops, Operator * oplist, uint16 * success_ops)
{
    IPC_OPERATOR_DESTROY_MULTIPLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.n_ops = n_ops;
    ipc_send_prim.oplist = oplist;
    ipc_send_prim.success_ops = success_ops;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DESTROY_MULTIPLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DESTROY_MULTIPLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorStartMultiple(uint16 n_ops, Operator * oplist, uint16 * success_ops)
{
    IPC_OPERATOR_START_MULTIPLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.n_ops = n_ops;
    ipc_send_prim.oplist = oplist;
    ipc_send_prim.success_ops = success_ops;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_START_MULTIPLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_START_MULTIPLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorStopMultiple(uint16 n_ops, Operator * oplist, uint16 * success_ops)
{
    IPC_OPERATOR_STOP_MULTIPLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.n_ops = n_ops;
    ipc_send_prim.oplist = oplist;
    ipc_send_prim.success_ops = success_ops;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_STOP_MULTIPLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_STOP_MULTIPLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorResetMultiple(uint16 n_ops, Operator * oplist, uint16 * success_ops)
{
    IPC_OPERATOR_RESET_MULTIPLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.n_ops = n_ops;
    ipc_send_prim.oplist = oplist;
    ipc_send_prim.success_ops = success_ops;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_RESET_MULTIPLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_RESET_MULTIPLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


BundleID OperatorBundleLoad(FILE_INDEX index, uint16 processor)
{
    IPC_OPERATOR_BUNDLE_LOAD ipc_send_prim;
    IPC_BUNDLEID_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send_prim.processor = processor;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_BUNDLE_LOAD, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_BUNDLE_LOAD_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorBundleUnload(BundleID bundle)
{
    IPC_OPERATOR_BUNDLE_UNLOAD ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.bundle = bundle;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_BUNDLE_UNLOAD, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_BUNDLE_UNLOAD_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorFrameworkConfigurationSet(uint16 key, const uint16 * send_msg, uint16 send_len_words)
{
    IPC_OPERATOR_FRAMEWORK_CONFIGURATION_SET ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.send_msg = send_msg;
    ipc_send_prim.send_len_words = send_len_words;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_CONFIGURATION_SET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_CONFIGURATION_SET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorFrameworkEnable(OperatorFrameworkPowerState state)
{
    IPC_OPERATOR_FRAMEWORK_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.state = state;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorDelegateMultiple(Operator op_client, uint16 n_ops, Operator * oplist)
{
    IPC_OPERATOR_DELEGATE_MULTIPLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.op_client = op_client;
    ipc_send_prim.n_ops = n_ops;
    ipc_send_prim.oplist = oplist;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DELEGATE_MULTIPLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DELEGATE_MULTIPLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


DataFileID OperatorDataLoadEx(FILE_INDEX index, OperatorDataFileType type, OperatorDataStorageType storage, bool auto_remove)
{
    IPC_OPERATOR_DATA_LOAD_EX ipc_send_prim;
    IPC_DATAFILEID_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send_prim.type = type;
    ipc_send_prim.storage = storage;
    ipc_send_prim.auto_remove = auto_remove;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DATA_LOAD_EX, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DATA_LOAD_EX_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorDataUnloadEx(DataFileID file_id)
{
    IPC_OPERATOR_DATA_UNLOAD_EX ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.file_id = file_id;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DATA_UNLOAD_EX, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DATA_UNLOAD_EX_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_OPERATOR */


#if TRAPSET_AUDIO_PWM
bool AudioPwmPowerEnable(bool enable)
{
    IPC_AUDIO_PWM_POWER_ENABLE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_AUDIO_PWM_POWER_ENABLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_PWM_POWER_ENABLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void AudioPwmMute(bool enable)
{
    IPC_AUDIO_PWM_MUTE ipc_send_prim;
    ipc_send_prim.enable = enable;
    ipc_send(IPC_SIGNAL_ID_AUDIO_PWM_MUTE, &ipc_send_prim, sizeof(ipc_send_prim));
}


#endif /* TRAPSET_AUDIO_PWM */


#if TRAPSET_AUDIO
Source StreamRingtoneSource(const ringtone_note* ringtone)
{
    IPC_STREAM_RINGTONE_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.ringtone = ringtone;
    ipc_send(IPC_SIGNAL_ID_STREAM_RINGTONE_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_RINGTONE_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Source StreamAudioSource(audio_hardware hardware, audio_instance instance, audio_channel channel)
{
    IPC_STREAM_AUDIO_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.hardware = hardware;
    ipc_send_prim.instance = instance;
    ipc_send_prim.channel = channel;
    ipc_send(IPC_SIGNAL_ID_STREAM_AUDIO_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_AUDIO_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamAudioSink(audio_hardware hardware, audio_instance instance, audio_channel channel)
{
    IPC_STREAM_AUDIO_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.hardware = hardware;
    ipc_send_prim.instance = instance;
    ipc_send_prim.channel = channel;
    ipc_send(IPC_SIGNAL_ID_STREAM_AUDIO_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_AUDIO_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Sink StreamScoSink(uint16 handle)
{
    IPC_STREAM_SCO_SINK ipc_send_prim;
    IPC_SINK_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_STREAM_SCO_SINK, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SCO_SINK_RSP, &ipc_recv_prim);
    return SINK_FROM_ID(ipc_recv_prim.ret);
}


Source StreamScoSource(uint16 handle)
{
    IPC_STREAM_SCO_SOURCE ipc_send_prim;
    IPC_SOURCE_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_STREAM_SCO_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_STREAM_SCO_SOURCE_RSP, &ipc_recv_prim);
    return SOURCE_FROM_ID(ipc_recv_prim.ret);
}


uint16 SourceGetScoHandle(Source source)
{
    IPC_SOURCE_GET_SCO_HANDLE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send(IPC_SIGNAL_ID_SOURCE_GET_SCO_HANDLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SOURCE_GET_SCO_HANDLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 SinkGetScoHandle(Sink sink)
{
    IPC_SINK_GET_SCO_HANDLE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_SINK_GET_SCO_HANDLE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_SINK_GET_SCO_HANDLE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_AUDIO */


#if TRAPSET_WAKE_ON_AUDIO
bool OperatorFrameworkTriggerNotificationStart(OperatorFrameworkTriggerType type, Operator opid)
{
    IPC_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.type = type;
    ipc_send_prim.opid = opid;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_START_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorFrameworkTriggerNotificationStop(void )
{
    IPC_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_STOP ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_STOP, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_FRAMEWORK_TRIGGER_NOTIFICATION_STOP_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


DataFileID OperatorDataLoad(FILE_INDEX index, OperatorDataFileType type, bool auto_remove)
{
    IPC_OPERATOR_DATA_LOAD ipc_send_prim;
    IPC_DATAFILEID_RSP ipc_recv_prim;
    ipc_send_prim.index = index;
    ipc_send_prim.type = type;
    ipc_send_prim.auto_remove = auto_remove;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DATA_LOAD, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DATA_LOAD_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool OperatorDataUnload(DataFileID file_id)
{
    IPC_OPERATOR_DATA_UNLOAD ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.file_id = file_id;
    ipc_send(IPC_SIGNAL_ID_OPERATOR_DATA_UNLOAD, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_OPERATOR_DATA_UNLOAD_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool AudioDspClockConfigure(audio_dsp_clock_configuration * clock_config)
{
    IPC_AUDIO_DSP_CLOCK_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.clock_config = clock_config;
    ipc_send(IPC_SIGNAL_ID_AUDIO_DSP_CLOCK_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_DSP_CLOCK_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool AudioPowerSaveModeSet(audio_power_save_mode mode)
{
    IPC_AUDIO_POWER_SAVE_MODE_SET ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.mode = mode;
    ipc_send(IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_SET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_SET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


audio_power_save_mode AudioPowerSaveModeGet(void )
{
    IPC_AUDIO_POWER_SAVE_MODE_GET ipc_send_prim;
    IPC_AUDIO_POWER_SAVE_MODE_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_GET, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_AUDIO_POWER_SAVE_MODE_GET_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_WAKE_ON_AUDIO */


#if TRAPSET_PROFILE
bool VmRequestRunTimeProfile(vm_runtime_profile profile)
{
    IPC_VM_REQUEST_RUN_TIME_PROFILE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.profile = profile;
    ipc_send(IPC_SIGNAL_ID_VM_REQUEST_RUN_TIME_PROFILE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_REQUEST_RUN_TIME_PROFILE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


vm_runtime_profile VmGetRunTimeProfile(void )
{
    IPC_VM_GET_RUN_TIME_PROFILE ipc_send_prim;
    IPC_VM_RUNTIME_PROFILE_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_GET_RUN_TIME_PROFILE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_GET_RUN_TIME_PROFILE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_PROFILE */


#if TRAPSET_IIR16BIT
bool CodecSetIirFilter16Bit(uint16 channel_mask, bool enable, IIR_COEFFICIENTS * iir_coefficients)
{
    IPC_CODEC_SET_IIR_FILTER16_BIT ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.channel_mask = channel_mask;
    ipc_send_prim.enable = enable;
    ipc_send_prim.iir_coefficients = iir_coefficients;
    ipc_send(IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER16_BIT, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CODEC_SET_IIR_FILTER16_BIT_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_IIR16BIT */


#if TRAPSET_BITSERIAL
bitserial_handle BitserialOpen(bitserial_block_index block_index, const bitserial_config * config)
{
    IPC_BITSERIAL_OPEN ipc_send_prim;
    IPC_BITSERIAL_HANDLE_RSP ipc_recv_prim;
    ipc_send_prim.block_index = block_index;
    ipc_send_prim.config = config;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_OPEN, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_OPEN_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


void BitserialClose(bitserial_handle handle)
{
    IPC_BITSERIAL_CLOSE ipc_send_prim;
    IPC_VOID_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_CLOSE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_CLOSE_RSP, &ipc_recv_prim);
}


bitserial_result BitserialTransfer(bitserial_handle handle, bitserial_transfer_handle * transfer_handle_ptr, const uint8 * tx_data, uint16 tx_size, uint8 * rx_data, uint16 rx_size)
{
    IPC_BITSERIAL_TRANSFER ipc_send_prim;
    IPC_BITSERIAL_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send_prim.transfer_handle_ptr = transfer_handle_ptr;
    ipc_send_prim.tx_data = tx_data;
    ipc_send_prim.tx_size = tx_size;
    ipc_send_prim.rx_data = rx_data;
    ipc_send_prim.rx_size = rx_size;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_TRANSFER, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_TRANSFER_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bitserial_result BitserialWrite(bitserial_handle handle, bitserial_transfer_handle * transfer_handle_ptr, const uint8 * data, uint16 size, bitserial_transfer_flags flags)
{
    IPC_BITSERIAL_WRITE ipc_send_prim;
    IPC_BITSERIAL_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send_prim.transfer_handle_ptr = transfer_handle_ptr;
    ipc_send_prim.data = data;
    ipc_send_prim.size = size;
    ipc_send_prim.flags = flags;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_WRITE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_WRITE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bitserial_result BitserialRead(bitserial_handle handle, bitserial_transfer_handle * transfer_handle_ptr, uint8 * data, uint16 size, bitserial_transfer_flags flags)
{
    IPC_BITSERIAL_READ ipc_send_prim;
    IPC_BITSERIAL_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send_prim.transfer_handle_ptr = transfer_handle_ptr;
    ipc_send_prim.data = data;
    ipc_send_prim.size = size;
    ipc_send_prim.flags = flags;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_READ, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_READ_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bitserial_result BitserialChangeParam(bitserial_handle handle, bitserial_changeable_params key, uint16 value, bitserial_transfer_flags flags)
{
    IPC_BITSERIAL_CHANGE_PARAM ipc_send_prim;
    IPC_BITSERIAL_RESULT_RSP ipc_recv_prim;
    ipc_send_prim.handle = handle;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send_prim.flags = flags;
    ipc_send(IPC_SIGNAL_ID_BITSERIAL_CHANGE_PARAM, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_BITSERIAL_CHANGE_PARAM_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_BITSERIAL */


#if TRAPSET_CRYPTO
bool CryptoAes128Ctr(const uint8 * key, const uint8 * nonce, uint16 flags, uint32 counter, const uint8 * source_data, uint16 source_data_len_bytes, uint8 * dest_data, uint16 dest_data_len_bytes)
{
    IPC_CRYPTO_AES128_CTR ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.key = key;
    ipc_send_prim.nonce = nonce;
    ipc_send_prim.flags = flags;
    ipc_send_prim.counter = counter;
    ipc_send_prim.source_data = source_data;
    ipc_send_prim.source_data_len_bytes = source_data_len_bytes;
    ipc_send_prim.dest_data = dest_data;
    ipc_send_prim.dest_data_len_bytes = dest_data_len_bytes;
    ipc_send(IPC_SIGNAL_ID_CRYPTO_AES128_CTR, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CRYPTO_AES128_CTR_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


bool CryptoAes128Cbc(bool encrypt, const uint8 * key, uint8 * nonce, uint16 flags, const uint8 * source_data, uint16 source_data_len_bytes, uint8 * dest_data, uint16 dest_data_len_bytes)
{
    IPC_CRYPTO_AES128_CBC ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.encrypt = encrypt;
    ipc_send_prim.key = key;
    ipc_send_prim.nonce = nonce;
    ipc_send_prim.flags = flags;
    ipc_send_prim.source_data = source_data;
    ipc_send_prim.source_data_len_bytes = source_data_len_bytes;
    ipc_send_prim.dest_data = dest_data;
    ipc_send_prim.dest_data_len_bytes = dest_data_len_bytes;
    ipc_send(IPC_SIGNAL_ID_CRYPTO_AES128_CBC, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CRYPTO_AES128_CBC_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_CRYPTO */


#if TRAPSET_BDADDR
#endif /* TRAPSET_BDADDR */


#if TRAPSET_KALIMBA
uint32 PioGetKalimbaControl32(void )
{
    IPC_PIO_GET_KALIMBA_CONTROL32 ipc_send_prim;
    IPC_UINT32_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_PIO_GET_KALIMBA_CONTROL32, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PIO_GET_KALIMBA_CONTROL32_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint32 PioSetKalimbaControl32(uint32 mask, uint32 value)
{
    IPC_PIO_SET_KALIMBA_CONTROL32 ipc_send_prim;
    IPC_UINT32_RSP ipc_recv_prim;
    ipc_send_prim.mask = mask;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_PIO_SET_KALIMBA_CONTROL32, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PIO_SET_KALIMBA_CONTROL32_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


Transform TransformRtpEncode(Source source, Sink sink)
{
    IPC_TRANSFORM_RTP_ENCODE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_RTP_ENCODE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_RTP_ENCODE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


Transform TransformRtpDecode(Source source, Sink sink)
{
    IPC_TRANSFORM_RTP_DECODE ipc_send_prim;
    IPC_TRANSFORM_RSP ipc_recv_prim;
    ipc_send_prim.source = SOURCE_TO_ID(source);
    ipc_send_prim.sink = SINK_TO_ID(sink);
    ipc_send(IPC_SIGNAL_ID_TRANSFORM_RTP_DECODE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TRANSFORM_RTP_DECODE_RSP, &ipc_recv_prim);
    return TRANSFORM_FROM_ID(ipc_recv_prim.ret);
}


#endif /* TRAPSET_KALIMBA */


#if TRAPSET_CHARGERMESSAGE
charger_events ChargerDebounce(charger_events events_to_enable, uint16 count, uint16 period)
{
    IPC_CHARGER_DEBOUNCE ipc_send_prim;
    IPC_CHARGER_EVENTS_RSP ipc_recv_prim;
    ipc_send_prim.events_to_enable = events_to_enable;
    ipc_send_prim.count = count;
    ipc_send_prim.period = period;
    ipc_send(IPC_SIGNAL_ID_CHARGER_DEBOUNCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_CHARGER_DEBOUNCE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_CHARGERMESSAGE */


#if TRAPSET_TEST
bool TestPerform_(uint16 len, const uint16 * args)
{
    IPC_TEST_PERFORM_ ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.len = len;
    ipc_send_prim.args = args;
    ipc_send(IPC_SIGNAL_ID_TEST_PERFORM_, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_TEST_PERFORM__RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_TEST */


#if TRAPSET_PSU
bool PsuConfigure(psu_id psu, psu_config_key key, uint16 value)
{
    IPC_PSU_CONFIGURE ipc_send_prim;
    IPC_BOOL_RSP ipc_recv_prim;
    ipc_send_prim.psu = psu;
    ipc_send_prim.key = key;
    ipc_send_prim.value = value;
    ipc_send(IPC_SIGNAL_ID_PSU_CONFIGURE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_PSU_CONFIGURE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


uint16 VmGetPowerSource(void )
{
    IPC_VM_GET_POWER_SOURCE ipc_send_prim;
    IPC_UINT16_RSP ipc_recv_prim;
    ipc_send(IPC_SIGNAL_ID_VM_GET_POWER_SOURCE, &ipc_send_prim, sizeof(ipc_send_prim));
    assert(!ipc_disallow_high_priority_handler_calls());
    (void)ipc_recv(IPC_SIGNAL_ID_VM_GET_POWER_SOURCE_RSP, &ipc_recv_prim);
    return ipc_recv_prim.ret;
}


#endif /* TRAPSET_PSU */


